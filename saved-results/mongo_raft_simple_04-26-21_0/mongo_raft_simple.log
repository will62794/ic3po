
Printing isolate this:
OK
	(mode: ic3po)
	(reuse: 1)
	(opt: 1)
	(const: 1)
	(wires: 1)
	(using z3 4.8.10.0 with seed 0)
@     0s  Reading from file results/mongo_raft_simple/mongo_raft_simple.vmt
-----------------------------------------------------------------

Action inputs:
	ext:commitEntry: set([V__fml:i, V__fml:q])
	ext:becomeLeader: set([V__fml:i, V__fml:newterm, V__fml:q])
	ext:clientRequest: set([V__fml:i, V__fml:nextInd])

Action definitions:
	ext:commitEntry: {}
	ext:becomeLeader: {}
	ext:clientRequest: {}

Action preconditions:

	ext:commitEntry:
		member(V__fml:i, V__fml:q)
		~(__loglen(V__fml:i) = indzero)
		(forall X . (member(X, V__fml:q) -> (__currentTerm(X) = __currentTerm(V__fml:i))))
		__leader(V__fml:i)
		(forall X . (member(X, V__fml:q) -> (indlte(__loglen(X), __loglen(V__fml:i)) & (__log(X, __loglen(V__fml:i)) = __log(V__fml:i, __loglen(V__fml:i))))))

	ext:becomeLeader:
		~(V__fml:newterm = termzero)
		lte(__currentTerm(V__fml:i), V__fml:newterm)
		~(V__fml:newterm = __currentTerm(V__fml:i))
		member(V__fml:i, V__fml:q)
		(forall X . (member(X, V__fml:q) -> ((__loglen(X) = indzero) | ((__log(V__fml:i, __loglen(V__fml:i)) = __log(X, __loglen(X))) & indlt(__loglen(V__fml:i), __loglen(X))) | (lte(__log(X, __loglen(X)), __log(V__fml:i, __loglen(V__fml:i))) & ~(__log(X, __loglen(X)) = __log(V__fml:i, __loglen(V__fml:i)))))))
		(forall X . (member(X, V__fml:q) -> (lte(__currentTerm(X), V__fml:newterm) & ~(__currentTerm(X) = V__fml:newterm))))

	ext:clientRequest:
		succ(__loglen(V__fml:i), V__fml:nextInd)
		__leader(V__fml:i)

Action postconditions:

	ext:commitEntry:
		(forall V038, V139 . (committed(V038, V139) <-> (((V038 = __loglen(V__fml:i)) & (V139 = __log(V__fml:i, __loglen(V__fml:i)))) ? True : __committed(V038, V139))))

	ext:becomeLeader:
		(forall V0 . (currentTerm(V0) = (member(V0, V__fml:q) ? V__fml:newterm : __currentTerm(V0))))
		(forall V0 . (leader(V0) <-> ((V0 = V__fml:i) ? True : (member(V0, V__fml:q) ? False : __leader(V0)))))

	ext:clientRequest:
		(forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:i) & (V1 = V__fml:nextInd)) ? __currentTerm(V__fml:i) : __log(V0, V1))))
		(forall V0 . (loglen(V0) = ((V0 = V__fml:i) ? V__fml:nextInd : __loglen(V0))))

Update map:
	log ->  ext:clientRequest
	currentTerm ->  ext:becomeLeader
	loglen ->  ext:clientRequest
	committed ->  ext:commitEntry
	leader ->  ext:becomeLeader

stratifying state variables:
	function arc: server -> term
	function arc: server -> index
	function arc: server -> term
	function arc: index -> term

stratifying axioms:
	skolem arc: quorum -> server

stratifying action ext:clientRequest:

stratifying action ext:becomeLeader:

stratifying action ext:commitEntry:

stratifying property:
    pos:
    neg:
	(epr: True)

stratifying helpers:

Arcs:
	index -> term
	quorum -> server
	server -> index term

EPR: True
-----------------------------------------------------------------
	(gen: prefer_epr)
-----------------------------------------------------------------
	(found #3 actions)
adding #3 noops to action ext:clientRequest
	noop(currentTerm)
	noop(committed)
	noop(leader)
adding #3 noops to action ext:becomeLeader
	noop(log)
	noop(loglen)
	noop(committed)
adding #4 noops to action ext:commitEntry
	noop(log)
	noop(currentTerm)
	noop(loglen)
	noop(leader)
-----------------------------------------------------------------
Init #1
	((forall V0 . ~__leader(V0)) & (forall V0 . (__currentTerm(V0) = termzero)) & (forall V0 . (__loglen(V0) = indzero)) & (forall V0, V1 . (__log(V0, V1) = termzero)) & (forall V036, V137 . ~__committed(V036, V137)))
		with variables frozenset([indzero, __currentTerm, __loglen, __committed, __leader, __log, termzero])

Axioms #12
	(forall Y, X24 . (~lte(X24, Y) | ~lte(Y, X24) | (X24 = Y)))
		with variables frozenset([lte])
	(forall X33, Y34, Z35 . (succ(X33, Z35) -> (indlt(X33, Z35) & ~(indlt(X33, Y34) & indlt(Y34, Z35)))))
		with variables frozenset([indlt, succ])
	(forall Y, X25 . (lte(X25, Y) | lte(Y, X25)))
		with variables frozenset([lte])
	(forall A, B . ((indlte(A, B) <-> indlt(A, B)) | (A = B)))
		with variables frozenset([indlte, indlt])
	(forall Q1, Q2 . (exists N . (member(N, Q1) & member(N, Q2))))
		with variables frozenset([member])
	(forall X21 . lte(termzero, X21))
		with variables frozenset([lte, termzero])
	(forall X22 . lte(X22, X22))
		with variables frozenset([lte])
	(forall X29 . ~indlt(X29, X29))
		with variables frozenset([indlt])
	(forall X23, Y, Z . (~lte(X23, Y) | ~lte(Y, Z) | lte(X23, Z)))
		with variables frozenset([lte])
	(forall X30, Y31 . (indlt(X30, Y31) | (X30 = Y31) | indlt(Y31, X30)))
		with variables frozenset([indlt])
	(forall Y27, Z28, X26 . ((indlt(X26, Y27) & indlt(Y27, Z28)) -> indlt(X26, Z28)))
		with variables frozenset([indlt])
	(forall X32 . ((X32 = indzero) | indlt(indzero, X32)))
		with variables frozenset([indzero, indlt])

Actions #4
	0:	ext:clientRequest (en: en_ext:clientRequest)	(((forall V0, V1 . (...(..., ...) = (... ? ... : ...))) & (forall V0 . (...(...) = (... ? ... : ...))) & __leader(V__fml:i) & succ(__loglen(V__fml:i), V__fml:nextInd)) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([__currentTerm, __loglen, V__fml:i, V__fml:nextInd, __log, currentTerm, loglen, committed, leader, log, __committed, __leader, succ])
	1:	ext:becomeLeader (en: en_ext:becomeLeader)	(((forall V0 . (...(...) = (... ? ... : ...))) & (forall V0 . (...(...) <-> (... ? ... : ...))) & ~(V__fml:newterm = termzero) & lte(__currentTerm(V__fml:i), V__fml:newterm) & ~(V__fml:newterm = ...(...)) & member(V__fml:i, V__fml:q) & (forall X . (...(..., ...) -> (... & ...))) & (forall X . (...(..., ...) -> (... | ... | ...)))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))))
		with variables frozenset([__currentTerm, __loglen, __committed, __leader, __log, currentTerm, loglen, committed, leader, log, member, termzero, indzero, lte, indlt, V__fml:i, V__fml:newterm, V__fml:q])
	2:	ext:commitEntry (en: en_ext:commitEntry)	(((forall V038, V139 . (...(..., ...) <-> (... ? ... : ...))) & __leader(V__fml:i) & ~(...(...) = indzero) & member(V__fml:i, V__fml:q) & (forall X . (...(..., ...) -> (... = ...))) & (forall X . (...(..., ...) -> (... & ...)))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([indzero, indlte, __currentTerm, __loglen, V__fml:i, __leader, __log, currentTerm, loglen, committed, leader, log, member, __committed, V__fml:q])
	3:	noop (en: en_noop)	((forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([__currentTerm, __loglen, __committed, __leader, __log, currentTerm, loglen, committed, leader, log])

Properties #1
	(forall I, T, X . ((__committed(I, T) & __leader(X) & (...(..., ...) & ~...)) -> (__log(X, I) = T)))
		with variables frozenset([lte, __currentTerm, __committed, __leader, __log])

Variables #21
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	__currentTerm of type server -> term
	__loglen of type server -> index
	V__fml:i of type server
	V__fml:nextInd of type index
	__log of type server -> index -> term
	currentTerm of type server -> term
	loglen of type server -> index
	committed of type index -> term -> Bool
	leader of type server -> Bool
	log of type server -> index -> term
	__leader of type server -> Bool
	__committed of type index -> term -> Bool
	member of type server -> quorum -> Bool
	V__fml:newterm of type term
	V__fml:q of type quorum
	succ of type index -> index -> Bool
	termzero of type term

State variables #12
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	__currentTerm of type server -> term
	__loglen of type server -> index
	__committed of type index -> term -> Bool
	__leader of type server -> Bool
	__log of type server -> index -> term
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Nex state variables #12
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	currentTerm of type server -> term
	loglen of type server -> index
	committed of type index -> term -> Bool
	leader of type server -> Bool
	log of type server -> index -> term
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Global variables #7
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Ordered variables #0

Nex to pre #5
	log <- __log
	currentTerm <- __currentTerm
	loglen <- __loglen
	committed <- __committed
	leader <- __leader

Pre to nex #5
	__loglen -> loglen
	__committed -> committed
	__leader -> leader
	__log -> log
	__currentTerm -> currentTerm

Other variables #4
	V__fml:i of type server
	V__fml:nextInd of type index
	V__fml:newterm of type term
	V__fml:q of type quorum

Axiom variables #7
	indzero
	lte
	indlte
	indlt
	member
	succ
	termzero

Predicates #0

Helpers #0

Inferences #0

Definitions #0

Trel:
((en_ext:clientRequest -> (((forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:i) & (V1 = V__fml:nextInd)) ? __currentTerm(V__fml:i) : __log(V0, V1)))) & (forall V0 . (loglen(V0) = ((V0 = V__fml:i) ? V__fml:nextInd : __loglen(V0)))) & __leader(V__fml:i) & succ(__loglen(V__fml:i), V__fml:nextInd)) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:becomeLeader -> (((forall V0 . (currentTerm(V0) = (member(V0, V__fml:q) ? V__fml:newterm : __currentTerm(V0)))) & (forall V0 . (leader(V0) <-> ((V0 = V__fml:i) ? True : (member(V0, V__fml:q) ? False : __leader(V0))))) & ~(V__fml:newterm = termzero) & lte(__currentTerm(V__fml:i), V__fml:newterm) & ~(V__fml:newterm = __currentTerm(V__fml:i)) & member(V__fml:i, V__fml:q) & (forall X . (member(X, V__fml:q) -> (lte(__currentTerm(X), V__fml:newterm) & ~(__currentTerm(X) = V__fml:newterm)))) & (forall X . (member(X, V__fml:q) -> ((__loglen(X) = indzero) | ((__log(V__fml:i, __loglen(V__fml:i)) = __log(X, __loglen(X))) & indlt(__loglen(V__fml:i), __loglen(X))) | (lte(__log(X, __loglen(X)), __log(V__fml:i, __loglen(V__fml:i))) & ~(__log(X, __loglen(X)) = __log(V__fml:i, __loglen(V__fml:i)))))))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))))) & (en_ext:commitEntry -> (((forall V038, V139 . (committed(V038, V139) <-> (((V038 = __loglen(V__fml:i)) & (V139 = __log(V__fml:i, __loglen(V__fml:i)))) ? True : __committed(V038, V139)))) & __leader(V__fml:i) & ~(__loglen(V__fml:i) = indzero) & member(V__fml:i, V__fml:q) & (forall X . (member(X, V__fml:q) -> (__currentTerm(X) = __currentTerm(V__fml:i)))) & (forall X . (member(X, V__fml:q) -> (indlte(__loglen(X), __loglen(V__fml:i)) & (__log(X, __loglen(V__fml:i)) = __log(V__fml:i, __loglen(V__fml:i))))))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_noop -> ((forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:clientRequest | en_ext:becomeLeader | en_ext:commitEntry | en_noop) & (~en_ext:clientRequest | ~en_ext:becomeLeader) & (~en_ext:clientRequest | ~en_ext:commitEntry) & (~en_ext:clientRequest | ~en_noop) & (~en_ext:becomeLeader | ~en_ext:commitEntry) & (~en_ext:becomeLeader | ~en_noop) & (~en_ext:commitEntry | ~en_noop))
-----------------------------------------------------------------
(enumsort) index <-> index:e0:
	[ INDEX0, INDEX1, ] <-> [ i0, i1, ]
(enumsort) quorum <-> quorum:e0:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e0:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
(enumsort) term <-> term:e0:
	[ TERM0, TERM1, ] <-> [ t0, t1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
(use_wires: False)

Checking property...

@     2s  Storing init values:
@     2s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlte(i0, i1)
	lte(t0, t0)
	lte(t0, t1)
	lte(t1, t1)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i1, t0)
	~committed(i1, t1)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~lte(t1, t0)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i1, i0)
	~succ(i1, i1)

@     2s  F[0] /\ !P -> UNSAT
@     2s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
@     2s  
Adding frame 1...
@     2s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e0 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm -> t1
		V__fml -> s0
		V__fml:q -> q0
@     2s  F[0] /\ T /\ C+ ?
@     2s  	Ans. UNSAT
@     2s  F[1] unsat core #1 	(ucsz: 1 -> 1)
(minimal unsat core)
	committed(i0, t0)
(clause)
	~committed(i0, t0)
(relations)
	committed
(cube: std)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall INDEX0, TERM0 . ~committed(INDEX0, TERM0))
---------------------------
(original clause)
	~committed(i0, t0)
(learnt sym-boosted clause)
	(forall INDEX0, TERM0 . ~committed(INDEX0, TERM0))
---------------------------
(clause-type: univ)	(forall I0, T0 . ~committed(I0, T0))
@     2s  is global clause? No
@     2s  Learning in F[1]: (forall I0, T0 . ~committed(I0, T0))
@     2s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     2s  F[0] /\ T /\ C+ ?
@     2s  	Ans. UNSAT
@     3s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(indzero = i1)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i1) | ~(loglen(s0) = i0))
(relations)
	indzero
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
(antecedent reduction)
@     3s  antecedent: 2 -> 2

(eq map)
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	INDEX0
	SERVER0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = indzero)
(fullsorts)
	index:e0: -> [ INDEX0, indzero, ]
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(original clause)
	(~(indzero = i1) | ~(loglen(s0) = i0))
(learnt sym-boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(clause-type: univ)	(forall S0 . (loglen(S0) = indzero))
@     3s  is global clause? No
@     3s  Learning in F[1]: (forall S0 . (loglen(S0) = indzero))
@     3s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, T0 . ~committed(I0, T0))
@     3s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #1 to F[2]
@     3s  Learning in F[2]: (forall I0, T0 . ~committed(I0, T0))
@     3s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     3s  F[1] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[2] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(indzero = i1)
	~succ(i1, i0)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i1) | ~(loglen(s0) = i0) | succ(i1, i0))
(relations)
	indzero
	succ
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
	~succ(INDEX1, INDEX0)
(antecedent reduction)
@     3s  antecedent: 2 -> 2

(eq map)
	INDEX1 -> indzero
(cube eq)
	~succ(indzero, INDEX0)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	INDEX0
	SERVER0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = indzero)
(fullsorts)
	index:e0: -> [ INDEX0, indzero, ]
qv2cubes #2
	INDEX0 -> [ ~succ(indzero, INDEX0), (loglen(SERVER0) = INDEX0), ]
	indzero -> [ ~succ(indzero, INDEX0), ]
qv2ucubes #2
	INDEX0 -> [ ~succ(indzero, V:index:e0:), (loglen(SERVER0) = V:index:e0:), ]
	indzero -> [ ~succ(V:index:e0:, INDEX0), ]
ucubes2qv #2
	~succ(V:index:e0:, INDEX0) -> [ indzero, ]
	((loglen(SERVER0) = V:index:e0:) & ~succ(indzero, V:index:e0:)) -> [ INDEX0, ]
(partition) #2 index:e0: -> { indzero, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~succ(indzero, loglen(SERVER0))
	~(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (loglen(SERVER0) = indzero)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(loglen(s0) = i0) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (loglen(SERVER0) = indzero)))
---------------------------
(clause-type: univ)	(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     3s  is global clause? Yes
@     3s  Learning in F[2]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     3s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     3s  F[1] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[2] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(indzero = i1)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
(clause)
	(~(indzero = i1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(relations)
	indzero
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
(antecedent reduction)
@     3s  antecedent: 4 -> 4

(eq map)
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	INDEX0
	SERVER0
	SERVER1
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = indzero)
	server:e0:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	index:e0: -> [ INDEX0, indzero, ]
	server:e0: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), (loglen(SERVER0) = INDEX0), ]
	indzero -> [ ]
qv2ucubes #2
	INDEX0 -> [ (loglen(SERVER1) = V:index:e0:), (loglen(SERVER0) = V:index:e0:), ]
	indzero -> [ ]
ucubes2qv #2
	((loglen(SERVER0) = V:index:e0:) & (loglen(SERVER1) = V:index:e0:)) -> [ INDEX0, ]
	true -> [ indzero, ]
(partition) #2 index:e0: -> { INDEX0, | indzero, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e0:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e0: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX0 . (~(loglen(SERVER0) = INDEX0) | (INDEX0 = indzero))))
(non-epr version)
	(forall INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | (INDEX0 = indzero))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX0 . (~(loglen(SERVER0) = INDEX0) | (INDEX0 = indzero))))
---------------------------
(original clause)
	(~(indzero = i1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX0 . (~(loglen(SERVER0) = INDEX0) | (INDEX0 = indzero))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
@     3s  is global clause? No
@     3s  Learning in F[2]: (exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
@     3s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     3s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i0
		V__fml -> s0
@     3s  	Ans. SAT
@     3s  F[0] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(termzero = t0)
	(log(s1, i0) = t1)
(clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0))
(relations)
	termzero
	log
(fullsorts)
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(termzero = TERM0)
(antecedent reduction)
@     3s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	INDEX0
	SERVER0
	TERM1
(antecedent eq)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	term:e0: -> [ termzero, TERM1, ]
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER0, INDEX0))
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(original clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(clause-type: univ)	(forall I0, S0 . (termzero = log(S0, I0)))
@     3s  is global clause? No
@     3s  Learning in F[1]: (forall I0, S0 . (termzero = log(S0, I0)))
@     3s  F[1] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[2] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(indzero = i1)
	(log(s1, i1) = t1)
(clause)
	(~(indzero = i1) | ~(log(s1, i1) = t1) | ~(termzero = t0))
(relations)
	indzero
	termzero
	log
(fullsorts)
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(indzero = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@     3s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	SERVER0
	TERM1
(antecedent eq)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	term:e0: -> [ termzero, TERM1, ]
(eq map: post)
	TERM1 -> log(SERVER0, indzero)
(cube eq: post)
	~(termzero = log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (termzero = log(SERVER0, indzero)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s1, i1) = t1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0 . (termzero = log(SERVER0, indzero)))
---------------------------
(clause-type: univ)	(forall S0 . (termzero = log(S0, indzero)))
@     3s  is global clause? Yes
@     3s  Learning in F[2]: (forall S0 . (termzero = log(S0, indzero)))
@     3s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     3s  F[1] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[2] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(log(s1, i0) = t1)
	(loglen(s1) = i1)
(clause)
	(~(log(s1, i0) = t1) | ~(loglen(s1) = i1) | ~(termzero = t0))
(relations)
	loglen
	termzero
	log
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX1)
	(termzero = TERM0)
(antecedent reduction)
@     3s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	INDEX0
	INDEX1
	SERVER0
	TERM1
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = INDEX1)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ termzero, TERM1, ]
qv2cubes #2
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM1), ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	INDEX0 -> [ (log(SERVER0, V:index:e0:) = TERM1), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e0:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e0:) -> [ INDEX1, ]
	(log(SERVER0, V:index:e0:) = TERM1) -> [ INDEX0, ]
(partition) #2 index:e0: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e0:), ]
ucubes2qv #2
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { termzero, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = loglen(SERVER0))
	~(termzero = log(SERVER0, INDEX0))
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . ((INDEX0 = loglen(SERVER0)) | (termzero = log(SERVER0, INDEX0))))
---------------------------
(original clause)
	(~(log(s1, i0) = t1) | ~(loglen(s1) = i1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . ((INDEX0 = loglen(SERVER0)) | (termzero = log(SERVER0, INDEX0))))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
@     3s  is global clause? No
@     3s  Learning in F[2]: (forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
@     3s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (termzero = log(S0, I0)))
	F[2]: #5
		(exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
		(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
		(forall S0 . (termzero = log(S0, indzero)))
		(forall I0, T0 . ~committed(I0, T0))
@     3s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #3 to F[3]
@     3s  Learning in F[3]: (forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
@     3s  Learning in F[3]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     3s  Learning in F[3]: (forall S0 . (termzero = log(S0, indzero)))
@     3s  Learning in F[3]: (forall S0 . (termzero = log(S0, indzero)))
@     3s  Learning in F[3]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     3s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s0
@     3s  F[2] /\ T /\ C+ ?
@     3s  	Ans. UNSAT
@     3s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	committed(i1, t0)
	~indlte(i1, i1)
(clause)
	(~committed(i1, t0) | indlte(i1, i1))
(relations)
	indlte
	committed
(cube: std)
	committed(INDEX0, TERM0)
	~indlte(INDEX0, INDEX0)

(boosted clause)
	(forall INDEX0, TERM0 . (~committed(INDEX0, TERM0) | indlte(INDEX0, INDEX0)))
---------------------------
(original clause)
	(~committed(i1, t0) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0 . (~committed(INDEX0, TERM0) | indlte(INDEX0, INDEX0)))
---------------------------
(clause-type: univ)	(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     3s  is global clause? Yes
@     3s  Learning in F[3]: (forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     3s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s0
@     4s  F[2] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[3] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	committed(i1, t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(relations)
	loglen
	committed
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
(antecedent reduction)
@     4s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #2
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
qv2ucubes #2
	INDEX0 -> [ (loglen(SERVER1) = V:index:e0:), (loglen(SERVER0) = V:index:e0:), ]
	INDEX1 -> [ committed(V:index:e0:, TERM0), ]
ucubes2qv #2
	((loglen(SERVER0) = V:index:e0:) & (loglen(SERVER1) = V:index:e0:)) -> [ INDEX0, ]
	committed(V:index:e0:, TERM0) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e0:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e0: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX0, TERM0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
(non-epr version)
	(forall INDEX0, TERM0, INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall INDEX0, TERM0, INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0, INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
---------------------------
(clause-type: non-epr)	(forall I0, T0, I1 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
@     4s  is global clause? No
@     4s  Learning in F[3]: (forall I0, T0, I1 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
@     4s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s0
@     4s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s1
		V__fml:q -> q0
@     4s  	Ans. SAT
@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(indzero = i0)
	(currentTerm(s1) = t1)
	(log(s1, i1) = t0)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s1) = t1) | ~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i1))
(relations)
	currentTerm
	indzero
	log
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(indzero = INDEX0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@     4s  antecedent: 4 -> 4

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(qvars eq)
	TERM0
	INDEX1
	SERVER0
	TERM1
(antecedent eq)
	index:e0:
	-> ~(indzero = INDEX1)
	term:e0:
	-> ~(TERM0 = TERM1)
(fullsorts)
	index:e0: -> [ indzero, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
qv2cubes #2
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = TERM0), ]
	indzero -> [ ]
qv2ucubes #2
	INDEX1 -> [ (loglen(SERVER0) = V:index:e0:), (log(SERVER0, V:index:e0:) = TERM0), ]
	indzero -> [ ]
ucubes2qv #2
	true -> [ indzero, ]
	((log(SERVER0, V:index:e0:) = TERM0) & (loglen(SERVER0) = V:index:e0:)) -> [ INDEX1, ]
(partition) #2 index:e0: -> { indzero, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER0, INDEX1) = V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e0:), ]
ucubes2qv #2
	(log(SERVER0, INDEX1) = V:term:e0:) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { TERM0, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX1 -> loglen(SERVER0)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i1))
(learnt sym-boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0))))
@     4s  is global clause? No
@     4s  Learning in F[2]: (forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0))))
@     4s  F[2] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[3] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	committed(i1, t0)
	(currentTerm(s1) = t1)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s1) = t1) | ~(loglen(s1) = i1) | ~committed(i1, t0))
(relations)
	currentTerm
	loglen
	committed
(fullsorts)
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	committed(INDEX0, TERM0)
	(loglen(SERVER0) = INDEX0)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@     4s  antecedent: 2 -> 2

qv2cubes #2
	TERM0 -> [ committed(INDEX0, TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ committed(INDEX0, V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e0:), ]
ucubes2qv #2
	committed(INDEX0, V:term:e0:) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { TERM0, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	committed(loglen(SERVER0), TERM0)
	~(TERM0 = currentTerm(SERVER0))
(qvars eq: post)
	TERM0
	SERVER0
(boosted clause)
	(forall TERM0, SERVER0 . (~committed(loglen(SERVER0), TERM0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(loglen(s1) = i1) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0 . (~committed(loglen(SERVER0), TERM0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall T0, S0 . (committed(loglen(S0), T0) -> (T0 = currentTerm(S0))))
@     4s  is global clause? No
@     4s  Learning in F[3]: (forall T0, S0 . (committed(loglen(S0), T0) -> (T0 = currentTerm(S0))))
@     4s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s0
@     4s  F[2] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[3] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	committed(i1, t0)
	(loglen(s0) = i0)
	~leader(s1)
(clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s1))
(relations)
	loglen
	committed
	leader
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
(antecedent reduction)
@     4s  antecedent: 4 -> 4

qv2cubes #2
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
qv2ucubes #2
	INDEX0 -> [ (loglen(SERVER0) = V:index:e0:), ]
	INDEX1 -> [ committed(V:index:e0:, TERM0), ]
ucubes2qv #2
	committed(V:index:e0:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER0) = V:index:e0:) -> [ INDEX0, ]
(partition) #2 index:e0: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ ~leader(V:server:e0:), ]
ucubes2qv #2
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, ]
	~leader(V:server:e0:) -> [ SERVER1, ]
(partition) #2 server:e0: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = INDEX1)
	~(SERVER0 = SERVER1)
	committed(INDEX1, TERM0)
	~leader(SERVER1)
(qvars eq: post)
	TERM0
	SERVER0
	INDEX1
	SERVER1
(boosted clause)
	(forall TERM0, SERVER0, INDEX1, SERVER1 . ((loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | ~committed(INDEX1, TERM0) | leader(SERVER1)))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s1))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, INDEX1, SERVER1 . ((loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | ~committed(INDEX1, TERM0) | leader(SERVER1)))
---------------------------
(clause-type: univ)	(forall T0, S0, I1, S1 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
@     4s  is global clause? No
@     4s  Learning in F[3]: (forall T0, S0, I1, S1 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
@     4s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     4s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s0
@     4s  	Ans. SAT
@     4s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i1
		V__fml -> s1
@     4s  	Ans. SAT
@     4s  F[0] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[1] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(currentTerm(s0) = t0)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	currentTerm
	termzero
	leader
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     4s  is global clause? Yes
@     4s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(currentTerm(s0) = t0)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	currentTerm
	termzero
	leader
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     4s  is global clause? Yes
@     4s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     4s  F[2] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     5s  F[3] unsat core #3 	(ucsz: 7 -> 3 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(currentTerm(s0) = t0)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	currentTerm
	termzero
	leader
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  is global clause? Yes
@     5s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
@     5s  F[2] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[3] unsat core #5 	(ucsz: 12 -> 10 -> 6 -> 6 -> 5 -> 5)
(minimal unsat core)
	(indzero = i0)
	(loglen(s0) = i1)
	(log(s0, i1) = t0)
	leader(s0)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~leader(s0))
(relations)
	currentTerm
	indzero
	loglen
	log
	leader
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(indzero = INDEX0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM1)
	leader(SERVER0)
(antecedent reduction)
@     5s  antecedent: 4 -> 4

(eq map)
	INDEX0 -> indzero
(cube eq)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(qvars eq)
	TERM0
	INDEX1
	SERVER0
	TERM1
(antecedent eq)
	index:e0:
	-> ~(indzero = INDEX1)
	term:e0:
	-> ~(TERM0 = TERM1)
(fullsorts)
	index:e0: -> [ indzero, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
qv2cubes #2
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = TERM0), ]
	indzero -> [ ]
qv2ucubes #2
	INDEX1 -> [ (loglen(SERVER0) = V:index:e0:), (log(SERVER0, V:index:e0:) = TERM0), ]
	indzero -> [ ]
ucubes2qv #2
	true -> [ indzero, ]
	((log(SERVER0, V:index:e0:) = TERM0) & (loglen(SERVER0) = V:index:e0:)) -> [ INDEX1, ]
(partition) #2 index:e0: -> { indzero, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER0, INDEX1) = V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e0:), ]
ucubes2qv #2
	(log(SERVER0, INDEX1) = V:term:e0:) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { TERM0, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
	leader(SERVER0)
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | ~leader(SERVER0) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | ~leader(SERVER0) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  is global clause? Yes
@     5s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (termzero = log(S0, I0)))
	F[2]: #3
		(exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0))))
		(forall I0, T0 . ~committed(I0, T0))
	F[3]: #9
		(forall S0 . (termzero = log(S0, indzero)))
		(forall T0, S0, I1, S1 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall T0, S0 . (committed(loglen(S0), T0) -> (T0 = currentTerm(S0))))
		(forall I0, T0, I1 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #6 to F[4]
@     5s  Learning in F[4]: (forall S0 . (termzero = log(S0, indzero)))
@     5s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  Learning in F[4]: (forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     5s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  Learning in F[4]: (forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
@     5s  Learning in F[4]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  Learning in F[4]: (forall S0 . (termzero = log(S0, indzero)))
@     5s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  Learning in F[4]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  Learning in F[4]: (forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     5s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd -> i0
		V__fml -> s0
@     5s  F[3] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[4] unsat core #2 	(ucsz: 11 -> 10 -> 6 -> 5 -> 4 -> 3 -> 2 -> 2)
(minimal unsat core)
	(termzero = t1)
	committed(i0, t1)
(clause)
	(~(termzero = t1) | ~committed(i0, t1))
(relations)
	termzero
	committed
(cube: std)
	committed(INDEX0, TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
(antecedent eq)
(boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(original clause)
	(~(termzero = t1) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(clause-type: univ)	(forall I0 . ~committed(I0, termzero))
@     5s  is global clause? No
@     5s  Learning in F[4]: (forall I0 . ~committed(I0, termzero))
@     5s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (termzero = log(S0, I0)))
	F[2]: #3
		(exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0))))
		(forall I0, T0 . ~committed(I0, T0))
	F[3]: #3
		(forall T0, S0 . (committed(loglen(S0), T0) -> (T0 = currentTerm(S0))))
		(forall T0, S0, I1, S1 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall I0, T0, I1 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
	F[4]: #7
		(forall S0 . (termzero = log(S0, indzero)))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #7 to F[5]
@     5s  Learning in F[5]: (forall S0 . (termzero = log(S0, indzero)))
@     5s  Learning in F[5]: (forall I0 . ~committed(I0, termzero))
@     5s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  Learning in F[5]: (forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     5s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  Learning in F[5]: (forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
@     5s  Learning in F[5]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  Learning in F[5]: (forall S0 . (termzero = log(S0, indzero)))
@     5s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     5s  Learning in F[5]: (forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  Learning in F[5]: (forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
@     5s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (termzero = log(S0, I0)))
	F[2]: #3
		(exists S0 . (forall I0 . ((loglen(S0) = I0) -> (I0 = indzero))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0))))
		(forall I0, T0 . ~committed(I0, T0))
	F[3]: #3
		(forall T0, S0 . (committed(loglen(S0), T0) -> (T0 = currentTerm(S0))))
		(forall T0, S0, I1, S1 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall I0, T0, I1 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
	F[4]: #0
	F[5]: #7
		(forall S0 . (termzero = log(S0, indzero)))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
@     5s  
Adding frame 6...
@     5s  F[4] converged!
Explored 7 frames
@     5s  -------------------------------------------------
### Invariant: #8
invariant [global1]	(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
invariant [other2]	(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
invariant [global2]	(forall S0 . (termzero = log(S0, indzero)))
invariant [prop1]	(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0) & (lte(T0, currentTerm(S0)) & ~(T0 = currentTerm(S0)))) -> (log(S0, I0) = T0)))
invariant [global3]	(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global1 -> UNSAT
	#2 other2 -> UNSAT
	#3 global2 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 global3 -> UNSAT
	#6 global5_1 -> UNSAT
	#7 other1 -> UNSAT
	#8 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global1 -> UNSAT
	#2 other2 -> UNSAT
	#3 global2 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 global3 -> UNSAT
	#6 global5_1 -> UNSAT
	#7 other1 -> UNSAT
	#8 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e0: -> [`index:e0:0`, `index:e0:1`]
	term -> term:e0: -> [`term:e0:0`, `term:e0:1`]
	quorum -> quorum:e0: -> [`quorum:e0:0`, `quorum:e0:1`]
	server -> server:e0: -> [`server:e0:0`, `server:e0:1`]

Invariant is a proof certificate
@     5s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e0, T:e0, X:e0 . ((__committed:e0(I:e0, T:e0) & __leader:e0(X:e0) & (...(..., ...) & ~...)) -> (__log:e0(X:e0, I:e0) = T:e0)))
raw invariant [global1] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . (~...(..., ...) & ~(... = ...)))
raw invariant [other2] (cost: 2, 2F, 0E) 	~(exists Q:index:e0:0, Q:server:e0:0 . (~(... = ...) & ~(... = ...)))
raw invariant [global2] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . ~(termzero:e0 = ...(..., ...)))
raw invariant [global3] (cost: 2, 2F, 0E) 	~(exists Q:index:e0:0, Q:term:e0:0 . (__committed:e0(Q:index:e0:0, Q:term:e0:0) & ~...(..., ...)))
raw invariant [global5_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . (__leader:e0(Q:server:e0:0) & (...(...) = termzero:e0)))
raw invariant [other1] (cost: 1, 1F, 0E) 	~(exists Q:index:e0:0 . __committed:e0(Q:index:e0:0, termzero:e0))
raw invariant [global5] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . (~(... = ...) & __leader:e0(Q:server:e0:0) & ~(... = ...)))
@     5s  Minimizing certificate of size 8
@     5s  	prop1	(cost: 3) -> property
@     5s  	other2	(cost: 2) -> remove
@     6s  	global3	(cost: 2) -> remove
@     6s  	global1	(cost: 1) -> remove
@     6s  	global2	(cost: 1) -> remove
@     6s  	global5_1	(cost: 1) -> add
@     6s  	other1	(cost: 1) -> add
@     6s  	global5	(cost: 1) -> add
	Minimized certificate: 8 -> 4
@     6s  -------------------------------------------------
### Proof certificate (required): #4
invariant [prop1]	(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0) & (lte(T0, currentTerm(S0)) & ~(T0 = currentTerm(S0)))) -> (log(S0, I0) = T0)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###

### Optional invariants: #4
invariant [other2_optional]	(forall I0, S0 . ((I0 = loglen(S0)) | (termzero = log(S0, I0))))
invariant [global3_optional]	(forall I0, T0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [global1_optional]	(forall S0 . (succ(indzero, loglen(S0)) | (loglen(S0) = indzero)))
invariant [global2_optional]	(forall S0 . (termzero = log(S0, indzero)))
###

	random:	0
	scalls:	206
	scalls-finite:	206
	scalls-infinite:	0
	scalls-finite-full:	206
	cti:	17
	cubes:	18
	subsumed-calls:	137
	subsumed-subset:	0
	subsumed-varintersect-c:	135
	subsumed-varintersect-e:	0
	subsumed-query-sat:	2
	subsumed-query-unsat:	0
	subsumed-eq:	31
	unsat-core:	28
	sz-unsat-core-avg:	3.93
	sz-unsat-min-avg:	2.86
	sz-cube-avg:	36.00
	antecedent-reduction-sum:	2
	antecedent-total-sum:	34
	antecedent-reduction-avg:	0.06
	antecedent-calls:	11
	antecedent-calls-reduced:	1
	antecedent-scalls:	45
	time-q-max-finite-ms:	37
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	0
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	0
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	1
	time-forward:	1
	time-antecedent:	0
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	0
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	0
	time-qf:	0
	time-sum:	3
@     6s  -------------------------------------------------
@     6s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@     6s  (finite convergence checks)
@     6s  (performing finite convergence checks for index)
(enumsort) index <-> index:e1:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e1:
	[ TERM0, TERM1, ] <-> [ t0, t1, ]
(enumsort) quorum <-> quorum:e1:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e1:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[t0] = 0
	dep_height[t1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[i0] = 300
	dep_height[i1] = 301
	dep_height[i2] = 302
(use_wires: False)
@     6s  -------------------------------------------------
### Invariant: #4
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [prop1]	(forall I1, T1, S1 . ((committed(I1, T1) & leader(S1) & (lte(T1, currentTerm(S1)) & ~(T1 = currentTerm(S1)))) -> (log(S1, I1) = T1)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other1 -> UNSAT
	#2 prop1  (property) -> UNSAT
	#3 global5_1 -> UNSAT
	#4 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other1 -> UNSAT
	#2 prop1  (property) -> UNSAT
	#3 global5_1 -> UNSAT
	#4 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e1: -> [`index:e1:0`, `index:e1:1`, `index:e1:2`]
	term -> term:e1: -> [`term:e1:0`, `term:e1:1`]
	quorum -> quorum:e1: -> [`quorum:e1:0`, `quorum:e1:1`]
	server -> server:e1: -> [`server:e1:0`, `server:e1:1`]

Invariant is a proof certificate
@     6s  -------------------------------------------------
@     6s  (performing finite convergence checks for term)
(enumsort) index <-> index:e2:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e2:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e2:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e2:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@     6s  -------------------------------------------------
### Invariant: #4
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [prop1]	(forall I2, T2, S2 . ((committed(I2, T2) & leader(S2) & (lte(T2, currentTerm(S2)) & ~(T2 = currentTerm(S2)))) -> (log(S2, I2) = T2)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> SAT
Checking Init /\ !Inv:
	#1 global5_1 -> UNSAT
	#2 prop1  (property) -> UNSAT
	#3 other1 -> UNSAT
	#4 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global5_1 -> UNSAT
	#2 prop1  (property) -> SAT
	#3 other1 -> UNSAT
	#4 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: 1 failed

Finite sorts: #4
	index -> index:e2: -> [`index:e2:0`, `index:e2:1`, `index:e2:2`]
	term -> term:e2: -> [`term:e2:0`, `term:e2:1`, `term:e2:2`]
	quorum -> quorum:e2: -> [`quorum:e2:0`, `quorum:e2:1`]
	server -> server:e2: -> [`server:e2:0`, `server:e2:1`]

Invariant is not a proof certificate
@     6s  -------------------------------------------------
@     6s  (extended |term| to 3)
@     6s  (finite convergence checks failed for term)
(enumsort) index <-> index:e3:
	[ INDEX0, INDEX1, ] <-> [ i0, i1, ]
(enumsort) term <-> term:e3:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e3:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e3:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@     6s  -------------------------------------------------
### Checking reusability of clauses: #3
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###

Checking Init /\ !Inv:
	#1 other1 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 other1 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 global5 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 3 -> 3 (0 + 0 failed)
All clauses reusable
@     6s  -------------------------------------------------
	random:	0
	scalls:	232
	scalls-finite:	226
	scalls-infinite:	6
	scalls-finite-full:	226
	cti:	17
	cubes:	18
	subsumed-calls:	137
	subsumed-subset:	0
	subsumed-varintersect-c:	135
	subsumed-varintersect-e:	0
	subsumed-query-sat:	2
	subsumed-query-unsat:	0
	subsumed-eq:	31
	unsat-core:	28
	sz-unsat-core-avg:	3.93
	sz-unsat-min-avg:	2.86
	sz-cube-avg:	36.00
	antecedent-reduction-sum:	2
	antecedent-total-sum:	34
	antecedent-reduction-avg:	0.06
	antecedent-calls:	11
	antecedent-calls-reduced:	1
	antecedent-scalls:	45
	time-q-max-finite-ms:	37
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	4
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	0
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	1
	time-forward:	1
	time-antecedent:	0
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	0
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	0
	time-qf:	0
	time-sum:	3
@     6s  -------------------------------------------------
@     6s  -------------------------------------------------
@     6s  (incremental SymIC3)
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)

Checking property...

@     6s  Storing init values:
@     6s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlte(i0, i1)
	lte(t0, t0)
	lte(t0, t1)
	lte(t0, t2)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t2)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~lte(t1, t0)
	~lte(t2, t0)
	~lte(t2, t1)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i1, i0)
	~succ(i1, i1)

@     6s  F[0] /\ !P -> UNSAT
@     6s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
@     6s  
Adding frame 1...
@     6s  Is F[0] -> global5_1? -> UNSAT
@     6s  Is global5_1 inductive? -> UNSAT
@     6s  Is F[0] -> global5? -> UNSAT
@     6s  Is global5 inductive? -> UNSAT
@     6s  Is F[0] -> other1? -> UNSAT
@     6s  Is other1 inductive? -> SAT
@     6s  Is F[0] /\ T -> other1+? -> UNSAT
@     6s  Learning in F[1]: (forall I0 . ~committed(I0, termzero))
Seeded 3 (global: 2, init: 1) helpers out of 3
@     6s  Learning in F[1]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     6s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     6s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@     6s  F[0] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[1] unsat core #1 	(ucsz: 1 -> 1)
(minimal unsat core)
	committed(i1, t2)
(clause)
	~committed(i1, t2)
(relations)
	committed
(cube: std)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(original clause)
	~committed(i1, t2)
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(clause-type: univ)	(forall T0, I0 . ~committed(I0, T0))
@     6s  is global clause? No
@     6s  Learning in F[1]: (forall T0, I0 . ~committed(I0, T0))
@     6s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     6s  F[0] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(log(s0, i0) = t0)
	(termzero = t1)
(clause)
	(~(log(s0, i0) = t0) | ~(termzero = t1))
(relations)
	log
	termzero
(cube: std)
	(termzero = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     7s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM0
	SERVER0
	INDEX0
(antecedent eq)
	term:e3:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (log(SERVER0, INDEX0) = termzero))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (log(SERVER0, INDEX0) = termzero))
---------------------------
(clause-type: univ)	(forall S0, I0 . (log(S0, I0) = termzero))
@     7s  is global clause? No
@     7s  Learning in F[1]: (forall S0, I0 . (log(S0, I0) = termzero))
@     7s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
	F[1]: #4
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0, I0 . (log(S0, I0) = termzero))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     7s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #3 to F[2]
@     7s  Learning in F[2]: (forall T0, I0 . ~committed(I0, T0))
@     7s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     7s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     7s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     7s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     7s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     7s  F[1] /\ T /\ C+ ?
@     7s  	Ans. UNSAT
@     7s  F[2] unsat core #3 	(ucsz: 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	~succ(i1, i0)
	(termzero = t1)
	(log(s1, i0) = t0)
(clause)
	(~(log(s1, i0) = t0) | ~(termzero = t1) | succ(i1, i0))
(relations)
	succ
	log
	termzero
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
(cube: std)
	~succ(INDEX1, INDEX0)
	(termzero = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     7s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
(cube eq)
	~succ(INDEX1, INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM0
	SERVER0
	INDEX0
	INDEX1
(antecedent eq)
	index:e3:
	-> ~(INDEX0 = INDEX1)
	term:e3:
	-> ~(TERM0 = termzero)
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
qv2cubes #2
	INDEX0 -> [ ~succ(INDEX1, INDEX0), (log(SERVER0, INDEX0) = TERM0), ]
	INDEX1 -> [ ~succ(INDEX1, INDEX0), ]
qv2ucubes #2
	INDEX0 -> [ ~succ(INDEX1, V:index:e3:), (log(SERVER0, V:index:e3:) = TERM0), ]
	INDEX1 -> [ ~succ(V:index:e3:, INDEX0), ]
ucubes2qv #2
	((log(SERVER0, V:index:e3:) = TERM0) & ~succ(INDEX1, V:index:e3:)) -> [ INDEX0, ]
	~succ(V:index:e3:, INDEX0) -> [ INDEX1, ]
(partition) #2 index:e3: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	~succ(INDEX1, INDEX0)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | succ(INDEX1, INDEX0) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(termzero = t1) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | succ(INDEX1, INDEX0) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@     7s  is global clause? Yes
@     7s  Learning in F[2]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@     7s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     7s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@     7s  	Ans. SAT
@     7s  F[0] /\ T /\ C+ ?
@     7s  	Ans. UNSAT
@     7s  F[1] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(termzero = t0)
	~member(s1, q0)
	~member(s1, q1)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s1) = t2) | ~(termzero = t0) | member(s1, q0) | member(s1, q1))
(relations)
	currentTerm
	member
	termzero
(fullsorts)
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~member(SERVER0, QUORUM0)
	(termzero = TERM0)
	(currentTerm(SERVER0) = TERM1)
	~member(SERVER0, QUORUM1)
(antecedent reduction)
@     7s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	~member(SERVER0, QUORUM0)
	(currentTerm(SERVER0) = TERM1)
	~member(SERVER0, QUORUM1)
(qvars eq)
	QUORUM1
	SERVER0
	TERM1
	QUORUM0
(antecedent eq)
	quorum:e3:
	-> ~(QUORUM0 = QUORUM1)
	term:e3:
	-> ~(termzero = TERM1)
(fullsorts)
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
qv2cubes #2
	QUORUM1 -> [ ~member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ ~member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ ~member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ ~member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	~member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER0, TERM1 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
(non-epr version)
	(forall SERVER0, TERM1 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER0, TERM1 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(termzero = t0) | member(s1, q0) | member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER0, TERM1 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@     7s  is global clause? Yes
@     7s  Learning in F[2]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@     7s  F[1] /\ T /\ C+ ?
@     7s  	Ans. UNSAT
@     7s  F[2] unsat core #3 	(ucsz: 6 -> 4 -> 3 -> 3)
(minimal unsat core)
	~member(s1, q0)
	~member(s1, q1)
	leader(s1)
(clause)
	(~leader(s1) | member(s1, q0) | member(s1, q1))
(relations)
	leader
	member
(fullsorts)
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~member(SERVER0, QUORUM0)
	leader(SERVER0)
	~member(SERVER0, QUORUM1)
(antecedent reduction)
@     7s  antecedent: 2 -> 2

qv2cubes #2
	QUORUM1 -> [ ~member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ ~member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ ~member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ ~member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	~member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
(non-epr version)
	(forall SERVER0 . (exists QUORUM0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
---------------------------
(original clause)
	(~leader(s1) | member(s1, q0) | member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@     7s  is global clause? Yes
@     7s  Learning in F[2]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@     7s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     7s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@     7s  	Ans. SAT
@     7s  F[0] /\ T /\ C+ ?
@     7s  	Ans. UNSAT
@     8s  F[1] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(currentTerm(s1) = t2)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(termzero = t0))
(relations)
	currentTerm
	termzero
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	term:e3: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM0)
	(currentTerm(SERVER0) = TERM1)
	(currentTerm(SERVER1) = TERM2)
(antecedent reduction)
@     8s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	(currentTerm(SERVER1) = TERM2)
(qvars eq)
	TERM2
	SERVER0
	SERVER1
	TERM1
(antecedent eq)
	term:e3:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	term:e3: -> [ termzero, TERM1, TERM2, ]
qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), ]
	SERVER1 -> [ (currentTerm(SERVER1) = TERM2), ]
qv2ucubes #2
	SERVER0 -> [ (currentTerm(V:server:e3:) = TERM1), ]
	SERVER1 -> [ (currentTerm(V:server:e3:) = TERM2), ]
ucubes2qv #2
	(currentTerm(V:server:e3:) = TERM1) -> [ SERVER0, ]
	(currentTerm(V:server:e3:) = TERM2) -> [ SERVER1, ]
(partition) #2 server:e3: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #3
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
	termzero -> [ ]
qv2ucubes #3
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e3:), ]
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e3:), ]
	termzero -> [ ]
ucubes2qv #3
	(currentTerm(SERVER1) = V:term:e3:) -> [ TERM2, ]
	true -> [ termzero, ]
	(currentTerm(SERVER0) = V:term:e3:) -> [ TERM1, ]
(partition) #3 term:e3: -> { TERM2, | termzero, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER0)
	TERM2 -> currentTerm(SERVER1)
(cube eq: post)
	~(termzero = currentTerm(SERVER1))
	~(currentTerm(SERVER0) = currentTerm(SERVER1))
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((termzero = currentTerm(SERVER1)) | (currentTerm(SERVER0) = currentTerm(SERVER1)) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((termzero = currentTerm(SERVER1)) | (currentTerm(SERVER0) = currentTerm(SERVER1)) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
@     8s  is global clause? No
@     8s  Learning in F[1]: (forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
@     8s  F[1] /\ T /\ C+ ?
@     8s  	Ans. UNSAT
@     8s  F[2] unsat core #5 	(ucsz: 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	leader(s1)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t1)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t1) | ~leader(s0) | ~leader(s1))
(relations)
	log
	leader
	currentTerm
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	leader(SERVER1)
	(currentTerm(SERVER1) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	leader(SERVER0)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     8s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), leader(SERVER0), (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ leader(SERVER1), (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ leader(V:server:e3:), (currentTerm(V:server:e3:) = TERM0), (log(V:server:e3:, INDEX0) = TERM0), ]
	SERVER1 -> [ leader(V:server:e3:), (currentTerm(V:server:e3:) = TERM1), ]
ucubes2qv #2
	((currentTerm(V:server:e3:) = TERM1) & leader(V:server:e3:)) -> [ SERVER1, ]
	((currentTerm(V:server:e3:) = TERM0) & (log(V:server:e3:, INDEX0) = TERM0) & leader(V:server:e3:)) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
	TERM1 -> currentTerm(SERVER1)
(cube eq: post)
	leader(SERVER1)
	~(log(SERVER0, INDEX0) = currentTerm(SERVER1))
	(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	leader(SERVER0)
(qvars eq: post)
	INDEX0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER1) | (log(SERVER0, INDEX0) = currentTerm(SERVER1)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX0)) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t1) | ~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER1) | (log(SERVER0, INDEX0) = currentTerm(SERVER1)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX0)) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
@     8s  is global clause? No
@     8s  Learning in F[2]: (forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
@     8s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
	F[1]: #2
		(forall S0, I0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
	F[2]: #7
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
		(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     8s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #5 to F[3]
@     8s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     8s  Learning in F[3]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@     8s  Learning in F[3]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@     8s  Learning in F[3]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@     8s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     8s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@     8s  Learning in F[3]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@     8s  Learning in F[3]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@     8s  Learning in F[3]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@     8s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     8s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@     8s  F[2] /\ T /\ C+ ?
@     8s  	Ans. UNSAT
@     8s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	~indlte(i1, i1)
	committed(i1, t1)
(clause)
	(~committed(i1, t1) | indlte(i1, i1))
(relations)
	committed
	indlte
(cube: std)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM0)))
---------------------------
(original clause)
	(~committed(i1, t1) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM0)))
---------------------------
(clause-type: univ)	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@     8s  is global clause? Yes
@     8s  Learning in F[3]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@     8s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     8s  F[2] /\ T /\ C+ ?
@     8s  	Ans. UNSAT
@     8s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	committed(i0, t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~committed(i0, t1))
(relations)
	committed
	indzero
(cube: std)
	(indzero = INDEX0)
	committed(INDEX0, TERM0)

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(indzero, TERM0)
(qvars eq)
	TERM0
(antecedent eq)
(boosted clause)
	(forall TERM0 . ~committed(indzero, TERM0))
---------------------------
(original clause)
	(~(indzero = i0) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(forall TERM0 . ~committed(indzero, TERM0))
---------------------------
(clause-type: univ)	(forall T0 . ~committed(indzero, T0))
@     8s  is global clause? Yes
@     8s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@     8s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     8s  F[2] /\ T /\ C+ ?
@     8s  	Ans. UNSAT
@     8s  F[3] unsat core #2 	(ucsz: 3 -> 2 -> 2)
(minimal unsat core)
	~succ(i0, i1)
	committed(i1, t2)
(clause)
	(~committed(i1, t2) | succ(i0, i1))
(relations)
	succ
	committed
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
(cube: std)
	~succ(INDEX0, INDEX1)
	committed(INDEX1, TERM0)
(antecedent reduction)
@     8s  antecedent: 2 -> 2

qv2cubes #2
	INDEX0 -> [ ~succ(INDEX0, INDEX1), ]
	INDEX1 -> [ ~succ(INDEX0, INDEX1), committed(INDEX1, TERM0), ]
qv2ucubes #2
	INDEX0 -> [ ~succ(V:index:e3:, INDEX1), ]
	INDEX1 -> [ ~succ(INDEX0, V:index:e3:), committed(V:index:e3:, TERM0), ]
ucubes2qv #2
	~succ(V:index:e3:, INDEX1) -> [ INDEX0, ]
	(committed(V:index:e3:, TERM0) & ~succ(INDEX0, V:index:e3:)) -> [ INDEX1, ]
(partition) #2 index:e3: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall TERM0, INDEX0, INDEX1 . (~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX0, INDEX1)))
---------------------------
(original clause)
	(~committed(i1, t2) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall TERM0, INDEX0, INDEX1 . (~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX0, INDEX1)))
---------------------------
(clause-type: univ)	(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     8s  is global clause? No
@     8s  Learning in F[3]: (forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     8s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     8s  F[2] /\ T /\ C+ ?
@     8s  	Ans. UNSAT
@     8s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(termzero = t0)
	committed(i1, t0)
(clause)
	(~(termzero = t0) | ~committed(i1, t0))
(relations)
	committed
	termzero
(cube: std)
	(termzero = TERM0)
	committed(INDEX0, TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
(antecedent eq)
(boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(original clause)
	(~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(clause-type: univ)	(forall I0 . ~committed(I0, termzero))
@     8s  is global clause? No
@     8s  Learning in F[3]: (forall I0 . ~committed(I0, termzero))
@     8s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     9s  F[2] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[3] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s1) = i0)
	committed(i1, t1)
	(loglen(s0) = i0)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(relations)
	committed
	loglen
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@     9s  antecedent: 4 -> 4

qv2cubes #2
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
qv2ucubes #2
	INDEX0 -> [ (loglen(SERVER1) = V:index:e3:), (loglen(SERVER0) = V:index:e3:), ]
	INDEX1 -> [ committed(V:index:e3:, TERM0), ]
ucubes2qv #2
	committed(V:index:e3:, TERM0) -> [ INDEX1, ]
	((loglen(SERVER0) = V:index:e3:) & (loglen(SERVER1) = V:index:e3:)) -> [ INDEX0, ]
(partition) #2 index:e3: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e3:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e3:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e3:) = INDEX0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e3: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall TERM0, INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
(non-epr version)
	(forall TERM0, INDEX0, INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
---------------------------
(clause-type: epr)	(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@     9s  is global clause? No
@     9s  Learning in F[3]: (exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@     9s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     9s  F[2] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[3] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	~leader(s0)
	committed(i1, t2)
	~leader(s1)
(clause)
	(~committed(i1, t2) | leader(s0) | leader(s1))
(relations)
	committed
	leader
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	~leader(SERVER1)
	committed(INDEX0, TERM0)
	~leader(SERVER0)
(antecedent reduction)
@     9s  antecedent: 2 -> 2

qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e3:), ]
	SERVER1 -> [ ~leader(V:server:e3:), ]
ucubes2qv #1
	~leader(V:server:e3:) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e3: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
(non-epr version)
	(forall TERM0, INDEX0 . (exists SERVER0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
---------------------------
(original clause)
	(~committed(i1, t2) | leader(s0) | leader(s1))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
---------------------------
(clause-type: epr)	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@     9s  is global clause? Yes
@     9s  Learning in F[3]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@     9s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@     9s  F[2] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[3] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	leader(s0)
	(currentTerm(s0) = t1)
	committed(i1, t0)
(clause)
	(~(currentTerm(s0) = t1) | ~committed(i1, t0) | ~leader(s0))
(relations)
	committed
	leader
	currentTerm
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	committed(INDEX0, TERM0)
	leader(SERVER0)
(antecedent reduction)
@     9s  antecedent: 2 -> 2

(eq map: post)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~(TERM0 = currentTerm(SERVER0))
	committed(INDEX0, TERM0)
	leader(SERVER0)
(qvars eq: post)
	TERM0
	SERVER0
	INDEX0
(boosted clause)
	(forall TERM0, SERVER0, INDEX0 . ((TERM0 = currentTerm(SERVER0)) | ~committed(INDEX0, TERM0) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~committed(i1, t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, INDEX0 . ((TERM0 = currentTerm(SERVER0)) | ~committed(INDEX0, TERM0) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall T0, S0, I0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
@     9s  is global clause? No
@     9s  Learning in F[3]: (forall T0, S0, I0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
@     9s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     9s  F[2] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[3] unsat core #3 	(ucsz: 9 -> 8 -> 4 -> 3 -> 3)
(minimal unsat core)
	committed(i1, t2)
	~member(s1, q1)
	(log(s0, i1) = t0)
(clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | member(s1, q1))
(relations)
	log
	member
	committed
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@     9s  antecedent: 4 -> 4

qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e3:, INDEX0) = TERM0), ]
	SERVER1 -> [ ~member(V:server:e3:, QUORUM0), ]
ucubes2qv #2
	(log(V:server:e3:, INDEX0) = TERM0) -> [ SERVER0, ]
	~member(V:server:e3:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e3: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	INDEX0
	TERM1
	QUORUM0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, TERM1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | member(s1, q1))
(learnt sym-boosted clause)
	(forall INDEX0, TERM1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@     9s  is global clause? No
@     9s  Learning in F[3]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@     9s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@     9s  F[2] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@    10s  F[3] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	~leader(s0)
	(loglen(s1) = i0)
	committed(i1, t1)
(clause)
	(~(loglen(s1) = i0) | ~committed(i1, t1) | leader(s0))
(relations)
	committed
	leader
	loglen
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	~leader(SERVER0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@    10s  antecedent: 4 -> 4

qv2cubes #2
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
qv2ucubes #2
	INDEX0 -> [ (loglen(SERVER1) = V:index:e3:), ]
	INDEX1 -> [ committed(V:index:e3:, TERM0), ]
ucubes2qv #2
	committed(V:index:e3:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e3:) -> [ INDEX0, ]
(partition) #2 index:e3: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e3:), ]
	SERVER1 -> [ (loglen(V:server:e3:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e3:) = INDEX0) -> [ SERVER1, ]
	~leader(V:server:e3:) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(loglen(SERVER1) = INDEX1)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	~leader(SERVER0)
(qvars eq: post)
	TERM0
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall TERM0, SERVER0, SERVER1, INDEX1 . ((loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0)))
---------------------------
(original clause)
	(~(loglen(s1) = i0) | ~committed(i1, t1) | leader(s0))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, SERVER1, INDEX1 . ((loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    10s  is global clause? No
@    10s  Learning in F[3]: (forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    10s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    10s  F[2] /\ T /\ C+ ?
@    10s  	Ans. UNSAT
@    10s  F[3] unsat core #8 	(ucsz: 11 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	leader(s0)
	member(s0, q0)
	member(s0, q1)
	(loglen(s0) = i0)
	(log(s1, i0) = t1)
	(currentTerm(s1) = t1)
	leader(s1)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t1) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | ~leader(s1) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	log
	leader
	currentTerm
	member
	loglen
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	(loglen(SERVER0) = INDEX0)
	leader(SERVER1)
	(log(SERVER1, INDEX0) = TERM1)
	(currentTerm(SERVER1) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	leader(SERVER0)
(antecedent reduction)
@    10s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ leader(SERVER0), (currentTerm(SERVER0) = TERM0), (loglen(SERVER0) = INDEX0), member(SERVER0, QUORUM1), member(SERVER0, QUORUM0), ]
	SERVER1 -> [ leader(SERVER1), (currentTerm(SERVER1) = TERM1), (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ member(V:server:e3:, QUORUM1), leader(V:server:e3:), (currentTerm(V:server:e3:) = TERM0), member(V:server:e3:, QUORUM0), (loglen(V:server:e3:) = INDEX0), ]
	SERVER1 -> [ (log(V:server:e3:, INDEX0) = TERM1), leader(V:server:e3:), (currentTerm(V:server:e3:) = TERM1), ]
ucubes2qv #2
	((currentTerm(V:server:e3:) = TERM0) & (loglen(V:server:e3:) = INDEX0) & leader(V:server:e3:) & member(V:server:e3:, QUORUM0) & member(V:server:e3:, QUORUM1)) -> [ SERVER0, ]
	((currentTerm(V:server:e3:) = TERM1) & (log(V:server:e3:, INDEX0) = TERM1) & leader(V:server:e3:)) -> [ SERVER1, ]
(partition) #2 server:e3: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM0, SERVER1, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall TERM0, SERVER1, TERM1, INDEX0, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM0, SERVER1, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t1) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | ~leader(s1) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM0, SERVER1, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T0, S1, T1, I0, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (log(S1, I0) = T1) & (loglen(S0) = I0) & leader(S0) & leader(S1) & member(S0, Q0)) -> (T0 = T1))))
@    10s  is global clause? No
@    10s  Learning in F[3]: (exists Q0 . (forall T0, S1, T1, I0, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (log(S1, I0) = T1) & (loglen(S0) = I0) & leader(S0) & leader(S1) & member(S0, Q0)) -> (T0 = T1))))
@    10s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    10s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@    11s  	Ans. SAT
@    11s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    11s  	Ans. SAT
@    11s  F[0] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    11s  F[1] unsat core #5 	(ucsz: 5 -> 5)
(minimal unsat core)
	(termzero = t0)
	member(s0, q0)
	(currentTerm(s1) = t2)
	member(s0, q1)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(termzero = t0) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	currentTerm
	member
	termzero
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(termzero = TERM0)
	(currentTerm(SERVER1) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(antecedent reduction)
@    11s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = termzero)
	(currentTerm(SERVER1) = TERM1)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(qvars eq)
	TERM1
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(antecedent eq)
	quorum:e3:
	-> ~(QUORUM0 = QUORUM1)
	term:e3:
	-> ~(termzero = TERM1)
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = termzero), member(SERVER0, QUORUM1), member(SERVER0, QUORUM0), ]
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ member(V:server:e3:, QUORUM1), (currentTerm(V:server:e3:) = termzero), member(V:server:e3:, QUORUM0), ]
	SERVER1 -> [ (currentTerm(V:server:e3:) = TERM1), ]
ucubes2qv #2
	(currentTerm(V:server:e3:) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e3:) = termzero) & member(V:server:e3:, QUORUM0) & member(V:server:e3:, QUORUM1)) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
(non-epr version)
	(forall TERM1, SERVER1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(termzero = t0) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    11s  is global clause? Yes
@    11s  Learning in F[3]: (exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    11s  F[1] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    11s  F[2] unsat core #5 	(ucsz: 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	member(s0, q1)
	member(s0, q0)
	(currentTerm(s0) = t1)
	~lte(t2, t1)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t1))
(relations)
	currentTerm
	member
	lte
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER1) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(antecedent reduction)
@    11s  antecedent: 6 -> 2 (reduced)
	removed: SERVER0
	removed: TERM0
	removed: TERM1
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), member(SERVER0, QUORUM1), member(SERVER0, QUORUM0), ]
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ member(V:server:e3:, QUORUM1), (currentTerm(V:server:e3:) = TERM0), member(V:server:e3:, QUORUM0), ]
	SERVER1 -> [ (currentTerm(V:server:e3:) = TERM1), ]
ucubes2qv #2
	(currentTerm(V:server:e3:) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e3:) = TERM0) & member(V:server:e3:, QUORUM0) & member(V:server:e3:, QUORUM1)) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(non-epr version)
	(forall TERM0, TERM1, SERVER1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    11s  is global clause? Yes
@    11s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    11s  F[2] /\ T /\ C+ ?
@    12s  	Ans. UNSAT
@    12s  F[3] unsat core #5 	(ucsz: 8 -> 7 -> 5 -> 5)
(minimal unsat core)
	member(s0, q1)
	member(s0, q0)
	(currentTerm(s0) = t1)
	~lte(t2, t1)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t1))
(relations)
	currentTerm
	member
	lte
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER1) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(antecedent reduction)
@    12s  antecedent: 6 -> 2 (reduced)
	removed: SERVER0
	removed: TERM0
	removed: TERM1
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), member(SERVER0, QUORUM1), member(SERVER0, QUORUM0), ]
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ member(V:server:e3:, QUORUM1), (currentTerm(V:server:e3:) = TERM0), member(V:server:e3:, QUORUM0), ]
	SERVER1 -> [ (currentTerm(V:server:e3:) = TERM1), ]
ucubes2qv #2
	(currentTerm(V:server:e3:) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e3:) = TERM0) & member(V:server:e3:, QUORUM0) & member(V:server:e3:, QUORUM1)) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(non-epr version)
	(forall TERM0, TERM1, SERVER1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, SERVER1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    12s  is global clause? Yes
@    12s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    12s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
	F[1]: #2
		(forall S0, I0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
	F[2]: #2
		(forall T0, I0 . ~committed(I0, T0))
		(forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
	F[3]: #17
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I0 . ~committed(I0, termzero))
		(forall T0, S0, I0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall T0, S1, T1, I0, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (log(S1, I0) = T1) & (loglen(S0) = I0) & leader(S0) & leader(S1) & member(S0, Q0)) -> (T0 = T1))))
		(forall T0 . ~committed(indzero, T0))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    12s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #15 to F[4]
@    13s  Learning in F[4]: (exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    13s  Learning in F[4]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    13s  Learning in F[4]: (exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    13s  Learning in F[4]: (forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@    13s  Learning in F[4]: (forall I0 . ~committed(I0, termzero))
@    13s  Learning in F[4]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@    13s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    13s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    13s  Learning in F[4]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@    13s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    13s  Learning in F[4]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    13s  Learning in F[4]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    13s  Learning in F[4]: (forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    13s  Learning in F[4]: (exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    13s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    13s  Learning in F[4]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@    13s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    13s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    13s  Learning in F[4]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@    13s  Learning in F[4]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    13s  Learning in F[4]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    13s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@    13s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    13s  	Ans. SAT
@    13s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    13s  	Ans. SAT
@    13s  F[1] /\ T /\ C+ ?
@    13s  	Ans. UNSAT
@    13s  F[2] unsat core #3 	(ucsz: 8 -> 3 -> 3)
(minimal unsat core)
	(termzero = t2)
	(log(s0, i0) = t1)
	(log(s1, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(log(s1, i0) = t1) | ~(termzero = t2))
(relations)
	log
	termzero
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM0)
	(termzero = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@    13s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER1, INDEX0) = TERM0)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM0
	SERVER1
	SERVER0
	INDEX0
(antecedent eq)
	server:e3:
	-> ~(SERVER0 = SERVER1)
	term:e3:
	-> ~(TERM0 = termzero)
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e3:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e3:, INDEX0) = TERM0), ]
ucubes2qv #1
	(log(V:server:e3:, INDEX0) = TERM0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e3: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | (TERM0 = termzero))))
(non-epr version)
	(forall TERM0, INDEX0 . (exists SERVER0 . (~(log(SERVER0, INDEX0) = TERM0) | (TERM0 = termzero))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | (TERM0 = termzero))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(log(s1, i0) = t1) | ~(termzero = t2))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | (TERM0 = termzero))))
---------------------------
(clause-type: epr)	(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> (T0 = termzero))))
@    13s  is global clause? No
@    13s  Learning in F[2]: (exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> (T0 = termzero))))
@    13s  F[2] /\ T /\ C+ ?
@    14s  	Ans. UNSAT
@    14s  F[3] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	committed(i0, t1)
	(log(s1, i0) = t1)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(log(s1, i0) = t1) | ~committed(i0, t1))
(relations)
	log
	committed
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM0)
	committed(INDEX0, TERM0)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@    14s  antecedent: 2 -> 2

qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e3:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e3:, INDEX0) = TERM0), ]
ucubes2qv #1
	(log(V:server:e3:, INDEX0) = TERM0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e3: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM0))))
(non-epr version)
	(forall TERM0, INDEX0 . (exists SERVER0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM0))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(log(s1, i0) = t1) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM0))))
---------------------------
(clause-type: epr)	(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> ~committed(I0, T0))))
@    14s  is global clause? No
@    14s  Learning in F[3]: (exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> ~committed(I0, T0))))
@    14s  F[3] /\ T /\ C+ ?
@    14s  	Ans. UNSAT
@    15s  F[4] unsat core #4 	(ucsz: 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i0, t1)
	member(s0, q0)
	member(s0, q1)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~committed(i0, t1) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	committed
	currentTerm
	member
(fullsorts)
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	member(SERVER0, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM1)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    15s  antecedent: 4 -> 4

qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall TERM0, TERM1, INDEX0, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~committed(i0, t1) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@    16s  is global clause? No
@    16s  Learning in F[4]: (exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@    16s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
	F[1]: #2
		(forall S0, I0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
	F[2]: #3
		(forall T0, I0 . ~committed(I0, T0))
		(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> (T0 = termzero))))
		(forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
	F[3]: #3
		(forall T0, S0, I0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> ~committed(I0, T0))))
		(exists Q0 . (forall T0, S1, T1, I0, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (log(S1, I0) = T1) & (loglen(S0) = I0) & leader(S0) & leader(S1) & member(S0, Q0)) -> (T0 = T1))))
	F[4]: #16
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I0 . ~committed(I0, termzero))
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall T0 . ~committed(indzero, T0))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    17s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #15 to F[5]
@    18s  Learning in F[5]: (exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    18s  Learning in F[5]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    18s  Learning in F[5]: (exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    18s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    18s  Learning in F[5]: (forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@    18s  Learning in F[5]: (forall I0 . ~committed(I0, termzero))
@    18s  Learning in F[5]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@    18s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    18s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    18s  Learning in F[5]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@    18s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    18s  Learning in F[5]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    18s  Learning in F[5]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    18s  Learning in F[5]: (forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    18s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    18s  Learning in F[5]: (exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    18s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    18s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    18s  Learning in F[5]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@    18s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    18s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    18s  Learning in F[5]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@    18s  Learning in F[5]: (exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    18s  Learning in F[5]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    18s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    18s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@    18s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    18s  	Ans. SAT
@    18s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    18s  	Ans. SAT
@    18s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@    18s  	Ans. SAT
@    18s  F[1] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[2] unsat core #3 	(ucsz: 6 -> 3 -> 3 -> 3)
(minimal unsat core)
	~leader(s0)
	(termzero = t2)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(termzero = t2) | leader(s0))
(relations)
	log
	leader
	termzero
(cube: std)
	(termzero = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    18s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
(qvars eq)
	TERM0
	SERVER0
	INDEX0
(antecedent eq)
	term:e3:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = termzero)
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(termzero = t2) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
@    18s  is global clause? No
@    18s  Learning in F[2]: (forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
@    18s  F[2] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[3] unsat core #4 	(ucsz: 11 -> 9 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	~leader(s0)
	(termzero = t2)
	(loglen(s1) = i0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(loglen(s1) = i0) | ~(termzero = t2) | leader(s0))
(relations)
	log
	leader
	loglen
	termzero
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    18s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM1 -> termzero
(cube eq)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
(qvars eq)
	TERM0
	SERVER1
	SERVER0
	INDEX0
(antecedent eq)
	term:e3:
	-> ~(TERM0 = termzero)
(fullsorts)
	server:e3: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e3:, INDEX0) = TERM0), ~leader(V:server:e3:), ]
	SERVER1 -> [ (loglen(V:server:e3:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e3:) = INDEX0) -> [ SERVER1, ]
	((log(V:server:e3:, INDEX0) = TERM0) & ~leader(V:server:e3:)) -> [ SERVER0, ]
(partition) #2 server:e3: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~leader(SERVER0)
	~(log(SERVER0, loglen(SERVER1)) = termzero)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (leader(SERVER0) | (log(SERVER0, loglen(SERVER1)) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(loglen(s1) = i0) | ~(termzero = t2) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (leader(SERVER0) | (log(SERVER0, loglen(SERVER1)) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (leader(S0) | (log(S0, loglen(S1)) = termzero)))
@    18s  is global clause? No
@    18s  Learning in F[3]: (forall S0, S1 . (leader(S0) | (log(S0, loglen(S1)) = termzero)))
@    18s  F[3] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[4] unsat core #3 	(ucsz: 9 -> 8 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	committed(i0, t1)
	~leader(s0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~committed(i0, t1) | leader(s0))
(relations)
	log
	leader
	committed
(cube: std)
	committed(INDEX0, TERM0)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)

(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX0, log(SERVER0, INDEX0))
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (~committed(INDEX0, log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~committed(i0, t1) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (~committed(INDEX0, log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
@    19s  is global clause? No
@    19s  Learning in F[4]: (forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
@    19s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e4 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2 -> t0
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    19s  	Ans. SAT
@    19s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e4 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e2 -> q0
		V__fml:e1:e2 -> s0
@    19s  	Ans. SAT
@    19s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e4 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2 -> i0
		V__fml:e1:e2 -> s0
@    19s  	Ans. SAT
@    19s  F[1] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[2] unsat core #3 	(ucsz: 6 -> 3 -> 3)
(minimal unsat core)
	(termzero = t2)
	(loglen(s0) = i1)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~(termzero = t2))
(relations)
	log
	loglen
	termzero
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
(cube: std)
	(termzero = TERM1)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@    19s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM0
	SERVER0
	INDEX0
	INDEX1
(antecedent eq)
	index:e3:
	-> ~(INDEX0 = INDEX1)
	term:e3:
	-> ~(TERM0 = termzero)
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
qv2cubes #2
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	INDEX0 -> [ (log(SERVER0, V:index:e3:) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e3:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e3:) -> [ INDEX1, ]
	(log(SERVER0, V:index:e3:) = TERM0) -> [ INDEX0, ]
(partition) #2 index:e3: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = termzero)
	~(INDEX0 = loglen(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | (INDEX0 = loglen(SERVER0))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | (INDEX0 = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    19s  is global clause? No
@    19s  Learning in F[2]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    19s  F[2] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[3] unsat core #3 	(ucsz: 7 -> 6 -> 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t2)
	(loglen(s0) = i1)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~(termzero = t2))
(relations)
	log
	loglen
	termzero
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
(cube: std)
	(termzero = TERM1)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@    20s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM0
	SERVER0
	INDEX0
	INDEX1
(antecedent eq)
	index:e3:
	-> ~(INDEX0 = INDEX1)
	term:e3:
	-> ~(TERM0 = termzero)
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
qv2cubes #2
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	INDEX0 -> [ (log(SERVER0, V:index:e3:) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e3:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e3:) -> [ INDEX1, ]
	(log(SERVER0, V:index:e3:) = TERM0) -> [ INDEX0, ]
(partition) #2 index:e3: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = termzero)
	~(INDEX0 = loglen(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | (INDEX0 = loglen(SERVER0))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . ((log(SERVER0, INDEX0) = termzero) | (INDEX0 = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    20s  is global clause? No
@    20s  Learning in F[3]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    20s  F[3] /\ T /\ C+ ?
@    20s  	Ans. UNSAT
@    20s  F[4] unsat core #4 	(ucsz: 17 -> 12 -> 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	leader(s0)
	(loglen(s0) = i1)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~leader(s0))
(relations)
	log
	leader
	currentTerm
	loglen
(fullsorts)
	index:e3: -> [ INDEX0, INDEX1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
	leader(SERVER0)
(antecedent reduction)
@    20s  antecedent: 2 -> 2

qv2cubes #2
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	INDEX0 -> [ (log(SERVER0, V:index:e3:) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e3:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e3:) -> [ INDEX1, ]
	(log(SERVER0, V:index:e3:) = TERM0) -> [ INDEX0, ]
(partition) #2 index:e3: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, INDEX0) = currentTerm(SERVER0))
	leader(SERVER0)
	~(INDEX0 = loglen(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (~(log(SERVER0, INDEX0) = currentTerm(SERVER0)) | ~leader(SERVER0) | (INDEX0 = loglen(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (~(log(SERVER0, INDEX0) = currentTerm(SERVER0)) | ~leader(SERVER0) | (INDEX0 = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
@    20s  is global clause? No
@    20s  Learning in F[4]: (forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
@    20s  F[4] /\ T /\ C+ ?
@    20s  	Ans. UNSAT
@    20s  F[5] unsat core #4 	(ucsz: 13 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i0, t1)
	member(s0, q0)
	member(s0, q1)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~committed(i0, t1) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	committed
	currentTerm
	member
(fullsorts)
	quorum:e3: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	member(SERVER0, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM1)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    21s  antecedent: 4 -> 4

qv2cubes #2
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
qv2ucubes #2
	QUORUM1 -> [ member(SERVER0, V:quorum:e3:), ]
	QUORUM0 -> [ member(SERVER0, V:quorum:e3:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e3:) -> [ QUORUM1, QUORUM0, ]
(partition) #1 quorum:e3: -> { QUORUM1, QUORUM0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall TERM0, TERM1, INDEX0, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~committed(i0, t1) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM0, TERM1, INDEX0, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@    22s  is global clause? No
@    22s  Learning in F[5]: (exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@    22s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S4 . ~leader(S4)) & (forall S4 . (currentTerm(S4) = termzero)) & (forall S4 . (loglen(S4) = indzero)) & (forall S4, I4 . (log(S4, I4) = termzero)) & (forall I4_1, T4 . ~committed(I4_1, T4)))
	F[1]: #2
		(forall S0, I0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((termzero = currentTerm(S1)) | (currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S0))))
	F[2]: #4
		(forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
		(forall T0, I0 . ~committed(I0, T0))
		(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> (T0 = termzero))))
		(forall I0, S0, S1 . ((leader(S1) & (currentTerm(S0) = log(S0, I0)) & leader(S0)) -> (log(S0, I0) = currentTerm(S1))))
	F[3]: #5
		(forall T0, S0, I0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall S0, S1 . (leader(S0) | (log(S0, loglen(S1)) = termzero)))
		(exists Q0 . (forall T0, S1, T1, I0, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (log(S1, I0) = T1) & (loglen(S0) = I0) & leader(S0) & leader(S1) & member(S0, Q0)) -> (T0 = T1))))
		(exists S0 . (forall T0, I0 . ((log(S0, I0) = T0) -> ~committed(I0, T0))))
	F[4]: #2
		(forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
		(forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
	F[5]: #16
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I0 . ~committed(I0, termzero))
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall T0 . ~committed(indzero, T0))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    22s  
Adding frame 6...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #1 to F[3]
@    23s  Learning in F[3]: (forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
Trying forwarding F[3]
Forwarded #2 to F[4]
@    23s  Learning in F[4]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    23s  Learning in F[4]: (forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
Trying forwarding F[4]
Forwarded #4 to F[5]
@    23s  Learning in F[5]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    23s  Learning in F[5]: (forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
@    23s  Learning in F[5]: (forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
@    23s  Learning in F[5]: (forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
@    23s  F[4] converged!
Explored 7 frames
@    23s  -------------------------------------------------
### Invariant: #21
invariant [global8]	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
invariant [other8]	(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
invariant [global4]	(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
invariant [global3]	(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
invariant [global9]	(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
invariant [prop1]	(forall I4, T4, S4 . ((committed(I4, T4) & leader(S4) & (lte(T4, currentTerm(S4)) & ~(T4 = currentTerm(S4)))) -> (log(S4, I4) = T4)))
invariant [other9]	(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
invariant [other3]	(forall I0 . ~committed(I0, termzero))
invariant [other7]	(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
invariant [other1]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other2]	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
invariant [other10]	(forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
invariant [global6]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [other6]	(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
invariant [global5_1]	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
invariant [global11]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other5]	(forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
invariant [other4]	(forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global6 -> UNSAT
	#2 global8 -> UNSAT
	#3 global4 -> UNSAT
	#4 global3 -> UNSAT
	#5 global9 -> UNSAT
	#6 global5_1 -> UNSAT
	#7 other9 -> UNSAT
	#8 other3 -> UNSAT
	#9 other8 -> UNSAT
	#10 other1 -> UNSAT
	#11 global5 -> UNSAT
	#12 other2 -> UNSAT
	#13 prop1  (property) -> UNSAT
	#14 other7 -> UNSAT
	#15 global7 -> UNSAT
	#16 other10 -> UNSAT
	#17 global5_1 -> UNSAT
	#18 global11 -> UNSAT
	#19 other5 -> UNSAT
	#20 other4 -> UNSAT
	#21 other6 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global6 -> UNSAT
	#2 global8 -> UNSAT
	#3 global4 -> UNSAT
	#4 global3 -> UNSAT
	#5 global9 -> UNSAT
	#6 global5_1 -> UNSAT
	#7 other9 -> UNSAT
	#8 other3 -> UNSAT
	#9 other8 -> UNSAT
	#10 other1 -> UNSAT
	#11 global5 -> UNSAT
	#12 other2 -> UNSAT
	#13 prop1  (property) -> UNSAT
	#14 other7 -> UNSAT
	#15 global7 -> UNSAT
	#16 other10 -> UNSAT
	#17 global5_1 -> UNSAT
	#18 global11 -> UNSAT
	#19 other5 -> UNSAT
	#20 other4 -> UNSAT
	#21 other6 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e3: -> [`index:e3:0`, `index:e3:1`]
	term -> term:e3: -> [`term:e3:0`, `term:e3:1`, `term:e3:2`]
	quorum -> quorum:e3: -> [`quorum:e3:0`, `quorum:e3:1`]
	server -> server:e3: -> [`server:e3:0`, `server:e3:1`]

Invariant is a proof certificate
@    25s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e4, T:e4, X:e4 . ((__committed:e4(I:e4, T:e4) & __leader:e4(X:e4) & (...(..., ...) & ~...)) -> (__log:e4(X:e4, I:e4) = T:e4)))
raw invariant [global8] (cost: 3, 2F, 1E) 	~(forall Q:server:e3:0 . (exists Q:term:e3:0, Q:index:e3:0 . (...(..., ...) & ~...)))
raw invariant [other8] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e3:0 . (exists Q:term:e3:0, Q:term:e3:1, Q:index:e3:0, Q:server:e3:0 . ((... = ...) & ...(..., ...) & ...(..., ...) & ~...)))
raw invariant [global4] (cost: 3, 2F, 1E) 	~(forall Q:quorum:e3:0 . (exists Q:server:e3:0, Q:term:e3:1 . ((... = ...) & ~... & ~...)))
raw invariant [global3] (cost: 3, 3F, 0E) 	~(exists Q:server:e3:0, Q:index:e3:0, Q:index:e3:1 . (~(... = ...) & ~...(..., ...) & ~(... = ...)))
raw invariant [global9] (cost: 4, 3F, 1E) 	~(forall Q:quorum:e3:0 . (exists Q:term:e3:1, Q:server:e3:1, Q:server:e3:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [other9] (cost: 4, 4F, 0E) 	~(exists Q:term:e3:0, Q:server:e3:0, Q:server:e3:1, Q:index:e3:1 . (~(... = ...) & __committed:e4(Q:index:e3:1, Q:term:e3:0) & ~(... = ...) & ~...(...)))
raw invariant [other3] (cost: 1, 1F, 0E) 	~(exists Q:index:e3:0 . __committed:e4(Q:index:e3:0, termzero:e4))
raw invariant [other7] (cost: 4, 3F, 1E) 	~(forall Q:server:e3:0 . (exists Q:term:e3:0, Q:index:e3:0, Q:index:e3:1 . ((... = ...) & ...(..., ...) & ~...)))
raw invariant [other1] (cost: 5, 5F, 0E) 	~(exists Q:index:e3:0, Q:term:e3:1, Q:quorum:e3:0, Q:server:e3:0, Q:server:e3:1 . (~(... = ...) & ~(... = ...) & ~...(..., ...) & __committed:e4(Q:index:e3:0, Q:term:e3:1)))
raw invariant [global5] (cost: 1, 1F, 0E) 	~(exists Q:server:e4:0 . (~(... = ...) & __leader:e4(Q:server:e4:0) & ~(... = ...)))
raw invariant [global5_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e4:0 . (__leader:e4(Q:server:e4:0) & (...(...) = termzero:e4)))
raw invariant [other2] (cost: 2, 2F, 0E) 	~(exists Q:server:e3:0, Q:index:e3:0 . (~(... = ...) & ~(... = ...)))
raw invariant [other10] (cost: 2, 2F, 0E) 	~(exists Q:server:e3:0, Q:index:e3:0 . ((...(..., ...) = ...(...)) & __leader:e4(Q:server:e3:0) & ~(... = ...)))
raw invariant [global6] (cost: 2, 2F, 0E) 	~(exists Q:term:e3:0, Q:index:e3:0 . (~...(..., ...) & __committed:e4(Q:index:e3:0, Q:term:e3:0)))
raw invariant [other6] (cost: 3, 3F, 0E) 	~(exists Q:term:e3:0, Q:index:e3:0, Q:index:e3:1 . (__committed:e4(Q:index:e3:1, Q:term:e3:0) & ~(... = ...) & ~...(..., ...)))
raw invariant [global5_1] (cost: 2, 1F, 1E) 	~(forall Q:quorum:e3:0 . (exists Q:server:e3:0 . (...(...) & ~...)))
raw invariant [global11] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e3:0 . (exists Q:term:e3:0, Q:term:e3:1, Q:server:e3:1, Q:server:e3:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [other5] (cost: 2, 2F, 0E) 	~(exists Q:server:e3:0, Q:index:e3:0 . (__committed:e4(Q:index:e3:0, ...(..., ...)) & ~...(...)))
raw invariant [other4] (cost: 2, 2F, 0E) 	~(exists Q:server:e3:0, Q:index:e3:0 . (~(... = ...) & ~...(...)))
raw invariant [global7] (cost: 1, 1F, 0E) 	~(exists Q:term:e3:0 . __committed:e4(indzero:e4, Q:term:e3:0))
@    25s  Minimizing certificate of size 21
@    25s  	other8	(cost: 5) -> remove
@    26s  	other1	(cost: 5) -> add
@    26s  	global11	(cost: 5) -> add
@    27s  	global9	(cost: 4) -> remove
@    27s  	other9	(cost: 4) -> add
@    28s  	other7	(cost: 4) -> add
@    28s  	prop1	(cost: 3) -> property
@    28s  	global8	(cost: 3) -> remove
@    29s  	global4	(cost: 3) -> remove
@    29s  	global3	(cost: 3) -> add
@    30s  	other6	(cost: 3) -> remove
@    30s  	other2	(cost: 2) -> add
@    31s  	other10	(cost: 2) -> remove
@    31s  	global6	(cost: 2) -> remove
@    32s  	global5_1	(cost: 2) -> remove
@    32s  	other5	(cost: 2) -> remove
@    32s  	other4	(cost: 2) -> remove
@    33s  	other3	(cost: 1) -> remove
@    33s  	global5	(cost: 1) -> add
@    34s  	global5_1	(cost: 1) -> add
@    34s  	global7	(cost: 1) -> add
	Minimized certificate: 21 -> 10
@    34s  -------------------------------------------------
### Proof certificate (required): #10
invariant [other1]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global11]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other9]	(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
invariant [other7]	(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
invariant [prop1]	(forall I4, T4, S4 . ((committed(I4, T4) & leader(S4) & (lte(T4, currentTerm(S4)) & ~(T4 = currentTerm(S4)))) -> (log(S4, I4) = T4)))
invariant [global3]	(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
invariant [other2]	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
###

### Optional invariants: #11
invariant [other8_optional]	(exists Q0 . (forall T0, T1, I0, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
invariant [global9_optional]	(exists Q0 . (forall T1, S1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
invariant [global8_optional]	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
invariant [global4_optional]	(exists Q0 . (forall S0, T1 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
invariant [other6_optional]	(forall T0, I0, I1 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
invariant [other10_optional]	(forall S0, I0 . (((log(S0, I0) = currentTerm(S0)) & leader(S0)) -> (I0 = loglen(S0))))
invariant [global6_optional]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [global5_1_optional]	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
invariant [other5_optional]	(forall S0, I0 . (committed(I0, log(S0, I0)) -> leader(S0)))
invariant [other4_optional]	(forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)))
invariant [other3_optional]	(forall I0 . ~committed(I0, termzero))
###

	random:	0
	scalls:	1138
	scalls-finite:	1132
	scalls-infinite:	6
	scalls-finite-full:	1132
	cti:	47
	cubes:	49
	subsumed-calls:	693
	subsumed-subset:	0
	subsumed-varintersect-c:	678
	subsumed-varintersect-e:	0
	subsumed-query-sat:	13
	subsumed-query-unsat:	2
	subsumed-eq:	106
	unsat-core:	83
	sz-unsat-core-avg:	4.64
	sz-unsat-min-avg:	3.08
	sz-cube-avg:	40.43
	antecedent-reduction-sum:	20
	antecedent-total-sum:	127
	antecedent-reduction-avg:	0.16
	antecedent-calls:	36
	antecedent-calls-reduced:	8
	antecedent-scalls:	163
	time-q-max-finite-ms:	1281
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	4
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	1
	time-cti-bad-unsat:	1
	time-cti-sat:	1
	time-cti-unsat:	6
	time-forward:	3
	time-antecedent:	4
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	2
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	10
	time-qf:	0
	time-sum:	26
@    34s  -------------------------------------------------
@    34s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@    34s  (finite convergence checks)
@    34s  (performing finite convergence checks for index)
(enumsort) index <-> index:e5:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e5:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e5:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e5:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@    34s  -------------------------------------------------
### Invariant: #10
invariant [other9]	(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
invariant [other1]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global3]	(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
invariant [prop1]	(forall I5, T5, S5 . ((committed(I5, T5) & leader(S5) & (lte(T5, currentTerm(S5)) & ~(T5 = currentTerm(S5)))) -> (log(S5, I5) = T5)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [other7]	(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
invariant [other2]	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
invariant [global11]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other9 -> UNSAT
	#2 other1 -> UNSAT
	#3 global3 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 global5_1 -> UNSAT
	#6 global7 -> UNSAT
	#7 other7 -> UNSAT
	#8 other2 -> UNSAT
	#9 global11 -> UNSAT
	#10 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other9 -> UNSAT
	#2 other1 -> UNSAT
	#3 global3 -> SAT
	#4 prop1  (property) -> UNSAT
	#5 global5_1 -> UNSAT
	#6 global7 -> UNSAT
	#7 other7 -> UNSAT
	#8 other2 -> UNSAT
	#9 global11 -> UNSAT
	#10 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: 1 failed

Finite sorts: #4
	index -> index:e5: -> [`index:e5:0`, `index:e5:1`, `index:e5:2`]
	term -> term:e5: -> [`term:e5:0`, `term:e5:1`, `term:e5:2`]
	quorum -> quorum:e5: -> [`quorum:e5:0`, `quorum:e5:1`]
	server -> server:e5: -> [`server:e5:0`, `server:e5:1`]

Invariant is not a proof certificate
@    35s  -------------------------------------------------
@    35s  (extended |index| to 3)
@    35s  (finite convergence checks failed for index)
(enumsort) index <-> index:e6:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e6:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e6:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e6:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[t0] = 0
	dep_height[t1] = 1
	dep_height[t2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@    35s  -------------------------------------------------
### Checking reusability of clauses: #9
invariant [other1]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [other7]	(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global3]	(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other2]	(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [other9]	(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
invariant [global11]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
###

Checking Init /\ !Inv:
	#1 other1 -> UNSAT
	#2 other7 -> UNSAT
	#3 global5_1 -> UNSAT
	#4 global3 -> UNSAT
	#5 global5 -> UNSAT
	#6 other2 -> UNSAT
	#7 global7 -> UNSAT
	#8 other9 -> UNSAT
	#9 global11 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 other1 -> UNSAT
	#2 other7 -> UNSAT
	#3 global5_1 -> UNSAT
	#4 global3 -> UNSAT
	#5 global5 -> UNSAT
	#6 other2 -> UNSAT
	#7 global7 -> UNSAT
	#8 other9 -> UNSAT
	#9 global11 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 9 -> 9 (0 + 0 failed)
All clauses reusable
@    35s  -------------------------------------------------
	random:	0
	scalls:	1178
	scalls-finite:	1154
	scalls-infinite:	24
	scalls-finite-full:	1154
	cti:	47
	cubes:	49
	subsumed-calls:	693
	subsumed-subset:	0
	subsumed-varintersect-c:	678
	subsumed-varintersect-e:	0
	subsumed-query-sat:	13
	subsumed-query-unsat:	2
	subsumed-eq:	106
	unsat-core:	83
	sz-unsat-core-avg:	4.64
	sz-unsat-min-avg:	3.08
	sz-cube-avg:	40.43
	antecedent-reduction-sum:	20
	antecedent-total-sum:	127
	antecedent-reduction-avg:	0.16
	antecedent-calls:	36
	antecedent-calls-reduced:	8
	antecedent-scalls:	163
	time-q-max-finite-ms:	1281
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	11
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	1
	time-cti-bad-unsat:	1
	time-cti-sat:	1
	time-cti-unsat:	6
	time-forward:	3
	time-antecedent:	4
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	3
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	10
	time-qf:	0
	time-sum:	27
@    35s  -------------------------------------------------
@    35s  -------------------------------------------------
@    35s  (incremental SymIC3)
	dep_height[t0] = 0
	dep_height[t1] = 1
	dep_height[t2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
(use_wires: False)

Checking property...

@    35s  Storing init values:
@    35s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s0, i2) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(log(s1, i2) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i2, i1)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i2, i1)
	lte(t0, t0)
	lte(t0, t1)
	lte(t0, t2)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t2)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~committed(i2, t0)
	~committed(i2, t1)
	~committed(i2, t2)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i1, i2)
	~indlt(i2, i0)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i1, i2)
	~indlte(i2, i0)
	~indlte(i2, i2)
	~lte(t1, t0)
	~lte(t2, t0)
	~lte(t2, t1)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@    35s  F[0] /\ !P -> UNSAT
@    35s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
@    35s  
Adding frame 1...
@    35s  Is F[0] -> global5_1? -> UNSAT
@    35s  Is global5_1 inductive? -> UNSAT
@    35s  Is F[0] -> global3? -> UNSAT
@    35s  Is global3 inductive? -> SAT
@    35s  Is F[0] /\ T -> global3+? -> UNSAT
@    35s  Learning in F[1]: (forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
@    35s  Is F[0] -> other7? -> UNSAT
@    35s  Is other7 inductive? -> SAT
@    36s  Is F[0] /\ T -> other7+? -> UNSAT
@    36s  Learning in F[1]: (exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    36s  Is F[0] -> global5? -> UNSAT
@    36s  Is global5 inductive? -> UNSAT
@    36s  Is F[0] -> other2? -> UNSAT
@    36s  Is other2 inductive? -> SAT
@    36s  Is F[0] /\ T -> other2+? -> UNSAT
@    36s  Learning in F[1]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    36s  Is F[0] -> global11? -> UNSAT
@    36s  Is global11 inductive? -> UNSAT
@    36s  Is F[0] -> other9? -> UNSAT
@    36s  Is other9 inductive? -> SAT
@    36s  Is F[0] /\ T -> other9+? -> UNSAT
@    36s  Learning in F[1]: (forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    36s  Is F[0] -> global7? -> UNSAT
@    36s  Is global7 inductive? -> UNSAT
@    36s  Is F[0] -> other1? -> UNSAT
@    36s  Is other1 inductive? -> SAT
@    36s  Is F[0] /\ T -> other1+? -> UNSAT
@    36s  Learning in F[1]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
Seeded 9 (global: 4, init: 5) helpers out of 9
@    36s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    36s  Learning in F[1]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  Learning in F[1]: (forall T0 . ~committed(indzero, T0))
@    36s  Learning in F[1]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    36s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #9
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall T0 . ~committed(indzero, T0))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #8 to F[2]
@    36s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    36s  Learning in F[2]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    36s  Learning in F[2]: (forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
@    36s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@    36s  Learning in F[2]: (exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    36s  Learning in F[2]: (forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
@    36s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    36s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    36s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@    36s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    36s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    36s  F[1] /\ T /\ C+ ?
@    36s  	Ans. UNSAT
@    37s  F[2] unsat core #3 	(ucsz: 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i1) = t2)
	(log(s0, i0) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(log(s1, i1) = t2))
(relations)
	log
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER1, INDEX1) = TERM2)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@    37s  antecedent: 7 -> 3 (reduced)
	removed: INDEX1
	removed: SERVER0
	removed: INDEX0
	removed: SERVER1

(eq map: post)
	TERM1 -> log(SERVER1, INDEX0)
	TERM2 -> log(SERVER1, INDEX1)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = log(SERVER1, INDEX0))
	~(log(SERVER0, INDEX0) = log(SERVER1, INDEX1))
	~(log(SERVER1, INDEX0) = log(SERVER1, INDEX1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER1, INDEX0)) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX1)) | (log(SERVER1, INDEX0) = log(SERVER1, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(log(s1, i1) = t2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER1, INDEX0)) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX1)) | (log(SERVER1, INDEX0) = log(SERVER1, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
@    37s  is global clause? No
@    37s  Learning in F[2]: (forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
@    37s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    37s  F[1] /\ T /\ C+ ?
@    37s  	Ans. UNSAT
@    37s  F[2] unsat core #3 	(ucsz: 6 -> 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	~leader(s0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(termzero = t0) | leader(s0))
(relations)
	termzero
	log
	leader
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
(antecedent reduction)
@    37s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
(qvars eq)
	TERM1
	INDEX0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER0, INDEX0))
	~leader(SERVER0)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . ((termzero = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(termzero = t0) | leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . ((termzero = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@    37s  is global clause? No
@    37s  Learning in F[2]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@    37s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    38s  F[1] /\ T /\ C+ ?
@    38s  	Ans. UNSAT
@    38s  F[2] unsat core #3 	(ucsz: 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i2) = t0)
	(termzero = t1)
	committed(i2, t0)
(clause)
	(~(log(s1, i2) = t0) | ~(termzero = t1) | ~committed(i2, t0))
(relations)
	log
	termzero
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM0)
	(termzero = TERM1)
(antecedent reduction)
@    38s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM0)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX0, log(SERVER0, INDEX0))
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~committed(INDEX0, log(SERVER0, INDEX0)) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s1, i2) = t0) | ~(termzero = t1) | ~committed(i2, t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~committed(INDEX0, log(SERVER0, INDEX0)) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
@    38s  is global clause? No
@    38s  Learning in F[2]: (forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
@    38s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #1
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
	F[2]: #11
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
		(forall T0 . ~committed(indzero, T0))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    38s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #5 to F[3]
@    39s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    39s  Learning in F[3]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    39s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@    39s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    39s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    39s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    39s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    39s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@    39s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    39s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    39s  F[2] /\ T /\ C+ ?
@    39s  	Ans. UNSAT
@    39s  F[3] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i0) = t0)
	(indzero = i2)
	(termzero = t1)
	~leader(s1)
	(currentTerm(s1) = t0)
(clause)
	(~(currentTerm(s1) = t0) | ~(indzero = i2) | ~(log(s1, i0) = t0) | ~(termzero = t1) | leader(s1))
(relations)
	indzero
	termzero
	log
	leader
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(indzero = INDEX1)
	(currentTerm(SERVER0) = TERM0)
	~leader(SERVER0)
	(termzero = TERM1)
(antecedent reduction)
@    39s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
	INDEX1 -> indzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	~leader(SERVER0)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
	index:e6:
	-> ~(INDEX0 = indzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~leader(SERVER0)
	~(INDEX0 = indzero)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~(currentTerm(SERVER0) = log(SERVER0, INDEX0)) | leader(SERVER0) | (INDEX0 = indzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t0) | ~(indzero = i2) | ~(log(s1, i0) = t0) | ~(termzero = t1) | leader(s1))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~(currentTerm(SERVER0) = log(SERVER0, INDEX0)) | leader(SERVER0) | (INDEX0 = indzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((currentTerm(S0) = log(S0, I0)) -> (leader(S0) | (I0 = indzero) | (log(S0, I0) = termzero))))
@    39s  is global clause? No
@    39s  Learning in F[3]: (forall I0, S0 . ((currentTerm(S0) = log(S0, I0)) -> (leader(S0) | (I0 = indzero) | (log(S0, I0) = termzero))))
@    39s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    39s  F[2] /\ T /\ C+ ?
@    39s  	Ans. UNSAT
@    39s  F[3] unsat core #3 	(ucsz: 11 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i0) = t0)
	(currentTerm(s1) = t2)
	(termzero = t2)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i0) = t0) | ~(termzero = t2))
(relations)
	termzero
	log
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
	(termzero = TERM1)
(antecedent reduction)
@    39s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	(currentTerm(SERVER0) = termzero)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~(currentTerm(SERVER0) = termzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i0) = t0) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~(currentTerm(SERVER0) = termzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    39s  is global clause? Yes
@    39s  Learning in F[3]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    39s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    39s  F[2] /\ T /\ C+ ?
@    39s  	Ans. UNSAT
@    39s  F[3] unsat core #4 	(ucsz: 11 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i0) = t0)
	(currentTerm(s1) = t2)
	(loglen(s1) = i0)
	(log(s1, i1) = t2)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i0) = t0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0))
(relations)
	loglen
	log
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX1) = TERM1)
	(loglen(SERVER0) = INDEX0)
(antecedent reduction)
@    40s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map: post)
	TERM1 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, loglen(SERVER0))
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
	(log(SERVER0, INDEX1) = currentTerm(SERVER0))
(qvars eq: post)
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i0) = t0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@    40s  is global clause? No
@    40s  Learning in F[3]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@    40s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    40s  F[2] /\ T /\ C+ ?
@    40s  	Ans. UNSAT
@    40s  F[3] unsat core #4 	(ucsz: 10 -> 6 -> 4 -> 4)
(minimal unsat core)
	(termzero = t2)
	~member(s0, q0)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(termzero = t2) | ~committed(i1, t1) | leader(s1) | member(s0, q0))
(relations)
	termzero
	committed
	leader
	member
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	~leader(SERVER1)
	~member(SERVER0, QUORUM0)
	committed(INDEX0, TERM0)
	(termzero = TERM1)
(antecedent reduction)
@    40s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
(cube eq)
	~leader(SERVER1)
	~member(SERVER0, QUORUM0)
	committed(INDEX0, TERM0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	TERM0
	QUORUM0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ ~member(SERVER0, QUORUM0), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ ~member(V:server:e6:, QUORUM0), ]
	SERVER1 -> [ ~leader(V:server:e6:), ]
ucubes2qv #2
	~member(V:server:e6:, QUORUM0) -> [ SERVER0, ]
	~leader(V:server:e6:) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM0, QUORUM0 . (~committed(INDEX0, TERM0) | (SERVER0 = SERVER1) | (TERM0 = termzero) | leader(SERVER1) | member(SERVER0, QUORUM0)))
---------------------------
(original clause)
	(~(termzero = t2) | ~committed(i1, t1) | leader(s1) | member(s0, q0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM0, QUORUM0 . (~committed(INDEX0, TERM0) | (SERVER0 = SERVER1) | (TERM0 = termzero) | leader(SERVER1) | member(SERVER0, QUORUM0)))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
@    40s  is global clause? No
@    40s  Learning in F[3]: (forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
@    40s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    40s  F[2] /\ T /\ C+ ?
@    40s  	Ans. UNSAT
@    40s  F[3] unsat core #5 	(ucsz: 11 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s0, i0) = t0)
	~succ(i1, i0)
	(indzero = i1)
	(termzero = t1)
	(log(s0, i1) = t0)
(clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(termzero = t1) | succ(i1, i0))
(relations)
	indzero
	termzero
	succ
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(indzero = INDEX1)
	~succ(INDEX1, INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	(termzero = TERM1)
(antecedent reduction)
@    40s  antecedent: 4 -> 4

(eq map)
	TERM1 -> termzero
	INDEX1 -> indzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	~succ(indzero, INDEX0)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
	index:e6:
	-> ~(INDEX0 = indzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	(log(SERVER0, indzero) = log(SERVER0, INDEX0))
	~succ(indzero, INDEX0)
	~(INDEX0 = indzero)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~(log(SERVER0, indzero) = log(SERVER0, INDEX0)) | succ(indzero, INDEX0) | (INDEX0 = indzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(termzero = t1) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~(log(SERVER0, indzero) = log(SERVER0, INDEX0)) | succ(indzero, INDEX0) | (INDEX0 = indzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((log(S0, indzero) = log(S0, I0)) -> (succ(indzero, I0) | (I0 = indzero) | (log(S0, I0) = termzero))))
@    40s  is global clause? No
@    40s  Learning in F[3]: (forall I0, S0 . ((log(S0, indzero) = log(S0, I0)) -> (succ(indzero, I0) | (I0 = indzero) | (log(S0, I0) = termzero))))
@    40s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    40s  F[2] /\ T /\ C+ ?
@    40s  	Ans. UNSAT
@    41s  F[3] unsat core #4 	(ucsz: 6 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	~leader(s0)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(loglen(s0) = i0) | ~committed(i1, t1) | leader(s0) | leader(s1))
(relations)
	loglen
	committed
	leader
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	~leader(SERVER1)
	~leader(SERVER0)
(antecedent reduction)
@    41s  antecedent: 4 -> 4

qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ~leader(SERVER0), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e6:) = INDEX0), ~leader(V:server:e6:), ]
	SERVER1 -> [ ~leader(V:server:e6:), ]
ucubes2qv #2
	((loglen(V:server:e6:) = INDEX0) & ~leader(V:server:e6:)) -> [ SERVER0, ]
	~leader(V:server:e6:) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = INDEX1)
	~(SERVER0 = SERVER1)
	~leader(SERVER1)
	committed(INDEX1, TERM0)
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX1
	SERVER1
	TERM0
(boosted clause)
	(forall SERVER0, INDEX1, SERVER1, TERM0 . ((loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, TERM0) | leader(SERVER0)))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~committed(i1, t1) | leader(s0) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1, SERVER1, TERM0 . ((loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, TERM0) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    41s  is global clause? Yes
@    41s  Learning in F[3]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    41s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    41s  F[2] /\ T /\ C+ ?
@    41s  	Ans. UNSAT
@    41s  F[3] unsat core #4 	(ucsz: 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i0) = t0)
	(log(s1, i0) = t2)
	committed(i2, t1)
	(log(s0, i2) = t1)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i2) = t1) | ~(log(s1, i0) = t2) | ~committed(i2, t1))
(relations)
	log
	committed
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER1, INDEX0) = TERM2)
	(log(SERVER0, INDEX1) = TERM1)
	committed(INDEX1, TERM1)
(antecedent reduction)
@    41s  antecedent: 7 -> 3 (reduced)
	removed: INDEX1
	removed: SERVER0
	removed: INDEX0
	removed: SERVER1

qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX1) = TERM1), committed(INDEX1, TERM1), ]
	TERM2 -> [ (log(SERVER1, INDEX0) = TERM2), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX1) = V:term:e6:), committed(INDEX1, V:term:e6:), ]
	TERM2 -> [ (log(SERVER1, INDEX0) = V:term:e6:), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e6:), ]
ucubes2qv #3
	(log(SERVER0, INDEX0) = V:term:e6:) -> [ TERM0, ]
	(log(SERVER1, INDEX0) = V:term:e6:) -> [ TERM2, ]
	((log(SERVER0, INDEX1) = V:term:e6:) & committed(INDEX1, V:term:e6:)) -> [ TERM1, ]
(partition) #3 term:e6: -> { TERM0, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (log(SERVER0, INDEX1) = TERM1), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM2), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM0), (log(V:server:e6:, INDEX1) = TERM1), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX0) = TERM2), ]
ucubes2qv #2
	(log(V:server:e6:, INDEX0) = TERM2) -> [ SERVER1, ]
	((log(V:server:e6:, INDEX0) = TERM0) & (log(V:server:e6:, INDEX1) = TERM1)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
	TERM2 -> log(SERVER1, INDEX0)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = log(SERVER0, INDEX1))
	~(log(SERVER0, INDEX0) = log(SERVER1, INDEX0))
	~(log(SERVER0, INDEX1) = log(SERVER1, INDEX0))
	committed(INDEX1, log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX0)) | (log(SERVER0, INDEX1) = log(SERVER1, INDEX0)) | ~committed(INDEX1, log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i2) = t1) | ~(log(s1, i0) = t2) | ~committed(i2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX0)) | (log(SERVER0, INDEX1) = log(SERVER1, INDEX0)) | ~committed(INDEX1, log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
@    41s  is global clause? No
@    42s  Learning in F[3]: (forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
@    42s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    42s  F[2] /\ T /\ C+ ?
@    42s  	Ans. UNSAT
@    42s  F[3] unsat core #4 	(ucsz: 8 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i1) = t2)
	(log(s1, i0) = t0)
	~leader(s0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(log(s0, i1) = t2) | ~(log(s1, i0) = t0) | leader(s0))
(relations)
	log
	leader
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
	(log(SERVER1, INDEX0) = TERM0)
	(log(SERVER0, INDEX1) = TERM2)
(antecedent reduction)
@    42s  antecedent: 7 -> 3 (reduced)
	removed: INDEX1
	removed: SERVER0
	removed: INDEX0
	removed: SERVER1

qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
	TERM2 -> [ (log(SERVER0, INDEX1) = TERM2), ]
	TERM0 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e6:), ]
	TERM2 -> [ (log(SERVER0, INDEX1) = V:term:e6:), ]
	TERM0 -> [ (log(SERVER1, INDEX0) = V:term:e6:), ]
ucubes2qv #3
	(log(SERVER0, INDEX0) = V:term:e6:) -> [ TERM1, ]
	(log(SERVER1, INDEX0) = V:term:e6:) -> [ TERM0, ]
	(log(SERVER0, INDEX1) = V:term:e6:) -> [ TERM2, ]
(partition) #3 term:e6: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), (log(SERVER0, INDEX1) = TERM2), ~leader(SERVER0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM1), (log(V:server:e6:, INDEX1) = TERM2), ~leader(V:server:e6:), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e6:, INDEX0) = TERM0) -> [ SERVER1, ]
	((log(V:server:e6:, INDEX0) = TERM1) & (log(V:server:e6:, INDEX1) = TERM2) & ~leader(V:server:e6:)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
	TERM2 -> log(SERVER0, INDEX1)
	TERM0 -> log(SERVER1, INDEX0)
(cube eq: post)
	~(log(SERVER1, INDEX0) = log(SERVER0, INDEX1))
	~(log(SERVER0, INDEX0) = log(SERVER0, INDEX1))
	~(log(SERVER1, INDEX0) = log(SERVER0, INDEX0))
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER1, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER1, INDEX0) = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(log(s0, i1) = t2) | ~(log(s1, i0) = t0) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER1, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER1, INDEX0) = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
@    42s  is global clause? No
@    42s  Learning in F[3]: (forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
@    42s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    42s  F[2] /\ T /\ C+ ?
@    42s  	Ans. UNSAT
@    42s  F[3] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i1) = t2)
	(loglen(s1) = i0)
	~leader(s0)
	(termzero = t0)
	(log(s0, i2) = t2)
(clause)
	(~(log(s0, i2) = t2) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0) | ~(termzero = t0) | leader(s0))
(relations)
	loglen
	termzero
	log
	leader
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX1) = TERM1)
	(log(SERVER0, INDEX2) = TERM1)
	(termzero = TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    42s  antecedent: 7 -> 4 (reduced)
	removed: INDEX2
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX1) = TERM1)
	(log(SERVER0, INDEX2) = TERM1)
	~leader(SERVER0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
	INDEX2
	TERM1
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	index:e6:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
	INDEX1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
	INDEX2 -> [ (log(SERVER0, INDEX2) = TERM1), ]
qv2ucubes #3
	INDEX0 -> [ (loglen(SERVER1) = V:index:e6:), ]
	INDEX1 -> [ (log(SERVER1, V:index:e6:) = TERM1), ]
	INDEX2 -> [ (log(SERVER0, V:index:e6:) = TERM1), ]
ucubes2qv #3
	(log(SERVER1, V:index:e6:) = TERM1) -> [ INDEX1, ]
	(log(SERVER0, V:index:e6:) = TERM1) -> [ INDEX2, ]
	(loglen(SERVER1) = V:index:e6:) -> [ INDEX0, ]
(partition) #3 index:e6: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX2) = TERM1), ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (log(SERVER1, INDEX1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX2) = TERM1), ~leader(V:server:e6:), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX1) = TERM1), (loglen(V:server:e6:) = INDEX0), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX2) = TERM1) & ~leader(V:server:e6:)) -> [ SERVER0, ]
	((log(V:server:e6:, INDEX1) = TERM1) & (loglen(V:server:e6:) = INDEX0)) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
	TERM1 -> log(SERVER1, INDEX1)
(cube eq: post)
	~(termzero = log(SERVER1, INDEX1))
	~(loglen(SERVER1) = INDEX1)
	(log(SERVER0, INDEX2) = log(SERVER1, INDEX1))
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	INDEX2
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, INDEX2 . ((termzero = log(SERVER1, INDEX1)) | (loglen(SERVER1) = INDEX1) | ~(log(SERVER0, INDEX2) = log(SERVER1, INDEX1)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i2) = t2) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0) | ~(termzero = t0) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, INDEX2 . ((termzero = log(SERVER1, INDEX1)) | (loglen(SERVER1) = INDEX1) | ~(log(SERVER0, INDEX2) = log(SERVER1, INDEX1)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, I2 . ((log(S0, I2) = log(S1, I1)) -> ((termzero = log(S1, I1)) | (loglen(S1) = I1) | leader(S0))))
@    43s  is global clause? No
@    43s  Learning in F[3]: (forall S0, S1, I1, I2 . ((log(S0, I2) = log(S1, I1)) -> ((termzero = log(S1, I1)) | (loglen(S1) = I1) | leader(S0))))
@    43s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    43s  F[2] /\ T /\ C+ ?
@    43s  	Ans. UNSAT
@    43s  F[3] unsat core #3 	(ucsz: 13 -> 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	committed(i0, t1)
	(log(s0, i0) = t0)
	(log(s1, i1) = t1)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~committed(i0, t1))
(relations)
	log
	committed
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER1, INDEX1) = TERM1)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    43s  antecedent: 6 -> 6

qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX1) = TERM1), ]
ucubes2qv #2
	(log(V:server:e6:, INDEX0) = TERM0) -> [ SERVER0, ]
	(log(V:server:e6:, INDEX1) = TERM1) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX1)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	committed(INDEX0, log(SERVER1, INDEX1))
	~(SERVER0 = SERVER1)
	~(log(SERVER0, INDEX0) = log(SERVER1, INDEX1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | ~committed(INDEX0, log(SERVER1, INDEX1)) | (SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | ~committed(INDEX0, log(SERVER1, INDEX1)) | (SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = log(SERVER1, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
@    43s  is global clause? No
@    43s  Learning in F[3]: (forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
@    43s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    43s  F[2] /\ T /\ C+ ?
@    44s  	Ans. UNSAT
@    44s  F[3] unsat core #3 	(ucsz: 9 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(loglen(s1) = i2)
	committed(i1, t0)
(clause)
	(~(loglen(s1) = i2) | ~(termzero = t0) | ~committed(i1, t0))
(relations)
	loglen
	termzero
	committed
(cube: std)
	(loglen(SERVER0) = INDEX1)
	(termzero = TERM0)
	committed(INDEX0, TERM0)
(antecedent reduction)
@    44s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
	SERVER0
	INDEX1
(antecedent eq)
	index:e6:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX0 = loglen(SERVER0))
	committed(INDEX0, termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . ((INDEX0 = loglen(SERVER0)) | ~committed(INDEX0, termzero)))
---------------------------
(original clause)
	(~(loglen(s1) = i2) | ~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . ((INDEX0 = loglen(SERVER0)) | ~committed(INDEX0, termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    44s  is global clause? No
@    44s  Learning in F[3]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    44s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    44s  F[2] /\ T /\ C+ ?
@    44s  	Ans. UNSAT
@    44s  F[3] unsat core #4 	(ucsz: 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i0) = t0)
	(log(s1, i1) = t2)
	(loglen(s1) = i0)
	(termzero = t0)
(clause)
	(~(log(s1, i0) = t0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0) | ~(termzero = t0))
(relations)
	loglen
	termzero
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
	(termzero = TERM0)
(antecedent reduction)
@    44s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	TERM1
	INDEX0
	INDEX1
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, INDEX1)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
@    44s  is global clause? No
@    44s  Learning in F[3]: (forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
@    44s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    44s  F[2] /\ T /\ C+ ?
@    44s  	Ans. UNSAT
@    45s  F[3] unsat core #5 	(ucsz: 10 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i2)
	(indzero = i0)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t1) | leader(s1))
(relations)
	indzero
	committed
	leader
	loglen
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	~leader(SERVER1)
	(loglen(SERVER1) = INDEX2)
	(indzero = INDEX0)
(antecedent reduction)
@    45s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~leader(SERVER1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	(loglen(SERVER1) = INDEX2)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX2
	TERM0
(antecedent eq)
	index:e6:
	-> ~(indzero = INDEX1)
	-> ~(indzero = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	index:e6: -> [ indzero, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	indzero -> [ (loglen(SERVER0) = indzero), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
qv2ucubes #3
	indzero -> [ (loglen(SERVER0) = V:index:e6:), ]
	INDEX1 -> [ committed(V:index:e6:, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = V:index:e6:), ]
ucubes2qv #3
	committed(V:index:e6:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER0) = V:index:e6:) -> [ indzero, ]
	(loglen(SERVER1) = V:index:e6:) -> [ INDEX2, ]
(partition) #3 index:e6: -> { INDEX1, | indzero, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
	SERVER1 -> [ ~leader(SERVER1), (loglen(SERVER1) = INDEX2), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e6:) = indzero), ]
	SERVER1 -> [ (loglen(V:server:e6:) = INDEX2), ~leader(V:server:e6:), ]
ucubes2qv #2
	(loglen(V:server:e6:) = indzero) -> [ SERVER0, ]
	((loglen(V:server:e6:) = INDEX2) & ~leader(V:server:e6:)) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
(cube eq: post)
	~leader(SERVER1)
	~(INDEX1 = loglen(SERVER1))
	~(indzero = loglen(SERVER1))
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	~(indzero = INDEX1)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0 . (leader(SERVER1) | (INDEX1 = loglen(SERVER1)) | (indzero = loglen(SERVER1)) | ~committed(INDEX1, TERM0) | ~(loglen(SERVER0) = indzero) | (indzero = INDEX1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t1) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0 . (leader(SERVER1) | (INDEX1 = loglen(SERVER1)) | (indzero = loglen(SERVER1)) | ~committed(INDEX1, TERM0) | ~(loglen(SERVER0) = indzero) | (indzero = INDEX1)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
@    45s  is global clause? No
@    45s  Learning in F[3]: (forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
@    45s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    45s  F[2] /\ T /\ C+ ?
@    45s  	Ans. UNSAT
@    45s  F[3] unsat core #4 	(ucsz: 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i1) = t2)
	(termzero = t0)
	(log(s1, i0) = t2)
	(currentTerm(s1) = t1)
(clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i0) = t2) | ~(log(s1, i1) = t2) | ~(termzero = t0))
(relations)
	termzero
	log
	currentTerm
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM0)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
	(log(SERVER0, INDEX1) = TERM2)
(antecedent reduction)
@    46s  antecedent: 5 -> 5

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
	(log(SERVER0, INDEX1) = TERM2)
(qvars eq)
	SERVER0
	INDEX0
	INDEX1
	TERM1
	TERM2
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
	index:e6:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), (log(SERVER0, INDEX1) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e6:), (log(SERVER0, INDEX1) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(currentTerm(SERVER0) = V:term:e6:) -> [ TERM1, ]
	((log(SERVER0, INDEX0) = V:term:e6:) & (log(SERVER0, INDEX1) = V:term:e6:)) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER0)
	TERM2 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	(log(SERVER0, INDEX1) = log(SERVER0, INDEX0))
	~(termzero = log(SERVER0, INDEX0))
	~(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i0) = t2) | ~(log(s1, i1) = t2) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0, I1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0)))))
@    46s  is global clause? No
@    46s  Learning in F[3]: (forall S0, I0, I1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0)))))
@    46s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    46s  F[2] /\ T /\ C+ ?
@    46s  	Ans. UNSAT
@    46s  F[3] unsat core #5 	(ucsz: 10 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i0)
	(termzero = t0)
	(log(s0, i0) = t0)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t1) | leader(s1))
(relations)
	loglen
	termzero
	log
	committed
	leader
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	(termzero = TERM0)
	committed(INDEX1, TERM1)
(antecedent reduction)
@    46s  antecedent: 6 -> 4 (reduced)
	removed: TERM0
	removed: TERM1

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	(log(SERVER0, INDEX0) = termzero)
	committed(INDEX1, TERM1)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
	TERM1
(antecedent eq)
	index:e6:
	-> ~(INDEX0 = INDEX1)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = termzero), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = termzero), (loglen(V:server:e6:) = INDEX0), ]
	SERVER1 -> [ ~leader(V:server:e6:), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX0) = termzero) & (loglen(V:server:e6:) = INDEX0)) -> [ SERVER0, ]
	~leader(V:server:e6:) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(loglen(SERVER0) = INDEX1)
	~(SERVER0 = SERVER1)
	~leader(SERVER1)
	committed(INDEX1, TERM1)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	TERM1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t1) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = INDEX1) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, TERM1)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
@    46s  is global clause? No
@    46s  Learning in F[3]: (forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
@    46s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    46s  F[2] /\ T /\ C+ ?
@    46s  	Ans. UNSAT
@    47s  F[3] unsat core #3 	(ucsz: 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i0)
	committed(i2, t1)
	(log(s0, i2) = t1)
(clause)
	(~(log(s0, i2) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t1))
(relations)
	loglen
	log
	committed
(cube: std)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
(antecedent reduction)
@    47s  antecedent: 2 -> 2

(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, INDEX1)
(cube eq: post)
	~(loglen(SERVER0) = INDEX1)
	committed(INDEX1, log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . ((loglen(SERVER0) = INDEX1) | ~committed(INDEX1, log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i2) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . ((loglen(SERVER0) = INDEX1) | ~committed(INDEX1, log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
@    47s  is global clause? No
@    47s  Learning in F[3]: (forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
@    47s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    47s  F[2] /\ T /\ C+ ?
@    47s  	Ans. UNSAT
@    47s  F[3] unsat core #5 	(ucsz: 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~leader(s0)
	(termzero = t0)
	(loglen(s1) = i1)
	(log(s0, i0) = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s1) = i1) | ~(termzero = t0) | leader(s0))
(relations)
	indzero
	termzero
	log
	leader
	loglen
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    47s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
	TERM0 -> termzero
(cube eq)
	~leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM1
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	index:e6:
	-> ~(indzero = INDEX1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, indzero) = TERM1), ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM1), ~leader(V:server:e6:), ]
	SERVER1 -> [ (loglen(V:server:e6:) = INDEX1), ]
ucubes2qv #2
	(loglen(V:server:e6:) = INDEX1) -> [ SERVER1, ]
	((log(V:server:e6:, indzero) = TERM1) & ~leader(V:server:e6:)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, indzero)
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	~(termzero = log(SERVER0, indzero))
	~(indzero = loglen(SERVER1))
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((termzero = log(SERVER0, indzero)) | (indzero = loglen(SERVER1)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s1) = i1) | ~(termzero = t0) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((termzero = log(SERVER0, indzero)) | (indzero = loglen(SERVER1)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((termzero = log(S0, indzero)) | (indzero = loglen(S1)) | leader(S0)))
@    47s  is global clause? No
@    47s  Learning in F[3]: (forall S0, S1 . ((termzero = log(S0, indzero)) | (indzero = loglen(S1)) | leader(S0)))
@    47s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    47s  F[2] /\ T /\ C+ ?
@    47s  	Ans. UNSAT
@    48s  F[3] unsat core #4 	(ucsz: 14 -> 12 -> 10 -> 9 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i0) = t0)
	(termzero = t2)
	committed(i1, t0)
	~indlte(i1, i1)
(clause)
	(~(log(s0, i0) = t0) | ~(termzero = t2) | ~committed(i1, t0) | indlte(i1, i1))
(relations)
	indlte
	log
	termzero
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	~indlte(INDEX1, INDEX1)
	(termzero = TERM1)
(antecedent reduction)
@    48s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	~indlte(INDEX1, INDEX1)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX1, log(SERVER0, INDEX0))
	~indlte(INDEX1, INDEX1)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
	INDEX1
(boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . (~committed(INDEX1, log(SERVER0, INDEX0)) | indlte(INDEX1, INDEX1) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(termzero = t2) | ~committed(i1, t0) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . (~committed(INDEX1, log(SERVER0, INDEX0)) | indlte(INDEX1, INDEX1) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
@    48s  is global clause? No
@    48s  Learning in F[3]: (forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
@    48s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    48s  F[2] /\ T /\ C+ ?
@    49s  	Ans. UNSAT
@    49s  F[3] unsat core #3 	(ucsz: 9 -> 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i0) = t0)
	~lte(t0, t1)
	committed(i1, t1)
(clause)
	(~(log(s1, i0) = t0) | ~committed(i1, t1) | lte(t0, t1))
(relations)
	log
	lte
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~lte(TERM0, TERM1)
	committed(INDEX1, TERM1)
(antecedent reduction)
@    49s  antecedent: 4 -> 0 (reduced)
	removed: TERM0
	removed: INDEX1
	removed: TERM1
	removed: INDEX0

(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~lte(log(SERVER0, INDEX0), TERM1)
	committed(INDEX1, TERM1)
(qvars eq: post)
	TERM1
	INDEX0
	INDEX1
	SERVER0
(boosted clause)
	(forall TERM1, INDEX0, INDEX1, SERVER0 . (lte(log(SERVER0, INDEX0), TERM1) | ~committed(INDEX1, TERM1)))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~committed(i1, t1) | lte(t0, t1))
(learnt sym-boosted clause)
	(forall TERM1, INDEX0, INDEX1, SERVER0 . (lte(log(SERVER0, INDEX0), TERM1) | ~committed(INDEX1, TERM1)))
---------------------------
(clause-type: univ)	(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
@    49s  is global clause? No
@    49s  Learning in F[3]: (forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
@    49s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    49s  F[2] /\ T /\ C+ ?
@    49s  	Ans. UNSAT
@    50s  F[3] unsat core #4 	(ucsz: 14 -> 11 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(currentTerm(s0) = t0)
	committed(i2, t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0))
(relations)
	loglen
	committed
	currentTerm
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(currentTerm(SERVER0) = TERM0)
(antecedent reduction)
@    50s  antecedent: 4 -> 4

qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (currentTerm(V:server:e6:) = TERM0), (loglen(V:server:e6:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e6:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e6:) = INDEX0) -> [ SERVER1, ]
	((currentTerm(V:server:e6:) = TERM0) & (loglen(V:server:e6:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	committed(INDEX1, currentTerm(SERVER0))
	~(SERVER0 = SERVER1)
	~(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	SERVER0
	INDEX1
	SERVER1
(boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, currentTerm(SERVER0)) | (SERVER0 = SERVER1) | (loglen(SERVER1) = INDEX1) | ~(loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, currentTerm(SERVER0)) | (SERVER0 = SERVER1) | (loglen(SERVER1) = INDEX1) | ~(loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
@    50s  is global clause? No
@    50s  Learning in F[3]: (forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
@    50s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    50s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e7 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e2:e5 -> s0
		V__fml:q:e1:e2:e5 -> q0
@    50s  	Ans. SAT
@    50s  F[1] /\ T /\ C+ ?
@    50s  	Ans. UNSAT
@    51s  F[2] unsat core #4 	(ucsz: 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i1) = t2)
	(log(s0, i0) = t0)
	~succ(i0, i1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(log(s0, i1) = t2) | succ(i0, i1))
(relations)
	indzero
	succ
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	~succ(INDEX0, INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    51s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER0, INDEX1) = TERM1)
	~succ(indzero, INDEX1)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	TERM1
	INDEX1
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = TERM1)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	~(log(SERVER0, indzero) = log(SERVER0, INDEX1))
	~succ(indzero, INDEX1)
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . ((log(SERVER0, indzero) = log(SERVER0, INDEX1)) | succ(indzero, INDEX1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(log(s0, i1) = t2) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . ((log(SERVER0, indzero) = log(SERVER0, INDEX1)) | succ(indzero, INDEX1)))
---------------------------
(clause-type: univ)	(forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
@    51s  is global clause? No
@    51s  Learning in F[2]: (forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
@    51s  F[2] /\ T /\ C+ ?
@    51s  	Ans. UNSAT
@    52s  F[3] unsat core #3 	(ucsz: 10 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i0) = t0)
	leader(s0)
	committed(i1, t0)
(clause)
	(~(log(s0, i0) = t0) | ~committed(i1, t0) | ~leader(s0))
(relations)
	log
	committed
	leader
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	leader(SERVER0)
(antecedent reduction)
@    52s  antecedent: 2 -> 2

(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	committed(INDEX1, log(SERVER0, INDEX0))
	leader(SERVER0)
(qvars eq: post)
	INDEX0
	SERVER0
	INDEX1
(boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . ((INDEX0 = INDEX1) | ~committed(INDEX1, log(SERVER0, INDEX0)) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~committed(i1, t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . ((INDEX0 = INDEX1) | ~committed(INDEX1, log(SERVER0, INDEX0)) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
@    52s  is global clause? No
@    52s  Learning in F[3]: (forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
@    52s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #1
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
	F[2]: #7
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
	F[3]: #26
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
		(forall T0 . ~committed(indzero, T0))
		(forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
		(forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall S0, S1 . ((termzero = log(S0, indzero)) | (indzero = loglen(S1)) | leader(S0)))
		(forall S0, S1, I1, I2 . ((log(S0, I2) = log(S1, I1)) -> ((termzero = log(S1, I1)) | (loglen(S1) = I1) | leader(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall I0, S0 . ((log(S0, indzero) = log(S0, I0)) -> (succ(indzero, I0) | (I0 = indzero) | (log(S0, I0) = termzero))))
		(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
		(forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
		(forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
		(forall S0, I0, I1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0)))))
		(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
		(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
		(forall I0, S0 . ((currentTerm(S0) = log(S0, I0)) -> (leader(S0) | (I0 = indzero) | (log(S0, I0) = termzero))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
		(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
		(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
		(forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
@    52s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #1 to F[3]
@    53s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
Trying forwarding F[3]
Forwarded #10 to F[4]
@    54s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    54s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    54s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    54s  Learning in F[4]: (forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
@    54s  Learning in F[4]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    54s  Learning in F[4]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    54s  Learning in F[4]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    54s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    54s  Learning in F[4]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    54s  Learning in F[4]: (forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
@    54s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    54s  Learning in F[4]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    54s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    54s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    54s  Learning in F[4]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    54s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    54s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    54s  F[3] /\ T /\ C+ ?
@    54s  	Ans. UNSAT
@    54s  F[4] unsat core #5 	(ucsz: 9 -> 6 -> 5 -> 5)
(minimal unsat core)
	~lte(t2, t1)
	(termzero = t0)
	~leader(s0)
	(log(s0, i2) = t2)
	(log(s0, i0) = t2)
(clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~(termzero = t0) | leader(s0) | lte(t2, t1))
(relations)
	termzero
	log
	lte
	leader
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM0)
	~lte(TERM2, TERM1)
	~leader(SERVER0)
	(log(SERVER0, INDEX0) = TERM2)
	(log(SERVER0, INDEX1) = TERM2)
(antecedent reduction)
@    55s  antecedent: 5 -> 4 (reduced)
	removed: TERM2

(eq map)
	TERM0 -> termzero
(cube eq)
	~lte(TERM2, TERM1)
	~leader(SERVER0)
	(log(SERVER0, INDEX0) = TERM2)
	(log(SERVER0, INDEX1) = TERM2)
(qvars eq)
	SERVER0
	INDEX0
	INDEX1
	TERM1
	TERM2
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	index:e6:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ ~lte(TERM2, TERM1), ]
	termzero -> [ ]
	TERM2 -> [ ~lte(TERM2, TERM1), (log(SERVER0, INDEX0) = TERM2), (log(SERVER0, INDEX1) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ ~lte(TERM2, V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ ~lte(V:term:e6:, TERM1), (log(SERVER0, INDEX0) = V:term:e6:), (log(SERVER0, INDEX1) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	~lte(TERM2, V:term:e6:) -> [ TERM1, ]
	((log(SERVER0, INDEX0) = V:term:e6:) & (log(SERVER0, INDEX1) = V:term:e6:) & ~lte(V:term:e6:, TERM1)) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM2 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	~(termzero = TERM1)
	(log(SERVER0, INDEX1) = log(SERVER0, INDEX0))
	~lte(log(SERVER0, INDEX0), TERM1)
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
	TERM1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1, TERM1 . ((INDEX0 = INDEX1) | (termzero = TERM1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | lte(log(SERVER0, INDEX0), TERM1) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~(termzero = t0) | leader(s0) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1, TERM1 . ((INDEX0 = INDEX1) | (termzero = TERM1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | lte(log(SERVER0, INDEX0), TERM1) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I0, I1, T1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = T1) | lte(log(S0, I0), T1) | leader(S0))))
@    55s  is global clause? No
@    55s  Learning in F[4]: (forall S0, I0, I1, T1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = T1) | lte(log(S0, I0), T1) | leader(S0))))
@    55s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    55s  F[3] /\ T /\ C+ ?
@    55s  	Ans. UNSAT
@    55s  F[4] unsat core #4 	(ucsz: 10 -> 5 -> 5 -> 4 -> 4)
(minimal unsat core)
	~lte(t2, t1)
	leader(s1)
	~indlte(i1, i1)
	committed(i1, t1)
(clause)
	(~committed(i1, t1) | ~leader(s1) | indlte(i1, i1) | lte(t2, t1))
(relations)
	indlte
	lte
	committed
	leader
(cube: std)
	~lte(TERM1, TERM0)
	committed(INDEX0, TERM0)
	~indlte(INDEX0, INDEX0)
	leader(SERVER0)
(antecedent reduction)
@    55s  antecedent: 2 -> 0 (reduced)
	removed: TERM0
	removed: TERM1

(boosted clause)
	(forall TERM1, INDEX0, TERM0, SERVER0 . (~committed(INDEX0, TERM0) | lte(TERM1, TERM0) | ~leader(SERVER0) | indlte(INDEX0, INDEX0)))
---------------------------
(original clause)
	(~committed(i1, t1) | ~leader(s1) | indlte(i1, i1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall TERM1, INDEX0, TERM0, SERVER0 . (~committed(INDEX0, TERM0) | lte(TERM1, TERM0) | ~leader(SERVER0) | indlte(INDEX0, INDEX0)))
---------------------------
(clause-type: univ)	(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
@    55s  is global clause? No
@    55s  Learning in F[4]: (forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
@    55s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    55s  F[3] /\ T /\ C+ ?
@    55s  	Ans. UNSAT
@    55s  F[4] unsat core #7 	(ucsz: 7 -> 7)
(minimal unsat core)
	~succ(i0, i2)
	(log(s1, i1) = t2)
	(log(s0, i0) = t2)
	~leader(s1)
	(log(s0, i2) = t2)
	(indzero = i0)
	(termzero = t0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~(log(s1, i1) = t2) | ~(termzero = t0) | leader(s1) | succ(i0, i2))
(relations)
	indzero
	termzero
	succ
	log
	leader
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	~succ(INDEX0, INDEX2)
	(indzero = INDEX0)
	(log(SERVER1, INDEX1) = TERM1)
	(log(SERVER0, INDEX2) = TERM1)
	~leader(SERVER1)
(antecedent reduction)
@    56s  antecedent: 7 -> 4 (reduced)
	removed: SERVER0
	removed: INDEX1
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
	TERM0 -> termzero
(cube eq)
	(log(SERVER1, INDEX1) = TERM1)
	~succ(indzero, INDEX2)
	(log(SERVER0, INDEX2) = TERM1)
	~leader(SERVER1)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX2
	TERM1
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	index:e6:
	-> ~(indzero = INDEX2)
(fullsorts)
	index:e6: -> [ indzero, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	indzero -> [ ~succ(indzero, INDEX2), (log(SERVER0, indzero) = TERM1), ]
	INDEX1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
	INDEX2 -> [ ~succ(indzero, INDEX2), (log(SERVER0, INDEX2) = TERM1), ]
qv2ucubes #3
	indzero -> [ (log(SERVER0, V:index:e6:) = TERM1), ~succ(V:index:e6:, INDEX2), ]
	INDEX1 -> [ (log(SERVER1, V:index:e6:) = TERM1), ]
	INDEX2 -> [ ~succ(indzero, V:index:e6:), (log(SERVER0, V:index:e6:) = TERM1), ]
ucubes2qv #3
	((log(SERVER0, V:index:e6:) = TERM1) & ~succ(V:index:e6:, INDEX2)) -> [ indzero, ]
	((log(SERVER0, V:index:e6:) = TERM1) & ~succ(indzero, V:index:e6:)) -> [ INDEX2, ]
	(log(SERVER1, V:index:e6:) = TERM1) -> [ INDEX1, ]
(partition) #3 index:e6: -> { indzero, | INDEX2, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX2) = TERM1), (log(SERVER0, indzero) = TERM1), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM1), (log(V:server:e6:, INDEX2) = TERM1), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX1) = TERM1), ~leader(V:server:e6:), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX2) = TERM1) & (log(V:server:e6:, indzero) = TERM1)) -> [ SERVER0, ]
	((log(V:server:e6:, INDEX1) = TERM1) & ~leader(V:server:e6:)) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX1)
(cube eq: post)
	~succ(indzero, INDEX2)
	~(termzero = log(SERVER1, INDEX1))
	(log(SERVER0, INDEX2) = log(SERVER1, INDEX1))
	(log(SERVER0, indzero) = log(SERVER1, INDEX1))
	~leader(SERVER1)
	~(indzero = INDEX2)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX2
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX2, INDEX1 . (succ(indzero, INDEX2) | (termzero = log(SERVER1, INDEX1)) | ~(log(SERVER0, INDEX2) = log(SERVER1, INDEX1)) | ~(log(SERVER0, indzero) = log(SERVER1, INDEX1)) | leader(SERVER1) | (indzero = INDEX2)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~(log(s1, i1) = t2) | ~(termzero = t0) | leader(s1) | succ(i0, i2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX2, INDEX1 . (succ(indzero, INDEX2) | (termzero = log(SERVER1, INDEX1)) | ~(log(SERVER0, INDEX2) = log(SERVER1, INDEX1)) | ~(log(SERVER0, indzero) = log(SERVER1, INDEX1)) | leader(SERVER1) | (indzero = INDEX2)))
---------------------------
(clause-type: univ)	(forall S0, S1, I2, I1 . (((log(S0, I2) = log(S1, I1)) & (log(S0, indzero) = log(S1, I1))) -> (succ(indzero, I2) | (termzero = log(S1, I1)) | leader(S1) | (indzero = I2))))
@    56s  is global clause? No
@    56s  Learning in F[4]: (forall S0, S1, I2, I1 . (((log(S0, I2) = log(S1, I1)) & (log(S0, indzero) = log(S1, I1))) -> (succ(indzero, I2) | (termzero = log(S1, I1)) | leader(S1) | (indzero = I2))))
@    56s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    56s  F[3] /\ T /\ C+ ?
@    56s  	Ans. UNSAT
@    56s  F[4] unsat core #5 	(ucsz: 10 -> 5 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t2)
	(log(s0, i1) = t1)
	(termzero = t0)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i1) = t1) | ~(termzero = t0) | ~committed(i1, t1) | leader(s1))
(relations)
	log
	termzero
	committed
	leader
	currentTerm
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX0, TERM1)
	~leader(SERVER1)
	(currentTerm(SERVER0) = TERM2)
(antecedent reduction)
@    56s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX0, TERM1)
	~leader(SERVER1)
	(currentTerm(SERVER0) = TERM2)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	TERM1
	TERM2
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), committed(INDEX0, TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e6:), committed(INDEX0, V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(currentTerm(SERVER0) = V:term:e6:) -> [ TERM2, ]
	((log(SERVER0, INDEX0) = V:term:e6:) & committed(INDEX0, V:term:e6:)) -> [ TERM1, ]
(partition) #3 term:e6: -> { termzero, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), (currentTerm(SERVER0) = TERM2), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM1), (currentTerm(V:server:e6:) = TERM2), ]
	SERVER1 -> [ ~leader(V:server:e6:), ]
ucubes2qv #2
	((currentTerm(V:server:e6:) = TERM2) & (log(V:server:e6:, INDEX0) = TERM1)) -> [ SERVER0, ]
	~leader(V:server:e6:) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	committed(INDEX0, log(SERVER0, INDEX0))
	~leader(SERVER1)
	~(termzero = currentTerm(SERVER0))
	~(termzero = log(SERVER0, INDEX0))
	~(log(SERVER0, INDEX0) = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
	SERVER1
(boosted clause)
	(forall SERVER0, INDEX0, SERVER1 . (~committed(INDEX0, log(SERVER0, INDEX0)) | leader(SERVER1) | (termzero = currentTerm(SERVER0)) | (termzero = log(SERVER0, INDEX0)) | (log(SERVER0, INDEX0) = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i1) = t1) | ~(termzero = t0) | ~committed(i1, t1) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, SERVER1 . (~committed(INDEX0, log(SERVER0, INDEX0)) | leader(SERVER1) | (termzero = currentTerm(SERVER0)) | (termzero = log(SERVER0, INDEX0)) | (log(SERVER0, INDEX0) = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0, S1 . (committed(I0, log(S0, I0)) -> (leader(S1) | (termzero = currentTerm(S0)) | (termzero = log(S0, I0)) | (log(S0, I0) = currentTerm(S0)))))
@    57s  is global clause? No
@    57s  Learning in F[4]: (forall S0, I0, S1 . (committed(I0, log(S0, I0)) -> (leader(S1) | (termzero = currentTerm(S0)) | (termzero = log(S0, I0)) | (log(S0, I0) = currentTerm(S0)))))
@    57s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    57s  F[3] /\ T /\ C+ ?
@    57s  	Ans. UNSAT
@    57s  F[4] unsat core #5 	(ucsz: 11 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~lte(t2, t1)
	(log(s1, i1) = t2)
	(loglen(s1) = i1)
	committed(i2, t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i1) | ~committed(i2, t1) | lte(t2, t1))
(relations)
	indzero
	log
	committed
	lte
	loglen
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX2, TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	~lte(TERM1, TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    57s  antecedent: 5 -> 2 (reduced)
	removed: TERM0
	removed: INDEX2
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX2, TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	~lte(TERM1, TERM0)
(qvars eq)
	SERVER0
	INDEX1
	INDEX2
	TERM0
	TERM1
(antecedent eq)
	index:e6:
	-> ~(indzero = INDEX1)
(fullsorts)
	index:e6: -> [ indzero, INDEX1, INDEX2, ]
qv2cubes #3
	indzero -> [ ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = TERM1), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ]
qv2ucubes #3
	indzero -> [ ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e6:), (log(SERVER0, V:index:e6:) = TERM1), ]
	INDEX2 -> [ committed(V:index:e6:, TERM0), ]
ucubes2qv #3
	true -> [ indzero, ]
	committed(V:index:e6:, TERM0) -> [ INDEX2, ]
	((log(SERVER0, V:index:e6:) = TERM1) & (loglen(SERVER0) = V:index:e6:)) -> [ INDEX1, ]
(partition) #3 index:e6: -> { indzero, | INDEX2, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER0, loglen(SERVER0))
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX2, TERM0)
	~(indzero = loglen(SERVER0))
	~lte(log(SERVER0, loglen(SERVER0)), TERM0)
(qvars eq: post)
	SERVER0
	INDEX2
	TERM0
(boosted clause)
	(forall SERVER0, INDEX2, TERM0 . (~committed(INDEX2, TERM0) | (indzero = loglen(SERVER0)) | lte(log(SERVER0, loglen(SERVER0)), TERM0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i1) = t2) | ~(loglen(s1) = i1) | ~committed(i2, t1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX2, TERM0 . (~committed(INDEX2, TERM0) | (indzero = loglen(SERVER0)) | lte(log(SERVER0, loglen(SERVER0)), TERM0)))
---------------------------
(clause-type: univ)	(forall S0, I2, T0 . (committed(I2, T0) -> ((indzero = loglen(S0)) | lte(log(S0, loglen(S0)), T0))))
@    57s  is global clause? No
@    57s  Learning in F[4]: (forall S0, I2, T0 . (committed(I2, T0) -> ((indzero = loglen(S0)) | lte(log(S0, loglen(S0)), T0))))
@    57s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    58s  F[3] /\ T /\ C+ ?
@    58s  	Ans. UNSAT
@    58s  F[4] unsat core #4 	(ucsz: 13 -> 11 -> 10 -> 8 -> 7 -> 4 -> 4)
(minimal unsat core)
	~lte(t2, t1)
	(log(s0, i1) = t2)
	committed(i2, t1)
	(log(s0, i0) = t2)
(clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i1) = t2) | ~committed(i2, t1) | lte(t2, t1))
(relations)
	log
	lte
	committed
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX2, TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	~lte(TERM1, TERM0)
(antecedent reduction)
@    58s  antecedent: 5 -> 2 (reduced)
	removed: TERM0
	removed: INDEX2
	removed: TERM1

qv2cubes #3
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM1), ]
	INDEX1 -> [ (log(SERVER0, INDEX1) = TERM1), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ]
qv2ucubes #3
	INDEX0 -> [ (log(SERVER0, V:index:e6:) = TERM1), ]
	INDEX1 -> [ (log(SERVER0, V:index:e6:) = TERM1), ]
	INDEX2 -> [ committed(V:index:e6:, TERM0), ]
ucubes2qv #2
	committed(V:index:e6:, TERM0) -> [ INDEX2, ]
	(log(SERVER0, V:index:e6:) = TERM1) -> [ INDEX0, INDEX1, ]
(partition) #2 index:e6: -> { INDEX2, | INDEX0, INDEX1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	INDEX2:
		committed(INDEX2, TERM0)
ucmulti:
	(log(SERVER0, INDEX0) = TERM1)
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> index)? False
	(epr check: reverse)	allowed(arc: index -> index)? False
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
(epr reduced)
	(forall SERVER0 . (exists INDEX0 . (forall TERM1, INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~committed(INDEX2, TERM0) | lte(TERM1, TERM0)))))
(non-epr version)
	(forall SERVER0 . (forall TERM1, INDEX2, TERM0 . (exists INDEX0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~committed(INDEX2, TERM0) | lte(TERM1, TERM0)))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall SERVER0 . (exists INDEX0 . (forall TERM1, INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~committed(INDEX2, TERM0) | lte(TERM1, TERM0)))))
---------------------------
(original clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i1) = t2) | ~committed(i2, t1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER0 . (exists INDEX0 . (forall TERM1, INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~committed(INDEX2, TERM0) | lte(TERM1, TERM0)))))
---------------------------
(clause-type: epr)	(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
@    58s  is global clause? No
@    58s  Learning in F[4]: (forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
@    58s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    59s  F[3] /\ T /\ C+ ?
@    59s  	Ans. UNSAT
@    59s  F[4] unsat core #5 	(ucsz: 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i0)
	(log(s1, i0) = t2)
	committed(i2, t1)
	(currentTerm(s1) = t1)
	(log(s1, i2) = t1)
(clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s1) = i0) | ~committed(i2, t1))
(relations)
	loglen
	log
	committed
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX1) = TERM0)
(antecedent reduction)
@    59s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map: post)
	TERM1 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	committed(INDEX1, currentTerm(SERVER0))
	(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	~(currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))
(qvars eq: post)
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s1) = i0) | ~committed(i2, t1))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall I1, S0 . ((committed(I1, currentTerm(S0)) & (log(S0, I1) = currentTerm(S0))) -> (currentTerm(S0) = log(S0, loglen(S0)))))
@    59s  is global clause? No
@    59s  Learning in F[4]: (forall I1, S0 . ((committed(I1, currentTerm(S0)) & (log(S0, I1) = currentTerm(S0))) -> (currentTerm(S0) = log(S0, loglen(S0)))))
@    59s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    59s  F[3] /\ T /\ C+ ?
@    59s  	Ans. UNSAT
@    59s  F[4] unsat core #5 	(ucsz: 13 -> 11 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i0) = t0)
	(loglen(s1) = i0)
	~leader(s0)
	lte(t1, t2)
	committed(i1, t1)
(clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i0) | ~committed(i1, t1) | ~lte(t1, t2) | leader(s0))
(relations)
	loglen
	log
	committed
	lte
	leader
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	~leader(SERVER0)
	lte(TERM1, TERM2)
	(log(SERVER1, INDEX0) = TERM0)
	committed(INDEX1, TERM1)
(antecedent reduction)
@    60s  antecedent: 7 -> 7

qv2cubes #3
	TERM1 -> [ lte(TERM1, TERM2), committed(INDEX1, TERM1), ]
	TERM2 -> [ lte(TERM1, TERM2), ]
	TERM0 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	TERM1 -> [ committed(INDEX1, V:term:e6:), lte(V:term:e6:, TERM2), ]
	TERM2 -> [ lte(TERM1, V:term:e6:), ]
	TERM0 -> [ (log(SERVER1, INDEX0) = V:term:e6:), ]
ucubes2qv #3
	lte(TERM1, V:term:e6:) -> [ TERM2, ]
	(committed(INDEX1, V:term:e6:) & lte(V:term:e6:, TERM2)) -> [ TERM1, ]
	(log(SERVER1, INDEX0) = V:term:e6:) -> [ TERM0, ]
(partition) #3 term:e6: -> { TERM2, | TERM1, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e6:), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX0) = TERM0), (loglen(V:server:e6:) = INDEX0), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX0) = TERM0) & (loglen(V:server:e6:) = INDEX0)) -> [ SERVER1, ]
	~leader(V:server:e6:) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
	TERM0 -> log(SERVER1, loglen(SERVER1))
(cube eq: post)
	~(log(SERVER1, loglen(SERVER1)) = TERM2)
	~(loglen(SERVER1) = INDEX1)
	~(TERM1 = TERM2)
	committed(INDEX1, TERM1)
	~(SERVER0 = SERVER1)
	lte(TERM1, TERM2)
	~leader(SERVER0)
	~(log(SERVER1, loglen(SERVER1)) = TERM1)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	TERM1
	TERM2
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM1, TERM2 . ((log(SERVER1, loglen(SERVER1)) = TERM2) | (loglen(SERVER1) = INDEX1) | (TERM1 = TERM2) | ~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | ~lte(TERM1, TERM2) | leader(SERVER0) | (log(SERVER1, loglen(SERVER1)) = TERM1)))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i0) | ~committed(i1, t1) | ~lte(t1, t2) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM1, TERM2 . ((log(SERVER1, loglen(SERVER1)) = TERM2) | (loglen(SERVER1) = INDEX1) | (TERM1 = TERM2) | ~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | ~lte(TERM1, TERM2) | leader(SERVER0) | (log(SERVER1, loglen(SERVER1)) = TERM1)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
@    60s  is global clause? No
@    60s  Learning in F[4]: (forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
@    60s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    60s  F[3] /\ T /\ C+ ?
@    60s  	Ans. UNSAT
@    60s  F[4] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 6 -> 5 -> 5)
(minimal unsat core)
	(termzero = t0)
	(currentTerm(s1) = t2)
	(currentTerm(s0) = t2)
	committed(i2, t1)
	(log(s0, i0) = t1)
(clause)
	(~(currentTerm(s0) = t2) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t1) | ~(termzero = t0) | ~committed(i2, t1))
(relations)
	log
	termzero
	committed
	currentTerm
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(termzero = TERM0)
	(currentTerm(SERVER1) = TERM2)
	committed(INDEX1, TERM1)
	(currentTerm(SERVER0) = TERM2)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@    61s  antecedent: 7 -> 5 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER1) = TERM2)
	committed(INDEX1, TERM1)
	(currentTerm(SERVER0) = TERM2)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
	TERM1
	TERM2
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), committed(INDEX1, TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e6:), committed(INDEX1, V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e6:), (currentTerm(SERVER0) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	((log(SERVER0, INDEX0) = V:term:e6:) & committed(INDEX1, V:term:e6:)) -> [ TERM1, ]
	((currentTerm(SERVER0) = V:term:e6:) & (currentTerm(SERVER1) = V:term:e6:)) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), (currentTerm(SERVER0) = TERM2), ]
	SERVER1 -> [ (currentTerm(SERVER1) = TERM2), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM1), (currentTerm(V:server:e6:) = TERM2), ]
	SERVER1 -> [ (currentTerm(V:server:e6:) = TERM2), ]
ucubes2qv #2
	(currentTerm(V:server:e6:) = TERM2) -> [ SERVER1, ]
	((currentTerm(V:server:e6:) = TERM2) & (log(V:server:e6:, INDEX0) = TERM1)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = currentTerm(SERVER0))
	committed(INDEX1, log(SERVER0, INDEX0))
	~(SERVER0 = SERVER1)
	~(termzero = log(SERVER0, INDEX0))
	(currentTerm(SERVER1) = currentTerm(SERVER0))
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = currentTerm(SERVER0)) | ~committed(INDEX1, log(SERVER0, INDEX0)) | (SERVER0 = SERVER1) | (termzero = log(SERVER0, INDEX0)) | ~(currentTerm(SERVER1) = currentTerm(SERVER0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t1) | ~(termzero = t0) | ~committed(i2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = currentTerm(SERVER0)) | ~committed(INDEX1, log(SERVER0, INDEX0)) | (SERVER0 = SERVER1) | (termzero = log(SERVER0, INDEX0)) | ~(currentTerm(SERVER1) = currentTerm(SERVER0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, I1 . ((committed(I1, log(S0, I0)) & (currentTerm(S1) = currentTerm(S0))) -> ((log(S0, I0) = currentTerm(S0)) | (S0 = S1) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0)))))
@    61s  is global clause? No
@    61s  Learning in F[4]: (forall S0, S1, I0, I1 . ((committed(I1, log(S0, I0)) & (currentTerm(S1) = currentTerm(S0))) -> ((log(S0, I0) = currentTerm(S0)) | (S0 = S1) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0)))))
@    61s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e7 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e2:e5 -> s0
		V__fml:nextInd:e1:e2:e5 -> i0
@    61s  F[3] /\ T /\ C+ ?
@    61s  	Ans. UNSAT
@    61s  F[4] unsat core #4 	(ucsz: 13 -> 11 -> 9 -> 8 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	~member(s1, q0)
	(currentTerm(s0) = t2)
	committed(i2, t1)
	(termzero = t0)
(clause)
	(~(currentTerm(s0) = t2) | ~(termzero = t0) | ~committed(i2, t1) | member(s1, q0))
(relations)
	termzero
	committed
	currentTerm
	member
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(termzero = TERM0)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
	(currentTerm(SERVER0) = TERM2)
(antecedent reduction)
@    61s  antecedent: 5 -> 5

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
	(currentTerm(SERVER0) = TERM2)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	TERM1
	TERM2
	QUORUM0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM1 -> [ committed(INDEX0, TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ committed(INDEX0, V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	committed(INDEX0, V:term:e6:) -> [ TERM1, ]
	(currentTerm(SERVER0) = V:term:e6:) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM2), ]
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
qv2ucubes #2
	SERVER0 -> [ (currentTerm(V:server:e6:) = TERM2), ]
	SERVER1 -> [ ~member(V:server:e6:, QUORUM0), ]
ucubes2qv #2
	~member(V:server:e6:, QUORUM0) -> [ SERVER1, ]
	(currentTerm(V:server:e6:) = TERM2) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(TERM1 = currentTerm(SERVER0))
	~(termzero = TERM1)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
	~(SERVER0 = SERVER1)
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	TERM1
	QUORUM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM1, QUORUM0 . ((TERM1 = currentTerm(SERVER0)) | (termzero = TERM1) | ~committed(INDEX0, TERM1) | member(SERVER1, QUORUM0) | (SERVER0 = SERVER1) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(termzero = t0) | ~committed(i2, t1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM1, QUORUM0 . ((TERM1 = currentTerm(SERVER0)) | (termzero = TERM1) | ~committed(INDEX0, TERM1) | member(SERVER1, QUORUM0) | (SERVER0 = SERVER1) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
@    61s  is global clause? No
@    61s  Learning in F[4]: (forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
@    62s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    62s  F[3] /\ T /\ C+ ?
@    62s  	Ans. UNSAT
@    62s  F[4] unsat core #4 	(ucsz: 9 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i2) = t2)
	committed(i1, t2)
	(loglen(s1) = i0)
	~leader(s0)
(clause)
	(~(log(s1, i2) = t2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0))
(relations)
	loglen
	log
	committed
	leader
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM0)
	(log(SERVER1, INDEX2) = TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    62s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (log(SERVER1, INDEX2) = TERM0), ]
qv2ucubes #3
	INDEX0 -> [ (loglen(SERVER1) = V:index:e6:), ]
	INDEX1 -> [ committed(V:index:e6:, TERM0), ]
	INDEX2 -> [ (log(SERVER1, V:index:e6:) = TERM0), ]
ucubes2qv #3
	committed(V:index:e6:, TERM0) -> [ INDEX1, ]
	(log(SERVER1, V:index:e6:) = TERM0) -> [ INDEX2, ]
	(loglen(SERVER1) = V:index:e6:) -> [ INDEX0, ]
(partition) #3 index:e6: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (log(SERVER1, INDEX2) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e6:), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX2) = TERM0), (loglen(V:server:e6:) = INDEX0), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX2) = TERM0) & (loglen(V:server:e6:) = INDEX0)) -> [ SERVER1, ]
	~leader(V:server:e6:) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
	TERM0 -> log(SERVER1, INDEX2)
(cube eq: post)
	~leader(SERVER0)
	committed(INDEX1, log(SERVER1, INDEX2))
	~(loglen(SERVER1) = INDEX1)
	~(INDEX1 = INDEX2)
	~(loglen(SERVER1) = INDEX2)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	INDEX2
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, INDEX2 . (leader(SERVER0) | ~committed(INDEX1, log(SERVER1, INDEX2)) | (loglen(SERVER1) = INDEX1) | (INDEX1 = INDEX2) | (loglen(SERVER1) = INDEX2)))
---------------------------
(original clause)
	(~(log(s1, i2) = t2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, INDEX2 . (leader(SERVER0) | ~committed(INDEX1, log(SERVER1, INDEX2)) | (loglen(SERVER1) = INDEX1) | (INDEX1 = INDEX2) | (loglen(SERVER1) = INDEX2)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
@    62s  is global clause? No
@    62s  Learning in F[4]: (forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
@    62s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    62s  F[3] /\ T /\ C+ ?
@    62s  	Ans. UNSAT
@    63s  F[4] unsat core #5 	(ucsz: 11 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i1, t2)
	(loglen(s1) = i0)
	~leader(s0)
	~succ(i1, i0)
	~member(s0, q1)
(clause)
	(~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0) | member(s0, q1) | succ(i1, i0))
(relations)
	loglen
	succ
	committed
	leader
	member
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM0)
	~succ(INDEX1, INDEX0)
	~member(SERVER0, QUORUM0)
	~leader(SERVER0)
(antecedent reduction)
@    63s  antecedent: 4 -> 4

qv2cubes #2
	SERVER0 -> [ ~member(SERVER0, QUORUM0), ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ ~member(V:server:e6:, QUORUM0), ~leader(V:server:e6:), ]
	SERVER1 -> [ (loglen(V:server:e6:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e6:) = INDEX0) -> [ SERVER1, ]
	(~leader(V:server:e6:) & ~member(V:server:e6:, QUORUM0)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(loglen(SERVER1) = INDEX1)
	~(SERVER0 = SERVER1)
	~succ(INDEX1, loglen(SERVER1))
	~member(SERVER0, QUORUM0)
	committed(INDEX1, TERM0)
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	QUORUM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0, QUORUM0 . ((loglen(SERVER1) = INDEX1) | (SERVER0 = SERVER1) | succ(INDEX1, loglen(SERVER1)) | member(SERVER0, QUORUM0) | ~committed(INDEX1, TERM0) | leader(SERVER0)))
---------------------------
(original clause)
	(~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0) | member(s0, q1) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0, QUORUM0 . ((loglen(SERVER1) = INDEX1) | (SERVER0 = SERVER1) | succ(INDEX1, loglen(SERVER1)) | member(SERVER0, QUORUM0) | ~committed(INDEX1, TERM0) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
@    63s  is global clause? No
@    63s  Learning in F[4]: (forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
@    63s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    63s  F[3] /\ T /\ C+ ?
@    63s  	Ans. UNSAT
@    64s  F[4] unsat core #4 	(ucsz: 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	~lte(t2, t1)
	(log(s1, i0) = t2)
	~leader(s1)
	committed(i1, t1)
(clause)
	(~(log(s1, i0) = t2) | ~committed(i1, t1) | leader(s1) | lte(t2, t1))
(relations)
	log
	lte
	committed
	leader
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX1, TERM0)
	~lte(TERM1, TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    64s  antecedent: 4 -> 0 (reduced)
	removed: TERM0
	removed: INDEX1
	removed: TERM1
	removed: INDEX0

(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX1, TERM0)
	~lte(log(SERVER0, INDEX0), TERM0)
	~leader(SERVER0)
(qvars eq: post)
	INDEX0
	INDEX1
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX0, INDEX1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | lte(log(SERVER0, INDEX0), TERM0) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s1, i0) = t2) | ~committed(i1, t1) | leader(s1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall INDEX0, INDEX1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | lte(log(SERVER0, INDEX0), TERM0) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, I1, T0, S0 . (committed(I1, T0) -> (lte(log(S0, I0), T0) | leader(S0))))
@    64s  is global clause? No
@    64s  Learning in F[4]: (forall I0, I1, T0, S0 . (committed(I1, T0) -> (lte(log(S0, I0), T0) | leader(S0))))
@    64s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    64s  F[3] /\ T /\ C+ ?
@    64s  	Ans. UNSAT
@    64s  F[4] unsat core #4 	(ucsz: 9 -> 4 -> 4)
(minimal unsat core)
	(termzero = t0)
	~leader(s0)
	(log(s0, i0) = t1)
	committed(i1, t1)
(clause)
	(~(log(s0, i0) = t1) | ~(termzero = t0) | ~committed(i1, t1) | leader(s0))
(relations)
	log
	termzero
	committed
	leader
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
	committed(INDEX1, TERM1)
(antecedent reduction)
@    64s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	~leader(SERVER0)
	committed(INDEX1, TERM1)
(qvars eq)
	TERM1
	INDEX0
	INDEX1
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX1, log(SERVER0, INDEX0))
	~(termzero = log(SERVER0, INDEX0))
	~leader(SERVER0)
(qvars eq: post)
	INDEX0
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX0, INDEX1, SERVER0 . (~committed(INDEX1, log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(termzero = t0) | ~committed(i1, t1) | leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, INDEX1, SERVER0 . (~committed(INDEX1, log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, I1, S0 . (committed(I1, log(S0, I0)) -> ((termzero = log(S0, I0)) | leader(S0))))
@    64s  is global clause? No
@    64s  Learning in F[4]: (forall I0, I1, S0 . (committed(I1, log(S0, I0)) -> ((termzero = log(S0, I0)) | leader(S0))))
@    64s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    64s  F[3] /\ T /\ C+ ?
@    64s  	Ans. UNSAT
@    65s  F[4] unsat core #5 	(ucsz: 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~leader(s0)
	committed(i1, t2)
	(loglen(s1) = i0)
	(log(s1, i0) = t2)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s1, i0) = t2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0))
(relations)
	indzero
	log
	committed
	leader
	loglen
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM0)
	~leader(SERVER0)
	(log(SERVER1, INDEX0) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    65s  antecedent: 4 -> 0 (reduced)
	removed: INDEX0
	removed: SERVER1
	removed: INDEX1
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = indzero)
	(log(SERVER1, indzero) = TERM0)
	~leader(SERVER0)
(qvars eq)
	SERVER0
	INDEX1
	SERVER1
	TERM0
(antecedent eq)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = indzero), (log(SERVER1, indzero) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e6:), ]
	SERVER1 -> [ (log(V:server:e6:, indzero) = TERM0), (loglen(V:server:e6:) = indzero), ]
ucubes2qv #2
	((log(V:server:e6:, indzero) = TERM0) & (loglen(V:server:e6:) = indzero)) -> [ SERVER1, ]
	~leader(V:server:e6:) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER1, indzero)
(cube eq: post)
	(loglen(SERVER1) = indzero)
	committed(INDEX1, log(SERVER1, indzero))
	~leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX1
	SERVER1
(boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, log(SERVER1, indzero)) | leader(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i0) = t2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, log(SERVER1, indzero)) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
@    65s  is global clause? No
@    65s  Learning in F[4]: (forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
@    65s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    65s  F[3] /\ T /\ C+ ?
@    65s  	Ans. UNSAT
@    65s  F[4] unsat core #5 	(ucsz: 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i1, t2)
	(loglen(s1) = i0)
	~leader(s0)
	(indzero = i0)
	~lte(t1, t2)
(clause)
	(~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0) | lte(t1, t2))
(relations)
	indzero
	lte
	committed
	leader
	loglen
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM1)
	~lte(TERM0, TERM1)
	~leader(SERVER0)
	(indzero = INDEX0)
(antecedent reduction)
@    66s  antecedent: 6 -> 2 (reduced)
	removed: TERM0
	removed: INDEX0
	removed: INDEX1
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM1)
	(loglen(SERVER1) = indzero)
	~lte(TERM0, TERM1)
	~leader(SERVER0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ ~leader(SERVER0), ]
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
qv2ucubes #2
	SERVER0 -> [ ~leader(V:server:e6:), ]
	SERVER1 -> [ (loglen(V:server:e6:) = indzero), ]
ucubes2qv #2
	(loglen(V:server:e6:) = indzero) -> [ SERVER1, ]
	~leader(V:server:e6:) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0, TERM1 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | leader(SERVER0) | lte(TERM0, TERM1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i1, t2) | leader(s0) | lte(t1, t2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0, TERM1 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | leader(SERVER0) | lte(TERM0, TERM1)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
@    66s  is global clause? No
@    66s  Learning in F[4]: (forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
@    66s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    66s  F[3] /\ T /\ C+ ?
@    66s  	Ans. UNSAT
@    67s  F[4] unsat core #5 	(ucsz: 10 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(log(s0, i0) = t1)
	(indzero = i0)
	committed(i1, t1)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(relations)
	indzero
	log
	committed
	loglen
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(indzero = INDEX0)
(antecedent reduction)
@    67s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = indzero)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	SERVER0
	INDEX1
	SERVER1
	TERM0
(antecedent eq)
	server:e6:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = indzero), (log(SERVER0, indzero) = TERM0), ]
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM0), (loglen(V:server:e6:) = indzero), ]
	SERVER1 -> [ (loglen(V:server:e6:) = indzero), ]
ucubes2qv #2
	((log(V:server:e6:, indzero) = TERM0) & (loglen(V:server:e6:) = indzero)) -> [ SERVER0, ]
	(loglen(V:server:e6:) = indzero) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	committed(INDEX1, log(SERVER0, indzero))
	~(SERVER0 = SERVER1)
	(loglen(SERVER1) = indzero)
	(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
	INDEX1
	SERVER1
(boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, log(SERVER0, indzero)) | (SERVER0 = SERVER1) | ~(loglen(SERVER1) = indzero) | ~(loglen(SERVER0) = indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, log(SERVER0, indzero)) | (SERVER0 = SERVER1) | ~(loglen(SERVER1) = indzero) | ~(loglen(SERVER0) = indzero)))
---------------------------
(clause-type: univ)	(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    67s  is global clause? Yes
@    67s  Learning in F[4]: (forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    67s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    67s  F[3] /\ T /\ C+ ?
@    67s  	Ans. UNSAT
@    67s  F[4] unsat core #4 	(ucsz: 12 -> 9 -> 8 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i2, t0)
	(log(s0, i2) = t2)
	(log(s0, i0) = t2)
	~lte(t2, t0)
(clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~committed(i2, t0) | lte(t2, t0))
(relations)
	log
	lte
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX1, TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	~lte(TERM1, TERM0)
(antecedent reduction)
@    68s  antecedent: 4 -> 2 (reduced)
	removed: TERM0
	removed: TERM1

(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	(log(SERVER0, INDEX1) = log(SERVER0, INDEX0))
	committed(INDEX1, TERM0)
	~lte(log(SERVER0, INDEX0), TERM0)
(qvars eq: post)
	INDEX0
	INDEX1
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX0, INDEX1, TERM0, SERVER0 . ((INDEX0 = INDEX1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | ~committed(INDEX1, TERM0) | lte(log(SERVER0, INDEX0), TERM0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t2) | ~(log(s0, i2) = t2) | ~committed(i2, t0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall INDEX0, INDEX1, TERM0, SERVER0 . ((INDEX0 = INDEX1) | ~(log(SERVER0, INDEX1) = log(SERVER0, INDEX0)) | ~committed(INDEX1, TERM0) | lte(log(SERVER0, INDEX0), TERM0)))
---------------------------
(clause-type: univ)	(forall I0, I1, T0, S0 . (((log(S0, I1) = log(S0, I0)) & committed(I1, T0)) -> ((I0 = I1) | lte(log(S0, I0), T0))))
@    68s  is global clause? No
@    68s  Learning in F[4]: (forall I0, I1, T0, S0 . (((log(S0, I1) = log(S0, I0)) & committed(I1, T0)) -> ((I0 = I1) | lte(log(S0, I0), T0))))
@    68s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    68s  F[3] /\ T /\ C+ ?
@    68s  	Ans. UNSAT
@    68s  F[4] unsat core #7 	(ucsz: 14 -> 12 -> 11 -> 10 -> 8 -> 7 -> 7)
(minimal unsat core)
	leader(s0)
	leader(s1)
	(log(s1, i1) = t0)
	committed(i1, t1)
	(currentTerm(s1) = t1)
	(loglen(s0) = i0)
	(log(s0, i0) = t0)
(clause)
	(~(currentTerm(s1) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t1) | ~leader(s0) | ~leader(s1))
(relations)
	loglen
	log
	committed
	leader
	currentTerm
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM1)
	(log(SERVER1, INDEX1) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	leader(SERVER1)
	leader(SERVER0)
(antecedent reduction)
@    69s  antecedent: 6 -> 4 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #2
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), leader(SERVER0), ]
	SERVER1 -> [ leader(SERVER1), (log(SERVER1, INDEX1) = TERM0), (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, INDEX0) = TERM0), (loglen(V:server:e6:) = INDEX0), leader(V:server:e6:), ]
	SERVER1 -> [ leader(V:server:e6:), (log(V:server:e6:, INDEX1) = TERM0), (currentTerm(V:server:e6:) = TERM1), ]
ucubes2qv #2
	((currentTerm(V:server:e6:) = TERM1) & (log(V:server:e6:, INDEX1) = TERM0) & leader(V:server:e6:)) -> [ SERVER1, ]
	((log(V:server:e6:, INDEX0) = TERM0) & (loglen(V:server:e6:) = INDEX0) & leader(V:server:e6:)) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER1)
	INDEX0 -> loglen(SERVER0)
	TERM0 -> log(SERVER1, INDEX1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(log(SERVER1, INDEX1) = currentTerm(SERVER1))
	committed(INDEX1, currentTerm(SERVER1))
	(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1))
	leader(SERVER1)
	leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . ((SERVER0 = SERVER1) | (log(SERVER1, INDEX1) = currentTerm(SERVER1)) | ~committed(INDEX1, currentTerm(SERVER1)) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1)) | ~leader(SERVER1) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t1) | ~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . ((SERVER0 = SERVER1) | (log(SERVER1, INDEX1) = currentTerm(SERVER1)) | ~committed(INDEX1, currentTerm(SERVER1)) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1)) | ~leader(SERVER1) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@    69s  is global clause? No
@    69s  Learning in F[4]: (forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@    69s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    69s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e7 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e2:e5 -> s0
		V__fml:q:e1:e2:e5 -> q0
@    69s  	Ans. SAT
@    69s  F[2] /\ T /\ C+ ?
@    69s  	Ans. UNSAT
@    70s  F[3] unsat core #3 	(ucsz: 11 -> 9 -> 7 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i1) = t2)
	(termzero = t0)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(relations)
	termzero
	log
	currentTerm
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM0)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
(antecedent reduction)
@    70s  antecedent: 3 -> 3

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
(qvars eq)
	TERM1
	INDEX0
	TERM2
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(currentTerm(SERVER0) = V:term:e6:) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e6:) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER0)
	TERM2 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER0, INDEX0))
	~(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . ((termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . ((termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@    70s  is global clause? No
@    70s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@    70s  F[3] /\ T /\ C+ ?
@    70s  	Ans. UNSAT
@    70s  F[4] unsat core #3 	(ucsz: 16 -> 15 -> 10 -> 8 -> 8 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i1) = t2)
	(termzero = t0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(relations)
	termzero
	log
(fullsorts)
	term:e6: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER0, INDEX1) = TERM2)
(antecedent reduction)
@    70s  antecedent: 5 -> 3 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER0, INDEX1) = TERM2)
(qvars eq)
	SERVER0
	INDEX0
	INDEX1
	TERM1
	TERM2
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e6: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX1) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e6:), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX1) = V:term:e6:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e6:) -> [ TERM1, ]
	(log(SERVER0, INDEX1) = V:term:e6:) -> [ TERM2, ]
(partition) #3 term:e6: -> { termzero, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
	TERM2 -> log(SERVER0, INDEX1)
(cube eq: post)
	~(log(SERVER0, INDEX0) = log(SERVER0, INDEX1))
	~(termzero = log(SERVER0, INDEX0))
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (termzero = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (termzero = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
@    71s  is global clause? No
@    71s  Learning in F[4]: (forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
@    71s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    71s  F[3] /\ T /\ C+ ?
@    71s  	Ans. UNSAT
@    71s  F[4] unsat core #5 	(ucsz: 12 -> 11 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i2)
	(log(s0, i0) = t1)
	(indzero = i0)
	committed(i1, t1)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t1))
(relations)
	indzero
	log
	committed
	loglen
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX2)
	(indzero = INDEX0)
(antecedent reduction)
@    72s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, indzero) = TERM0)
	(loglen(SERVER1) = INDEX2)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX2
	TERM0
(antecedent eq)
	index:e6:
	-> ~(indzero = INDEX1)
	-> ~(indzero = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	index:e6: -> [ indzero, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	indzero -> [ (loglen(SERVER0) = indzero), (log(SERVER0, indzero) = TERM0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
qv2ucubes #3
	indzero -> [ (log(SERVER0, V:index:e6:) = TERM0), (loglen(SERVER0) = V:index:e6:), ]
	INDEX1 -> [ committed(V:index:e6:, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = V:index:e6:), ]
ucubes2qv #3
	committed(V:index:e6:, TERM0) -> [ INDEX1, ]
	((log(SERVER0, V:index:e6:) = TERM0) & (loglen(SERVER0) = V:index:e6:)) -> [ indzero, ]
	(loglen(SERVER1) = V:index:e6:) -> [ INDEX2, ]
(partition) #3 index:e6: -> { INDEX1, | indzero, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = indzero), (log(SERVER0, indzero) = TERM0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX2), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM0), (loglen(V:server:e6:) = indzero), ]
	SERVER1 -> [ (loglen(V:server:e6:) = INDEX2), ]
ucubes2qv #2
	((log(V:server:e6:, indzero) = TERM0) & (loglen(V:server:e6:) = indzero)) -> [ SERVER0, ]
	(loglen(V:server:e6:) = INDEX2) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	committed(INDEX1, log(SERVER0, indzero))
	~(INDEX1 = loglen(SERVER1))
	(loglen(SERVER0) = indzero)
	~(indzero = INDEX1)
	~(indzero = loglen(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~committed(INDEX1, log(SERVER0, indzero)) | (INDEX1 = loglen(SERVER1)) | ~(loglen(SERVER0) = indzero) | (indzero = INDEX1) | (indzero = loglen(SERVER1))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~committed(INDEX1, log(SERVER0, indzero)) | (INDEX1 = loglen(SERVER1)) | ~(loglen(SERVER0) = indzero) | (indzero = INDEX1) | (indzero = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
@    72s  is global clause? No
@    72s  Learning in F[4]: (forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
@    72s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    72s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e7 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e2:e5 -> s0
		V__fml:q:e1:e2:e5 -> q0
@    72s  	Ans. SAT
@    72s  F[2] /\ T /\ C+ ?
@    72s  	Ans. UNSAT
@    73s  F[3] unsat core #3 	(ucsz: 12 -> 9 -> 8 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i0) = t0)
	(log(s0, i0) = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0))
(relations)
	indzero
	log
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER1, INDEX0) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    73s  antecedent: 4 -> 2 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER1, indzero) = TERM0)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	TERM1
	SERVER1
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = TERM1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, indzero) = TERM1), ]
	SERVER1 -> [ (log(SERVER1, indzero) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM1), ]
	SERVER1 -> [ (log(V:server:e6:, indzero) = TERM0), ]
ucubes2qv #2
	(log(V:server:e6:, indzero) = TERM0) -> [ SERVER1, ]
	(log(V:server:e6:, indzero) = TERM1) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, indzero)
	TERM0 -> log(SERVER1, indzero)
(cube eq: post)
	~(log(SERVER1, indzero) = log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (log(SERVER1, indzero) = log(SERVER0, indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (log(SERVER1, indzero) = log(SERVER0, indzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    73s  is global clause? Yes
@    73s  Learning in F[4]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    73s  F[3] /\ T /\ C+ ?
@    73s  	Ans. UNSAT
@    74s  F[4] unsat core #3 	(ucsz: 9 -> 7 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i0) = t0)
	(log(s0, i0) = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0))
(relations)
	indzero
	log
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER1, INDEX0) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    74s  antecedent: 4 -> 2 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER1, indzero) = TERM0)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	TERM1
	SERVER1
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = TERM1)
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (log(SERVER0, indzero) = TERM1), ]
	SERVER1 -> [ (log(SERVER1, indzero) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e6:, indzero) = TERM1), ]
	SERVER1 -> [ (log(V:server:e6:, indzero) = TERM0), ]
ucubes2qv #2
	(log(V:server:e6:, indzero) = TERM0) -> [ SERVER1, ]
	(log(V:server:e6:, indzero) = TERM1) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, indzero)
	TERM0 -> log(SERVER1, indzero)
(cube eq: post)
	~(log(SERVER1, indzero) = log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (log(SERVER1, indzero) = log(SERVER0, indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (log(SERVER1, indzero) = log(SERVER0, indzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    74s  is global clause? Yes
@    74s  Learning in F[4]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    74s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    74s  F[3] /\ T /\ C+ ?
@    74s  	Ans. UNSAT
@    74s  F[4] unsat core #3 	(ucsz: 9 -> 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	~lte(t2, t0)
	(log(s0, i0) = t2)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i0) = t2) | lte(t2, t0))
(relations)
	lte
	log
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER0) = TERM0)
(antecedent reduction)
@    74s  antecedent: 2 -> 0 (reduced)
	removed: TERM0
	removed: TERM1

(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	~lte(log(SERVER0, INDEX0), currentTerm(SERVER0))
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . lte(log(SERVER0, INDEX0), currentTerm(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i0) = t2) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . lte(log(SERVER0, INDEX0), currentTerm(SERVER0)))
---------------------------
(clause-type: univ)	(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    74s  is global clause? Yes
@    74s  Learning in F[4]: (forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    74s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    75s  F[3] /\ T /\ C+ ?
@    75s  	Ans. UNSAT
@    75s  F[4] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i1, t2)
	(termzero = t0)
	(log(s1, i0) = t2)
	~succ(i0, i1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s1, i0) = t2) | ~(termzero = t0) | ~committed(i1, t2) | succ(i0, i1))
(relations)
	indzero
	termzero
	succ
	log
	committed
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	committed(INDEX1, TERM1)
	~succ(INDEX0, INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    75s  antecedent: 4 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	INDEX0 -> indzero
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, TERM1)
	~succ(indzero, INDEX1)
	(log(SERVER0, indzero) = TERM1)
(qvars eq)
	TERM1
	INDEX1
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(termzero = TERM1)
(eq map: post)
	TERM1 -> log(SERVER0, indzero)
(cube eq: post)
	~(termzero = log(SERVER0, indzero))
	~succ(indzero, INDEX1)
	committed(INDEX1, log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . ((termzero = log(SERVER0, indzero)) | succ(indzero, INDEX1) | ~committed(INDEX1, log(SERVER0, indzero))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i0) = t2) | ~(termzero = t0) | ~committed(i1, t2) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . ((termzero = log(SERVER0, indzero)) | succ(indzero, INDEX1) | ~committed(INDEX1, log(SERVER0, indzero))))
---------------------------
(clause-type: univ)	(forall S0, I1 . (committed(I1, log(S0, indzero)) -> ((termzero = log(S0, indzero)) | succ(indzero, I1))))
@    75s  is global clause? No
@    75s  Learning in F[4]: (forall S0, I1 . (committed(I1, log(S0, indzero)) -> ((termzero = log(S0, indzero)) | succ(indzero, I1))))
@    75s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    75s  F[3] /\ T /\ C+ ?
@    75s  	Ans. UNSAT
@    75s  F[4] unsat core #6 	(ucsz: 16 -> 13 -> 9 -> 9 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s1) = i2)
	(log(s0, i2) = t0)
	committed(i2, t1)
	member(s0, q0)
	member(s0, q1)
	(log(s1, i0) = t1)
(clause)
	(~(log(s0, i2) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i2) | ~committed(i2, t1) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	loglen
	log
	committed
	member
(fullsorts)
	server:e6: -> [ SERVER0, SERVER1, ]
	quorum:e6: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX1, TERM1)
	(log(SERVER1, INDEX0) = TERM1)
	member(SERVER0, QUORUM0)
	member(SERVER0, QUORUM1)
	(log(SERVER0, INDEX1) = TERM0)
(antecedent reduction)
@    76s  antecedent: 8 -> 6 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ member(SERVER0, QUORUM0), member(SERVER0, QUORUM1), (log(SERVER0, INDEX1) = TERM0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ member(V:server:e6:, QUORUM0), member(V:server:e6:, QUORUM1), (log(V:server:e6:, INDEX1) = TERM0), ]
	SERVER1 -> [ (log(V:server:e6:, INDEX0) = TERM1), (loglen(V:server:e6:) = INDEX1), ]
ucubes2qv #2
	((log(V:server:e6:, INDEX1) = TERM0) & member(V:server:e6:, QUORUM0) & member(V:server:e6:, QUORUM1)) -> [ SERVER0, ]
	((log(V:server:e6:, INDEX0) = TERM1) & (loglen(V:server:e6:) = INDEX1)) -> [ SERVER1, ]
(partition) #2 server:e6: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER0, V:quorum:e6:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e6:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e6:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e6: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX1, TERM0, TERM1 . (~(log(SERVER0, INDEX1) = TERM0) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM1) | ~member(SERVER0, QUORUM0) | (INDEX0 = INDEX1) | (TERM0 = TERM1))))
(non-epr version)
	(forall SERVER0, SERVER1, INDEX0, INDEX1, TERM0, TERM1 . (exists QUORUM0 . (~(log(SERVER0, INDEX1) = TERM0) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM1) | ~member(SERVER0, QUORUM0) | (INDEX0 = INDEX1) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX1, TERM0, TERM1 . (~(log(SERVER0, INDEX1) = TERM0) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM1) | ~member(SERVER0, QUORUM0) | (INDEX0 = INDEX1) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(log(s0, i2) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i2) | ~committed(i2, t1) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX1, TERM0, TERM1 . (~(log(SERVER0, INDEX1) = TERM0) | ~(log(SERVER1, INDEX0) = TERM1) | ~(loglen(SERVER1) = INDEX1) | ~committed(INDEX1, TERM1) | ~member(SERVER0, QUORUM0) | (INDEX0 = INDEX1) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S0, S1, I0, I1, T0, T1 . (((log(S0, I1) = T0) & (log(S1, I0) = T1) & (loglen(S1) = I1) & committed(I1, T1) & member(S0, Q0)) -> ((I0 = I1) | (T0 = T1)))))
@    76s  is global clause? No
@    76s  Learning in F[4]: (exists Q0 . (forall S0, S1, I0, I1, T0, T1 . (((log(S0, I1) = T0) & (log(S1, I0) = T1) & (loglen(S1) = I1) & committed(I1, T1) & member(S0, Q0)) -> ((I0 = I1) | (T0 = T1)))))
@    76s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    76s  F[3] /\ T /\ C+ ?
@    76s  	Ans. UNSAT
@    77s  F[4] unsat core #4 	(ucsz: 14 -> 13 -> 12 -> 11 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i0) = t0)
	committed(i2, t0)
	leader(s0)
	(log(s1, i1) = t0)
(clause)
	(~(log(s1, i0) = t0) | ~(log(s1, i1) = t0) | ~committed(i2, t0) | ~leader(s0))
(relations)
	log
	committed
	leader
(fullsorts)
	index:e6: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e6: -> [ SERVER0, SERVER1, ]
(cube: std)
	leader(SERVER0)
	(log(SERVER1, INDEX1) = TERM0)
	committed(INDEX2, TERM0)
	(log(SERVER1, INDEX0) = TERM0)
(antecedent reduction)
@    77s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM0), ]
	INDEX1 -> [ (log(SERVER1, INDEX1) = TERM0), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ]
qv2ucubes #3
	INDEX0 -> [ (log(SERVER1, V:index:e6:) = TERM0), ]
	INDEX1 -> [ (log(SERVER1, V:index:e6:) = TERM0), ]
	INDEX2 -> [ committed(V:index:e6:, TERM0), ]
ucubes2qv #2
	committed(V:index:e6:, TERM0) -> [ INDEX2, ]
	(log(SERVER1, V:index:e6:) = TERM0) -> [ INDEX0, INDEX1, ]
(partition) #2 index:e6: -> { INDEX2, | INDEX0, INDEX1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	INDEX2:
		committed(INDEX2, TERM0)
ucmulti:
	(log(SERVER1, INDEX0) = TERM0)
qv2cubes #2
	SERVER0 -> [ leader(SERVER0), ]
	SERVER1 -> [ ((INDEX2 = INDEX0) | (log(SERVER1, INDEX0) = TERM0)), ]
qv2ucubes #2
	SERVER0 -> [ leader(V:server:e6:), ]
	SERVER1 -> [ ((INDEX2 = INDEX0) | (log(V:server:e6:, INDEX0) = TERM0)), ]
ucubes2qv #2
	((INDEX2 = INDEX0) | (log(V:server:e6:, INDEX0) = TERM0)) -> [ SERVER1, ]
	leader(V:server:e6:) -> [ SERVER0, ]
(partition) #2 server:e6: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> index)? False
	(epr check: reverse)	allowed(arc: index -> index)? False
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
(epr reduced)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX0 . (forall INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER1, INDEX0) = TERM0)) | ~committed(INDEX2, TERM0))))))
(non-epr version)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (forall INDEX2, TERM0 . (exists INDEX0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER1, INDEX0) = TERM0)) | ~committed(INDEX2, TERM0))))))
	Both verions not allowed!
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (forall INDEX2, TERM0 . (exists INDEX0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER1, INDEX0) = TERM0)) | ~committed(INDEX2, TERM0))))))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(log(s1, i1) = t0) | ~committed(i2, t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (forall INDEX2, TERM0 . (exists INDEX0 . ((~(INDEX2 = INDEX0) & ~(log(SERVER1, INDEX0) = TERM0)) | ~committed(INDEX2, TERM0))))))
---------------------------
(clause-type: non-epr)	(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
@    77s  is global clause? No
@    78s  Learning in F[4]: (forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
@    78s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e7 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e2:e5 -> s0
		V__fml:newterm:e1:e2:e5 -> t0
		V__fml:q:e1:e2:e5 -> q0
@    78s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e7 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e2:e5 -> s0
		V__fml:q:e1:e2:e5 -> q0
@    78s  	Ans. SAT
@    78s  F[2] /\ T /\ C+ ?
@    78s  	Ans. UNSAT
@    78s  F[3] unsat core #3 	(ucsz: 12 -> 10 -> 5 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i0) = t0)
	(termzero = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(termzero = t1))
(relations)
	indzero
	termzero
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(indzero = INDEX0)
(antecedent reduction)
@    78s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
	INDEX0 -> indzero
(cube eq)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	~(log(SERVER0, indzero) = termzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(clause-type: univ)	(forall S0 . (log(S0, indzero) = termzero))
@    78s  is global clause? Yes
@    78s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@    78s  F[3] /\ T /\ C+ ?
@    78s  	Ans. UNSAT
@    78s  F[4] unsat core #3 	(ucsz: 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i0) = t0)
	(termzero = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(termzero = t1))
(relations)
	indzero
	termzero
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(indzero = INDEX0)
(antecedent reduction)
@    79s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
	INDEX0 -> indzero
(cube eq)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	TERM0
	SERVER0
(antecedent eq)
	term:e6:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	~(log(SERVER0, indzero) = termzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(clause-type: univ)	(forall S0 . (log(S0, indzero) = termzero))
@    79s  is global clause? Yes
@    79s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@    79s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #1
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
	F[2]: #6
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
	F[3]: #13
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
		(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
		(forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
		(forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
		(forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
		(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
		(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
	F[4]: #35
		(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
		(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
		(exists Q0 . (forall S0, S1, I0, I1, T0, T1 . (((log(S0, I1) = T0) & (log(S1, I0) = T1) & (loglen(S1) = I1) & committed(I1, T1) & member(S0, Q0)) -> ((I0 = I1) | (T0 = T1)))))
		(forall S0, I0, S1 . (committed(I0, log(S0, I0)) -> (leader(S1) | (termzero = currentTerm(S0)) | (termzero = log(S0, I0)) | (log(S0, I0) = currentTerm(S0)))))
		(forall T0 . ~committed(indzero, T0))
		(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
		(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, I1, S0 . (committed(I1, log(S0, I0)) -> ((termzero = log(S0, I0)) | leader(S0))))
		(forall S0, I2, T0 . (committed(I2, T0) -> ((indzero = loglen(S0)) | lte(log(S0, loglen(S0)), T0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
		(forall I0, I1, T0, S0 . (committed(I1, T0) -> (lte(log(S0, I0), T0) | leader(S0))))
		(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
		(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
		(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
		(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
		(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
		(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
		(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
		(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
		(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
		(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
		(forall S0, S1, I0, I1 . ((committed(I1, log(S0, I0)) & (currentTerm(S1) = currentTerm(S0))) -> ((log(S0, I0) = currentTerm(S0)) | (S0 = S1) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0)))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I1, S0 . ((committed(I1, currentTerm(S0)) & (log(S0, I1) = currentTerm(S0))) -> (currentTerm(S0) = log(S0, loglen(S0)))))
		(forall S0, I0, I1, T1 . ((log(S0, I1) = log(S0, I0)) -> ((I0 = I1) | (termzero = T1) | lte(log(S0, I0), T1) | leader(S0))))
		(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
		(forall I0, I1, T0, S0 . (((log(S0, I1) = log(S0, I0)) & committed(I1, T0)) -> ((I0 = I1) | lte(log(S0, I0), T0))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    79s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #7 to F[4]
@    80s  Learning in F[4]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@    81s  Learning in F[4]: (forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
@    81s  Learning in F[4]: (forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
@    81s  Learning in F[4]: (forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
@    81s  Learning in F[4]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@    81s  Learning in F[4]: (forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
@    81s  Learning in F[4]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
Trying forwarding F[4]
Forwarded #32 to F[5]
@    84s  Learning in F[5]: (forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
@    84s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    84s  Learning in F[5]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@    84s  Learning in F[5]: (forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
@    84s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    84s  Learning in F[5]: (forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    84s  Learning in F[5]: (forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
@    84s  Learning in F[5]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@    84s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    84s  Learning in F[5]: (forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
@    84s  Learning in F[5]: (forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
@    84s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@    84s  Learning in F[5]: (forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
@    84s  Learning in F[5]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    84s  Learning in F[5]: (forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
@    84s  Learning in F[5]: (forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
@    84s  Learning in F[5]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    84s  Learning in F[5]: (forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
@    84s  Learning in F[5]: (forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
@    84s  Learning in F[5]: (forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
@    84s  Learning in F[5]: (forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    84s  Learning in F[5]: (forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
@    84s  Learning in F[5]: (forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
@    84s  Learning in F[5]: (forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
@    84s  Learning in F[5]: (forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
@    84s  Learning in F[5]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    84s  Learning in F[5]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    84s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    84s  Learning in F[5]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@    84s  Learning in F[5]: (forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@    84s  Learning in F[5]: (forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
@    84s  Learning in F[5]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    84s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    84s  Learning in F[5]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    84s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    84s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@    84s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    84s  Learning in F[5]: (forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    84s  Learning in F[5]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    84s  Learning in F[5]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    84s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    84s  Learning in F[5]: (forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    84s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #1
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
	F[2]: #6
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
	F[3]: #6
		(forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
		(forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
		(forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
		(forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
	F[4]: #2
		(exists Q0 . (forall S0, S1, I0, I1, T0, T1 . (((log(S0, I1) = T0) & (log(S1, I0) = T1) & (loglen(S1) = I1) & committed(I1, T1) & member(S0, Q0)) -> ((I0 = I1) | (T0 = T1)))))
		(forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
	F[5]: #32
		(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
		(forall T0 . ~committed(indzero, T0))
		(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
		(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
		(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
		(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
		(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
		(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
		(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
		(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
		(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
		(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
		(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
		(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
		(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
		(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    84s  
Adding frame 6...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Trying forwarding F[5]
Forwarded #32 to F[6]
@    87s  Learning in F[6]: (forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
@    87s  Learning in F[6]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    87s  Learning in F[6]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@    87s  Learning in F[6]: (forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
@    87s  Learning in F[6]: (forall T0 . ~committed(indzero, T0))
@    87s  Learning in F[6]: (forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    87s  Learning in F[6]: (forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
@    87s  Learning in F[6]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@    87s  Learning in F[6]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    87s  Learning in F[6]: (forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
@    87s  Learning in F[6]: (forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
@    87s  Learning in F[6]: (forall S0 . (log(S0, indzero) = termzero))
@    87s  Learning in F[6]: (forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
@    87s  Learning in F[6]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    87s  Learning in F[6]: (forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
@    87s  Learning in F[6]: (forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
@    87s  Learning in F[6]: (forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@    87s  Learning in F[6]: (forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
@    87s  Learning in F[6]: (forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
@    87s  Learning in F[6]: (forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
@    87s  Learning in F[6]: (forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    87s  Learning in F[6]: (forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
@    87s  Learning in F[6]: (forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
@    87s  Learning in F[6]: (forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
@    87s  Learning in F[6]: (forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
@    87s  Learning in F[6]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    87s  Learning in F[6]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    87s  Learning in F[6]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    87s  Learning in F[6]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@    87s  Learning in F[6]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    87s  Learning in F[6]: (forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
@    87s  Learning in F[6]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    87s  Learning in F[6]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    87s  Learning in F[6]: (forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
@    87s  Learning in F[6]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@    87s  Learning in F[6]: (forall S0 . (log(S0, indzero) = termzero))
@    87s  Learning in F[6]: (forall T0 . ~committed(indzero, T0))
@    87s  Learning in F[6]: (forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
@    87s  Learning in F[6]: (forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
@    87s  Learning in F[6]: (forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
@    87s  Learning in F[6]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    87s  Learning in F[6]: (forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
@    87s  F[6] /\ T /\ !P+ -> UNSAT
Frames: #7
	F[0]: #1
		((forall S7 . ~leader(S7)) & (forall S7 . (currentTerm(S7) = termzero)) & (forall S7 . (loglen(S7) = indzero)) & (forall S7, I7 . (log(S7, I7) = termzero)) & (forall I7_1, T7 . ~committed(I7_1, T7)))
	F[1]: #1
		(forall S0, I0, I1 . ((I0 = I1) | succ(I1, I0) | (log(S0, I0) = termzero)))
	F[2]: #6
		(forall S0, I0 . ((log(S0, I0) = termzero) | (I0 = loglen(S0))))
		(forall I0, S0 . (committed(I0, log(S0, I0)) -> (log(S0, I0) = termzero)))
		(exists S0 . (forall T0, I0, I1 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall S0, I1 . ((log(S0, indzero) = log(S0, I1)) | succ(indzero, I1)))
		(forall T0, S0, S1, I1 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | leader(S0))))
		(forall S0, S1, I0, I1 . ((log(S0, I0) = log(S1, I0)) | (log(S0, I0) = log(S1, I1)) | (log(S1, I0) = log(S1, I1))))
	F[3]: #6
		(forall S0, S1, I1, T1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, T1)) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1))))
		(forall S0, S1, I0, I1 . (committed(I1, log(S0, I1)) -> ((log(S0, I0) = log(S0, I1)) | (log(S0, I0) = log(S1, I0)) | (log(S0, I1) = log(S1, I0)))))
		(forall I0, S0, I1 . ((committed(I1, log(S0, I0)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I0, I1 . (committed(I0, log(S1, I1)) -> ((I0 = I1) | (S0 = S1) | (log(S0, I0) = log(S1, I1)))))
		(forall S0, I1 . (committed(I1, log(S0, I1)) -> (loglen(S0) = I1)))
		(forall S0, I1, S1 . ((committed(I1, currentTerm(S0)) & (loglen(S0) = loglen(S1))) -> ((S0 = S1) | (loglen(S1) = I1))))
	F[4]: #2
		(exists Q0 . (forall S0, S1, I0, I1, T0, T1 . (((log(S0, I1) = T0) & (log(S1, I0) = T1) & (loglen(S1) = I1) & committed(I1, T1) & member(S0, Q0)) -> ((I0 = I1) | (T0 = T1)))))
		(forall I0, S0, I1 . (committed(I1, log(S0, I0)) -> (indlte(I1, I1) | (log(S0, I0) = termzero))))
	F[5]: #0
	F[6]: #32
		(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
		(forall T0 . ~committed(indzero, T0))
		(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
		(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
		(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
		(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
		(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
		(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
		(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
		(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
		(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
		(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
		(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
		(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
		(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
		(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@    87s  
Adding frame 7...
@    87s  F[5] converged!
Explored 8 frames
@    87s  -------------------------------------------------
### Invariant: #33
invariant [other22]	(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
invariant [global9]	(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other17]	(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
invariant [other7]	(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
invariant [other15]	(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
invariant [other1]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other20]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global5_4]	(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
invariant [other19]	(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [prop1]	(forall I7, T7, S7 . ((committed(I7, T7) & leader(S7) & (lte(T7, currentTerm(S7)) & ~(T7 = currentTerm(S7)))) -> (log(S7, I7) = T7)))
invariant [other14]	(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
invariant [other13]	(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global7_3]	(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
invariant [other10]	(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
invariant [other18]	(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
invariant [global9_1]	(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other21]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other5]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global6]	(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
invariant [other6]	(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
invariant [other8]	(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
invariant [other9]	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
invariant [other12]	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
invariant [other16]	(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
invariant [other11]	(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [other4]	(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
invariant [other3]	(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global5_1 -> UNSAT
	#2 global9 -> UNSAT
	#3 other3 -> UNSAT
	#4 global7_3 -> UNSAT
	#5 other7 -> UNSAT
	#6 other15 -> UNSAT
	#7 global7 -> UNSAT
	#8 other1 -> UNSAT
	#9 global11 -> UNSAT
	#10 other20 -> UNSAT
	#11 global5_4 -> UNSAT
	#12 other19 -> UNSAT
	#13 global11_2 -> UNSAT
	#14 prop1  (property) -> UNSAT
	#15 global5 -> UNSAT
	#16 other13 -> UNSAT
	#17 other22 -> UNSAT
	#18 other17 -> UNSAT
	#19 other6 -> UNSAT
	#20 other18 -> UNSAT
	#21 global9_1 -> UNSAT
	#22 other21 -> UNSAT
	#23 other5 -> UNSAT
	#24 global6 -> UNSAT
	#25 other10 -> UNSAT
	#26 other14 -> UNSAT
	#27 other9 -> UNSAT
	#28 other12 -> UNSAT
	#29 other16 -> UNSAT
	#30 other11 -> UNSAT
	#31 other2 -> UNSAT
	#32 other4 -> UNSAT
	#33 other8 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global5_1 -> UNSAT
	#2 global9 -> UNSAT
	#3 other3 -> UNSAT
	#4 global7_3 -> UNSAT
	#5 other7 -> UNSAT
	#6 other15 -> UNSAT
	#7 global7 -> UNSAT
	#8 other1 -> UNSAT
	#9 global11 -> UNSAT
	#10 other20 -> UNSAT
	#11 global5_4 -> UNSAT
	#12 other19 -> UNSAT
	#13 global11_2 -> UNSAT
	#14 prop1  (property) -> UNSAT
	#15 global5 -> UNSAT
	#16 other13 -> UNSAT
	#17 other22 -> UNSAT
	#18 other17 -> UNSAT
	#19 other6 -> UNSAT
	#20 other18 -> UNSAT
	#21 global9_1 -> UNSAT
	#22 other21 -> UNSAT
	#23 other5 -> UNSAT
	#24 global6 -> UNSAT
	#25 other10 -> UNSAT
	#26 other14 -> UNSAT
	#27 other9 -> UNSAT
	#28 other12 -> UNSAT
	#29 other16 -> UNSAT
	#30 other11 -> UNSAT
	#31 other2 -> UNSAT
	#32 other4 -> UNSAT
	#33 other8 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e6: -> [`index:e6:0`, `index:e6:1`, `index:e6:2`]
	term -> term:e6: -> [`term:e6:0`, `term:e6:1`, `term:e6:2`]
	quorum -> quorum:e6: -> [`quorum:e6:0`, `quorum:e6:1`]
	server -> server:e6: -> [`server:e6:0`, `server:e6:1`]

Invariant is a proof certificate
@    88s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e7, T:e7, X:e7 . ((__committed:e7(I:e7, T:e7) & __leader:e7(X:e7) & (...(..., ...) & ~...)) -> (__log:e7(X:e7, I:e7) = T:e7)))
raw invariant [other22] (cost: 4, 4F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1, Q:term:e6:0 . (~...(...) & ~(... = ...) & ~(... = ...) & __committed:e7(Q:index:e6:1, Q:term:e6:0) & (...(...) = indzero:e7) & ~(... = ...)))
raw invariant [global9] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:0, Q:server:e6:0 . ~lte:e7(...(..., ...), ...(...)))
raw invariant [other2] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:0, Q:server:e6:0 . (~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other17] (cost: 104, 4F, 1E) 	~(exists Q:server:e6:0, Q:server:e6:1 . (__leader:e7(Q:server:e6:0) & (exists Q:index:e6:2, Q:term:e6:0 . (forall ... . ...))))
raw invariant [other7] (cost: 4, 4F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1, Q:index:e6:2 . (~...(...) & __committed:e7(Q:index:e6:1, ...(..., ...)) & ~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other15] (cost: 4, 4F, 0E) 	~(exists Q:term:e6:1, Q:index:e6:0, Q:index:e6:1, Q:server:e6:0 . (~...(..., ...) & __committed:e7(Q:index:e6:1, Q:term:e6:1)))
raw invariant [other1] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:0, Q:server:e6:0 . (~(... = ...) & __committed:e7(Q:index:e6:0, termzero:e7)))
raw invariant [global11] (cost: 1, 1F, 0E) 	~(exists Q:server:e6:0 . ~(...(..., ...) = termzero:e7))
raw invariant [other20] (cost: 5, 5F, 0E) 	~(exists Q:index:e7:0, Q:term:e7:1, Q:quorum:e7:0, Q:server:e7:0, Q:server:e7:1 . (~(... = ...) & ~(... = ...) & ~...(..., ...) & __committed:e7(Q:index:e7:0, Q:term:e7:1)))
raw invariant [global5_4] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:0, Q:server:e6:0 . ((...(...) = termzero:e7) & ~(... = ...)))
raw invariant [other19] (cost: 131, 4F, 1E) 	~(exists Q:server:e6:0 . (forall Q:index:e6:0 . (exists Q:term:e6:1, Q:index:e6:2, Q:term:e6:0 . (... & ... & ...))))
raw invariant [global11_2] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e7:0 . (exists Q:term:e7:0, Q:term:e7:1, Q:server:e7:1, Q:server:e7:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [other14] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:1, Q:server:e6:0 . ((...(..., ...) = termzero:e7) & ~(... = ...)))
raw invariant [other13] (cost: 5, 5F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1, Q:term:e6:0, Q:term:e6:1 . ((...(...) = indzero:e7) & __committed:e7(Q:index:e6:1, Q:term:e6:1) & ~(... = ...) & ~...(...) & ~...(..., ...)))
raw invariant [global5_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e7:0 . (__leader:e7(Q:server:e7:0) & (...(...) = termzero:e7)))
raw invariant [global7_3] (cost: 3, 3F, 0E) 	~(exists Q:server:e6:0, Q:index:e6:1, Q:server:e6:1 . (__committed:e7(Q:index:e6:1, ...(..., ...)) & ~(... = ...) & (...(...) = indzero:e7) & (...(...) = indzero:e7)))
raw invariant [other10] (cost: 3, 3F, 0E) 	~(exists Q:server:e6:0, Q:index:e6:1, Q:server:e6:1 . ((...(...) = indzero:e7) & __committed:e7(Q:index:e6:1, ...(..., ...)) & ~...(...)))
raw invariant [other18] (cost: 3, 3F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1 . (__committed:e7(Q:index:e6:1, ...(..., ...)) & ~(... = ...) & (...(...) = indzero:e7) & ~(... = ...) & ~(... = ...)))
raw invariant [global9_1] (cost: 2, 2F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1 . ~(...(..., ...) = ...(..., ...)))
raw invariant [global5] (cost: 1, 1F, 0E) 	~(exists Q:server:e7:0 . (~(... = ...) & __leader:e7(Q:server:e7:0) & ~(... = ...)))
raw invariant [other21] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:0, Q:server:e6:0 . (~(... = ...) & ~...(...)))
raw invariant [other5] (cost: 2, 2F, 0E) 	~(exists Q:index:e6:1, Q:server:e6:0 . (~(... = ...) & (...(..., ...) = ...(...))))
raw invariant [global6] (cost: 4, 4F, 0E) 	~(exists Q:server:e6:0, Q:index:e6:1, Q:server:e6:1, Q:term:e6:0 . (~(... = ...) & ~(... = ...) & ~...(...) & __committed:e7(Q:index:e6:1, Q:term:e6:0) & ~...(...)))
raw invariant [other6] (cost: 5, 5F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:0, Q:term:e6:0, Q:quorum:e6:0 . (__committed:e7(Q:index:e6:0, Q:term:e6:0) & ~(... = ...) & ~(... = ...) & ~...(...) & ~...(..., ...)))
raw invariant [other8] (cost: 3, 3F, 0E) 	~(exists Q:server:e6:0, Q:index:e6:0, Q:index:e6:1 . (~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other9] (cost: 5, 5F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1, Q:term:e6:1, Q:term:e6:2 . (~(... = ...) & ~(... = ...) & ~(... = ...) & __committed:e7(Q:index:e6:1, Q:term:e6:1) & ~(... = ...) & lte:e7(Q:term:e6:1, Q:term:e6:2) & ~...(...) & ~(... = ...)))
raw invariant [other12] (cost: 3, 3F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1 . (~(... = ...) & ~(... = ...) & __committed:e7(Q:index:e6:1, ...(...)) & (...(..., ...) = ...(..., ...)) & __leader:e7(Q:server:e6:1) & __leader:e7(Q:server:e6:0)))
raw invariant [other16] (cost: 4, 4F, 0E) 	~(exists Q:term:e6:1, Q:index:e6:0, Q:term:e6:0, Q:server:e6:0 . (__committed:e7(Q:index:e6:0, Q:term:e6:0) & ~...(..., ...) & __leader:e7(Q:server:e6:0) & ~...(..., ...)))
raw invariant [other11] (cost: 5, 5F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:1, Q:term:e6:0, Q:quorum:e6:0 . (~(... = ...) & ~(... = ...) & ~...(..., ...) & ~...(..., ...) & __committed:e7(Q:index:e6:1, Q:term:e6:0) & ~...(...)))
raw invariant [global7] (cost: 1, 1F, 0E) 	~(exists Q:term:e7:0 . __committed:e7(indzero:e7, Q:term:e7:0))
raw invariant [other4] (cost: 5, 5F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:0, Q:term:e6:1, Q:quorum:e6:0 . (~(... = ...) & ~(... = ...) & __committed:e7(Q:index:e6:0, Q:term:e6:1) & ~...(..., ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other3] (cost: 4, 4F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1, Q:index:e6:0, Q:index:e6:1 . (~(... = ...) & ~(... = ...) & ~(... = ...) & ~...(...)))
@    88s  Minimizing certificate of size 33
@    88s  	other19	(cost: 131) -> remove
@    89s  	other17	(cost: 104) -> remove
@    90s  	other20	(cost: 5) -> add
@    91s  	global11_2	(cost: 5) -> add
@    92s  	other13	(cost: 5) -> remove
@    92s  	other6	(cost: 5) -> remove
@    93s  	other9	(cost: 5) -> add
@    93s  	other11	(cost: 5) -> remove
@    94s  	other4	(cost: 5) -> remove
@    95s  	other22	(cost: 4) -> remove
@    96s  	other7	(cost: 4) -> remove
@    96s  	other15	(cost: 4) -> remove
@    97s  	global6	(cost: 4) -> remove
@    97s  	other16	(cost: 4) -> remove
@    97s  	other3	(cost: 4) -> remove
@    98s  	prop1	(cost: 3) -> property
@    98s  	global7_3	(cost: 3) -> remove
@    98s  	other10	(cost: 3) -> remove
@    98s  	other18	(cost: 3) -> remove
@    99s  	other8	(cost: 3) -> remove
@    99s  	other12	(cost: 3) -> add
@    99s  	global9	(cost: 2) -> remove
@   100s  	other2	(cost: 2) -> add
@   100s  	other1	(cost: 2) -> add
@   100s  	global5_4	(cost: 2) -> remove
@   100s  	other14	(cost: 2) -> remove
@   101s  	global9_1	(cost: 2) -> remove
@   101s  	other21	(cost: 2) -> add
@   101s  	other5	(cost: 2) -> add
@   101s  	global11	(cost: 1) -> add
@   102s  	global5_1	(cost: 1) -> add
@   102s  	global5	(cost: 1) -> add
@   102s  	global7	(cost: 1) -> add
	Minimized certificate: 33 -> 13
@   102s  -------------------------------------------------
### Proof certificate (required): #13
invariant [other20]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other9]	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
invariant [prop1]	(forall I7, T7, S7 . ((committed(I7, T7) & leader(S7) & (lte(T7, currentTerm(S7)) & ~(T7 = currentTerm(S7)))) -> (log(S7, I7) = T7)))
invariant [other12]	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other1]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [other21]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other5]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
###

### Optional invariants: #20
invariant [other19_optional]	(forall S0 . (exists I0 . (forall T1, I2, T0 . ((((I2 = I0) | (log(S0, I0) = T1)) & committed(I2, T0)) -> lte(T1, T0)))))
invariant [other17_optional]	(forall S0, S1 . (leader(S0) -> (forall I2, T0 . (exists I0 . (((I2 = I0) | (log(S1, I0) = T0)) -> ~committed(I2, T0))))))
invariant [other13_optional]	(forall S0, S1, I1, T0, T1 . (((loglen(S1) = indzero) & committed(I1, T1)) -> ((S0 = S1) | leader(S0) | lte(T0, T1))))
invariant [other6_optional]	(forall S0, S1, I0, T0, Q0 . (committed(I0, T0) -> ((S0 = S1) | (T0 = termzero) | leader(S1) | member(S0, Q0))))
invariant [other11_optional]	(forall S0, S1, I1, T0, Q0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (S0 = S1) | succ(I1, loglen(S1)) | member(S0, Q0) | leader(S0))))
invariant [other4_optional]	(forall S0, S1, I0, T1, Q0 . (committed(I0, T1) -> ((T1 = currentTerm(S0)) | (termzero = T1) | member(S1, Q0) | (S0 = S1) | (termzero = currentTerm(S0)))))
invariant [other22_optional]	(forall S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> (leader(S1) | (I1 = loglen(S1)) | (indzero = loglen(S1)) | (indzero = I1))))
invariant [other7_optional]	(forall S0, S1, I1, I2 . (committed(I1, log(S1, I2)) -> (leader(S0) | (loglen(S1) = I1) | (I1 = I2) | (loglen(S1) = I2))))
invariant [other15_optional]	(forall T1, I0, I1, S0 . (committed(I1, T1) -> lte(log(S0, I0), T1)))
invariant [global6_optional]	(forall S0, I1, S1, T0 . (committed(I1, T0) -> ((loglen(S0) = I1) | (S0 = S1) | leader(S1) | leader(S0))))
invariant [other16_optional]	(forall T1, I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (lte(T1, T0) | indlte(I0, I0))))
invariant [other3_optional]	(forall S0, S1, I0, I1 . ((log(S1, I0) = log(S0, I1)) | (log(S0, I0) = log(S0, I1)) | (log(S1, I0) = log(S0, I0)) | leader(S0)))
invariant [global7_3_optional]	(forall S0, I1, S1 . ((committed(I1, log(S0, indzero)) & (loglen(S1) = indzero) & (loglen(S0) = indzero)) -> (S0 = S1)))
invariant [other10_optional]	(forall S0, I1, S1 . (((loglen(S1) = indzero) & committed(I1, log(S1, indzero))) -> leader(S0)))
invariant [other18_optional]	(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> ((I1 = loglen(S1)) | (indzero = I1) | (indzero = loglen(S1)))))
invariant [other8_optional]	(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) | (termzero = log(S0, I0)) | (termzero = log(S0, I1))))
invariant [global9_optional]	(forall I0, S0 . lte(log(S0, I0), currentTerm(S0)))
invariant [global5_4_optional]	(forall I0, S0 . ((currentTerm(S0) = termzero) -> (log(S0, I0) = termzero)))
invariant [other14_optional]	(forall I1, S0 . ((log(S0, loglen(S0)) = termzero) -> (termzero = log(S0, I1))))
invariant [global9_1_optional]	(forall S0, S1 . (log(S1, indzero) = log(S0, indzero)))
###

	random:	0
	scalls:	3157
	scalls-finite:	3133
	scalls-infinite:	24
	scalls-finite-full:	3133
	cti:	102
	cubes:	105
	subsumed-calls:	3196
	subsumed-subset:	2
	subsumed-varintersect-c:	3053
	subsumed-varintersect-e:	0
	subsumed-query-sat:	126
	subsumed-query-unsat:	15
	subsumed-eq:	237
	unsat-core:	193
	sz-unsat-core-avg:	6.08
	sz-unsat-min-avg:	3.33
	sz-cube-avg:	52.47
	antecedent-reduction-sum:	109
	antecedent-total-sum:	372
	antecedent-reduction-avg:	0.29
	antecedent-calls:	91
	antecedent-calls-reduced:	44
	antecedent-scalls:	462
	time-q-max-finite-ms:	2320
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	11
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	5
	time-cti-bad-unsat:	1
	time-cti-sat:	1
	time-cti-unsat:	22
	time-forward:	14
	time-antecedent:	19
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	4
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	24
	time-qf:	0
	time-sum:	91
@   102s  -------------------------------------------------
@   102s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   103s  (finite convergence checks)
@   103s  (performing finite convergence checks for quorum)
(enumsort) index <-> index:e8:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e8:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e8:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e8:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@   103s  -------------------------------------------------
### Invariant: #13
invariant [other20]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other12]	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
invariant [prop1]	(forall I8, T8, S8 . ((committed(I8, T8) & leader(S8) & (lte(T8, currentTerm(S8)) & ~(T8 = currentTerm(S8)))) -> (log(S8, I8) = T8)))
invariant [other1]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other21]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other5]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other9]	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global5_1 -> UNSAT
	#2 other12 -> UNSAT
	#3 prop1  (property) -> UNSAT
	#4 global7 -> UNSAT
	#5 other1 -> UNSAT
	#6 global5 -> UNSAT
	#7 other21 -> UNSAT
	#8 other5 -> UNSAT
	#9 other20 -> UNSAT
	#10 other2 -> UNSAT
	#11 other9 -> UNSAT
	#12 global11_2 -> UNSAT
	#13 global11 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global5_1 -> UNSAT
	#2 other12 -> UNSAT
	#3 prop1  (property) -> UNSAT
	#4 global7 -> UNSAT
	#5 other1 -> UNSAT
	#6 global5 -> UNSAT
	#7 other21 -> UNSAT
	#8 other5 -> UNSAT
	#9 other20 -> UNSAT
	#10 other2 -> UNSAT
	#11 other9 -> UNSAT
	#12 global11_2 -> UNSAT
	#13 global11 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e8: -> [`index:e8:0`, `index:e8:1`, `index:e8:2`]
	term -> term:e8: -> [`term:e8:0`, `term:e8:1`, `term:e8:2`]
	quorum -> quorum:e8: -> [`quorum:e8:0`, `quorum:e8:1`, `quorum:e8:2`]
	server -> server:e8: -> [`server:e8:0`, `server:e8:1`]

Invariant is a proof certificate
@   103s  -------------------------------------------------
@   103s  (performing finite convergence checks for server)
(enumsort) index <-> index:e9:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e9:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e9:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e9:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[i2] = 2
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[s2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@   103s  -------------------------------------------------
### Invariant: #13
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other20]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [other21]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other9]	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other5]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [prop1]	(forall I9, T9, S9 . ((committed(I9, T9) & leader(S9) & (lte(T9, currentTerm(S9)) & ~(T9 = currentTerm(S9)))) -> (log(S9, I9) = T9)))
invariant [other1]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [other12]	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other5 -> UNSAT
	#2 global7 -> UNSAT
	#3 other20 -> UNSAT
	#4 other1 -> UNSAT
	#5 global11 -> UNSAT
	#6 other9 -> UNSAT
	#7 global5_1 -> UNSAT
	#8 other2 -> UNSAT
	#9 global5 -> UNSAT
	#10 global11_2 -> UNSAT
	#11 prop1  (property) -> UNSAT
	#12 other21 -> UNSAT
	#13 other12 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other5 -> UNSAT
	#2 global7 -> UNSAT
	#3 other20 -> SAT
	#4 other1 -> UNSAT
	#5 global11 -> UNSAT
	#6 other9 -> SAT
	#7 global5_1 -> UNSAT
	#8 other2 -> UNSAT
	#9 global5 -> UNSAT
	#10 global11_2 -> UNSAT
	#11 prop1  (property) -> UNSAT
	#12 other21 -> UNSAT
	#13 other12 -> SAT
	Inv_all /\ T /\ !Inv+: 3 failed

Finite sorts: #4
	index -> index:e9: -> [`index:e9:0`, `index:e9:1`, `index:e9:2`]
	term -> term:e9: -> [`term:e9:0`, `term:e9:1`, `term:e9:2`]
	quorum -> quorum:e9: -> [`quorum:e9:0`, `quorum:e9:1`, `quorum:e9:2`]
	server -> server:e9: -> [`server:e9:0`, `server:e9:1`, `server:e9:2`]

Invariant is not a proof certificate
@   103s  -------------------------------------------------
@   103s  (extended |server| to 3)
@   103s  (finite convergence checks failed for server)
(enumsort) index <-> index:e10:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e10:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e10:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e10:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[i2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
	dep_height[s2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   103s  -------------------------------------------------
### Checking reusability of clauses: #12
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other9]	(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other1]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [other21]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other20]	(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [other12]	(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other5]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
###

Checking Init /\ !Inv:
	#1 global11 -> UNSAT
	#2 other9 -> UNSAT
	#3 global5_1 -> UNSAT
	#4 other2 -> UNSAT
	#5 other1 -> UNSAT
	#6 other21 -> UNSAT
	#7 other20 -> UNSAT
	#8 other12 -> UNSAT
	#9 global5 -> UNSAT
	#10 global7 -> UNSAT
	#11 global11_2 -> UNSAT
	#12 other5 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 global11 -> UNSAT
	#2 other9 -> UNSAT
	#3 global5_1 -> UNSAT
	#4 other2 -> UNSAT
	#5 other1 -> UNSAT
	#6 other21 -> UNSAT
	#7 other20 -> UNSAT
	#8 other12 -> UNSAT
	#9 global5 -> UNSAT
	#10 global7 -> UNSAT
	#11 global11_2 -> UNSAT
	#12 other5 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 12 -> 12 (0 + 0 failed)
All clauses reusable
@   103s  -------------------------------------------------
	random:	0
	scalls:	3237
	scalls-finite:	3189
	scalls-infinite:	48
	scalls-finite-full:	3189
	cti:	102
	cubes:	105
	subsumed-calls:	3196
	subsumed-subset:	2
	subsumed-varintersect-c:	3053
	subsumed-varintersect-e:	0
	subsumed-query-sat:	126
	subsumed-query-unsat:	15
	subsumed-eq:	237
	unsat-core:	193
	sz-unsat-core-avg:	6.08
	sz-unsat-min-avg:	3.33
	sz-cube-avg:	52.47
	antecedent-reduction-sum:	109
	antecedent-total-sum:	372
	antecedent-reduction-avg:	0.29
	antecedent-calls:	91
	antecedent-calls-reduced:	44
	antecedent-scalls:	462
	time-q-max-finite-ms:	2320
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	11
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	5
	time-cti-bad-unsat:	1
	time-cti-sat:	1
	time-cti-unsat:	22
	time-forward:	14
	time-antecedent:	19
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	4
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	24
	time-qf:	0
	time-sum:	92
@   103s  -------------------------------------------------
@   103s  -------------------------------------------------
@   103s  (incremental SymIC3)
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[i2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
	dep_height[s2] = 302
(use_wires: False)

Checking property...

@   103s  Storing init values:
@   103s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(currentTerm(s2) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s0, i2) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(log(s1, i2) = t0)
	(log(s2, i0) = t0)
	(log(s2, i1) = t0)
	(log(s2, i2) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(loglen(s2) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i1, i2)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i1, i2)
	lte(t0, t0)
	lte(t0, t1)
	lte(t0, t2)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t2)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~committed(i2, t0)
	~committed(i2, t1)
	~committed(i2, t2)
	~leader(s0)
	~leader(s1)
	~leader(s2)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i2, i0)
	~indlt(i2, i1)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i2, i0)
	~indlte(i2, i1)
	~indlte(i2, i2)
	~lte(t1, t0)
	~lte(t2, t0)
	~lte(t2, t1)
	~member(s0, q0)
	~member(s0, q1)
	~member(s2, q0)
	~member(s2, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@   104s  F[0] /\ !P -> UNSAT
@   104s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S11 . ~leader(S11)) & (forall S11 . (currentTerm(S11) = termzero)) & (forall S11 . (loglen(S11) = indzero)) & (forall S11, I11 . (log(S11, I11) = termzero)) & (forall I11_1, T11 . ~committed(I11_1, T11)))
@   104s  
Adding frame 1...
@   104s  Is F[0] -> other2? -> UNSAT
@   104s  Is other2 inductive? -> SAT
@   104s  Is F[0] /\ T -> other2+? -> UNSAT
@   104s  Learning in F[1]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   104s  Is F[0] -> other9? -> UNSAT
@   104s  Is other9 inductive? -> SAT
@   104s  Is F[0] /\ T -> other9+? -> UNSAT
@   104s  Learning in F[1]: (forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
@   104s  Is F[0] -> global11? -> UNSAT
@   104s  Is global11 inductive? -> UNSAT
@   104s  Is F[0] -> other12? -> UNSAT
@   104s  Is other12 inductive? -> SAT
@   104s  Is F[0] /\ T -> other12+? -> UNSAT
@   104s  Learning in F[1]: (forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@   104s  Is F[0] -> global5_1? -> UNSAT
@   104s  Is global5_1 inductive? -> UNSAT
@   104s  Is F[0] -> other1? -> UNSAT
@   104s  Is other1 inductive? -> SAT
@   104s  Is F[0] /\ T -> other1+? -> UNSAT
@   104s  Learning in F[1]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@   104s  Is F[0] -> other20? -> UNSAT
@   104s  Is other20 inductive? -> SAT
@   104s  Is F[0] /\ T -> other20+? -> UNSAT
@   104s  Learning in F[1]: (forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   104s  Is F[0] -> global11_2? -> UNSAT
@   104s  Is global11_2 inductive? -> UNSAT
@   104s  Is F[0] -> global7? -> UNSAT
@   104s  Is global7 inductive? -> UNSAT
@   104s  Is F[0] -> other21? -> UNSAT
@   104s  Is other21 inductive? -> SAT
@   104s  Is F[0] /\ T -> other21+? -> UNSAT
@   104s  Learning in F[1]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   104s  Is F[0] -> global5? -> UNSAT
@   104s  Is global5 inductive? -> UNSAT
@   104s  Is F[0] -> other5? -> UNSAT
@   104s  Is other5 inductive? -> SAT
@   104s  Is F[0] /\ T -> other5+? -> UNSAT
@   104s  Learning in F[1]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
Seeded 12 (global: 5, init: 7) helpers out of 12
@   104s  Learning in F[1]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   104s  Learning in F[1]: (forall S0 . (log(S0, indzero) = termzero))
@   104s  Learning in F[1]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   104s  Learning in F[1]: (forall T0 . ~committed(indzero, T0))
@   104s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   104s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S11 . ~leader(S11)) & (forall S11 . (currentTerm(S11) = termzero)) & (forall S11 . (loglen(S11) = indzero)) & (forall S11, I11 . (log(S11, I11) = termzero)) & (forall I11_1, T11 . ~committed(I11_1, T11)))
	F[1]: #12
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
		(forall T0 . ~committed(indzero, T0))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
@   104s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #9 to F[2]
@   104s  Learning in F[2]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   104s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   104s  Learning in F[2]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@   104s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@   104s  Learning in F[2]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   104s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   104s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   104s  Learning in F[2]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   104s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   104s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   104s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   104s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   104s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@   104s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   104s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e11 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2:e5:e8:e9 -> t0
		V__fml:q:e1:e2:e5:e8:e9 -> q0
		V__fml:e1:e2:e5:e8:e9 -> s0
@   104s  F[1] /\ T /\ C+ ?
@   104s  	Ans. UNSAT
@   105s  F[2] unsat core #6 	(ucsz: 15 -> 10 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	committed(i0, t1)
	(log(s1, i0) = t2)
	lte(t1, t0)
	(loglen(s2) = i2)
	(indzero = i2)
	~leader(s0)
(clause)
	(~(indzero = i2) | ~(log(s1, i0) = t2) | ~(loglen(s2) = i2) | ~committed(i0, t1) | ~lte(t1, t0) | leader(s0))
(relations)
	log
	loglen
	lte
	leader
	committed
	indzero
(fullsorts)
	server:e10: -> [ SERVER0, SERVER1, SERVER2, ]
	term:e10: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	lte(TERM1, TERM0)
	committed(INDEX0, TERM1)
	(loglen(SERVER2) = INDEX1)
	(log(SERVER1, INDEX0) = TERM2)
	(indzero = INDEX1)
	~leader(SERVER0)
(antecedent reduction)
@   105s  antecedent: 8 -> 6 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	INDEX1 -> indzero
(cube eq)
	lte(TERM1, TERM0)
	committed(INDEX0, TERM1)
	~leader(SERVER0)
	(loglen(SERVER2) = indzero)
	(log(SERVER1, INDEX0) = TERM2)
(qvars eq)
	SERVER1
	SERVER2
	INDEX0
	TERM0
	TERM1
	TERM2
	SERVER0
(antecedent eq)
	server:e10:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
	term:e10:
	-> ~(TERM0 = TERM1)
	-> ~(TERM0 = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	server:e10: -> [ SERVER0, SERVER1, SERVER2, ]
	term:e10: -> [ TERM0, TERM1, TERM2, ]
qv2cubes #3
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM2), ]
	SERVER2 -> [ (loglen(SERVER2) = indzero), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #3
	SERVER1 -> [ (log(V:server:e10:, INDEX0) = TERM2), ]
	SERVER2 -> [ (loglen(V:server:e10:) = indzero), ]
	SERVER0 -> [ ~leader(V:server:e10:), ]
ucubes2qv #3
	~leader(V:server:e10:) -> [ SERVER0, ]
	(loglen(V:server:e10:) = indzero) -> [ SERVER2, ]
	(log(V:server:e10:, INDEX0) = TERM2) -> [ SERVER1, ]
(partition) #3 server:e10: -> { SERVER0, | SERVER2, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	TERM2 -> [ (log(SERVER1, INDEX0) = TERM2), ]
	TERM0 -> [ lte(TERM1, TERM0), ]
	TERM1 -> [ lte(TERM1, TERM0), committed(INDEX0, TERM1), ]
qv2ucubes #3
	TERM2 -> [ (log(SERVER1, INDEX0) = V:term:e10:), ]
	TERM0 -> [ lte(TERM1, V:term:e10:), ]
	TERM1 -> [ lte(V:term:e10:, TERM0), committed(INDEX0, V:term:e10:), ]
ucubes2qv #3
	lte(TERM1, V:term:e10:) -> [ TERM0, ]
	(log(SERVER1, INDEX0) = V:term:e10:) -> [ TERM2, ]
	(committed(INDEX0, V:term:e10:) & lte(V:term:e10:, TERM0)) -> [ TERM1, ]
(partition) #3 term:e10: -> { TERM0, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM2 -> log(SERVER1, INDEX0)
(cube eq: post)
	lte(TERM1, TERM0)
	committed(INDEX0, TERM1)
	~(TERM0 = log(SERVER1, INDEX0))
	~(SERVER0 = SERVER1)
	~(TERM1 = log(SERVER1, INDEX0))
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~(TERM0 = TERM1)
	(loglen(SERVER2) = indzero)
	~leader(SERVER0)
(qvars eq: post)
	SERVER1
	SERVER2
	INDEX0
	TERM0
	TERM1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER2, INDEX0, TERM0, TERM1, SERVER0 . (~lte(TERM1, TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = log(SERVER1, INDEX0)) | (SERVER0 = SERVER1) | (TERM1 = log(SERVER1, INDEX0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (TERM0 = TERM1) | ~(loglen(SERVER2) = indzero) | leader(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i2) | ~(log(s1, i0) = t2) | ~(loglen(s2) = i2) | ~committed(i0, t1) | ~lte(t1, t0) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER2, INDEX0, TERM0, TERM1, SERVER0 . (~lte(TERM1, TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = log(SERVER1, INDEX0)) | (SERVER0 = SERVER1) | (TERM1 = log(SERVER1, INDEX0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (TERM0 = TERM1) | ~(loglen(SERVER2) = indzero) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
@   105s  is global clause? No
@   105s  Learning in F[2]: (forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
@   105s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e11 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2:e5:e8:e9 -> t0
		V__fml:q:e1:e2:e5:e8:e9 -> q0
		V__fml:e1:e2:e5:e8:e9 -> s0
@   105s  F[1] /\ T /\ C+ ?
@   105s  	Ans. UNSAT
@   105s  F[2] unsat core #5 	(ucsz: 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	member(s0, q1)
	member(s0, q0)
	committed(i2, t2)
	~member(s1, q0)
	(log(s0, i2) = t0)
(clause)
	(~(log(s0, i2) = t0) | ~committed(i2, t2) | ~member(s0, q0) | ~member(s0, q1) | member(s1, q0))
(relations)
	log
	committed
	member
(fullsorts)
	quorum:e10: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(antecedent reduction)
@   105s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	QUORUM0 -> [ ~member(SERVER1, QUORUM0), member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER1, V:quorum:e10:), member(SERVER0, V:quorum:e10:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e10:), ]
ucubes2qv #2
	member(SERVER0, V:quorum:e10:) -> [ QUORUM1, ]
	(member(SERVER0, V:quorum:e10:) & ~member(SERVER1, V:quorum:e10:)) -> [ QUORUM0, ]
(partition) #2 quorum:e10: -> { QUORUM1, | QUORUM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	committed(INDEX0, TERM1)
	~(QUORUM0 = QUORUM1)
	~member(SERVER1, QUORUM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	~(log(SERVER0, INDEX0) = TERM1)
(qvars eq: post)
	SERVER1
	INDEX0
	TERM1
	QUORUM0
	QUORUM1
	SERVER0
(boosted clause)
	(forall SERVER1, INDEX0, TERM1, QUORUM0, QUORUM1, SERVER0 . (~committed(INDEX0, TERM1) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0) | (log(SERVER0, INDEX0) = TERM1)))
---------------------------
(original clause)
	(~(log(s0, i2) = t0) | ~committed(i2, t2) | ~member(s0, q0) | ~member(s0, q1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall SERVER1, INDEX0, TERM1, QUORUM0, QUORUM1, SERVER0 . (~committed(INDEX0, TERM1) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0) | (log(SERVER0, INDEX0) = TERM1)))
---------------------------
(clause-type: univ)	(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
@   105s  is global clause? No
@   105s  Learning in F[2]: (forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
@   105s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e11 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1:e2:e5:e8:e9 -> t0
		V__fml:q:e1:e2:e5:e8:e9 -> q0
		V__fml:e1:e2:e5:e8:e9 -> s0
@   105s  F[1] /\ T /\ C+ ?
@   106s  	Ans. UNSAT
@   106s  F[2] unsat core #9 	(ucsz: 19 -> 17 -> 16 -> 15 -> 11 -> 9 -> 9)
(minimal unsat core)
	committed(i0, t2)
	(currentTerm(s0) = t2)
	leader(s0)
	leader(s1)
	member(s1, q0)
	member(s1, q1)
	(indzero = i1)
	(loglen(s0) = i1)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s0) = t2) | ~(indzero = i1) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1) | ~committed(i0, t2) | ~leader(s0) | ~leader(s1) | ~member(s1, q0) | ~member(s1, q1))
(relations)
	committed
	loglen
	leader
	currentTerm
	member
	indzero
(fullsorts)
	quorum:e10: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	member(SERVER1, QUORUM0)
	(indzero = INDEX1)
	member(SERVER1, QUORUM1)
	leader(SERVER1)
	committed(INDEX0, TERM0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX1)
	(currentTerm(SERVER0) = TERM0)
	leader(SERVER0)
(antecedent reduction)
@   106s  antecedent: 6 -> 4 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX1 -> indzero
(cube eq)
	member(SERVER1, QUORUM1)
	leader(SERVER1)
	committed(INDEX0, TERM0)
	(loglen(SERVER0) = indzero)
	member(SERVER1, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER1) = indzero)
	leader(SERVER0)
(qvars eq)
	SERVER1
	INDEX0
	TERM0
	QUORUM0
	QUORUM1
	SERVER0
(antecedent eq)
	server:e10:
	-> ~(SERVER0 = SERVER1)
	quorum:e10:
	-> ~(QUORUM0 = QUORUM1)
(fullsorts)
	quorum:e10: -> [ QUORUM0, QUORUM1, ]
qv2cubes #2
	QUORUM0 -> [ member(SERVER1, QUORUM0), ]
	QUORUM1 -> [ member(SERVER1, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER1, V:quorum:e10:), ]
	QUORUM1 -> [ member(SERVER1, V:quorum:e10:), ]
ucubes2qv #1
	member(SERVER1, V:quorum:e10:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e10: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER1, TERM0, SERVER0, INDEX0 . (~(currentTerm(SERVER0) = TERM0) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER1, QUORUM0) | (SERVER0 = SERVER1))))
(non-epr version)
	(forall SERVER1, TERM0, SERVER0, INDEX0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER1, QUORUM0) | (SERVER0 = SERVER1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM0, SERVER0, INDEX0 . (~(currentTerm(SERVER0) = TERM0) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER1, QUORUM0) | (SERVER0 = SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(indzero = i1) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1) | ~committed(i0, t2) | ~leader(s0) | ~leader(s1) | ~member(s1, q0) | ~member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM0, SERVER0, INDEX0 . (~(currentTerm(SERVER0) = TERM0) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | ~leader(SERVER1) | ~member(SERVER1, QUORUM0) | (SERVER0 = SERVER1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
@   106s  is global clause? No
@   106s  Learning in F[2]: (exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
@   106s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S11 . ~leader(S11)) & (forall S11 . (currentTerm(S11) = termzero)) & (forall S11 . (loglen(S11) = indzero)) & (forall S11, I11 . (log(S11, I11) = termzero)) & (forall I11_1, T11 . ~committed(I11_1, T11)))
	F[1]: #3
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
	F[2]: #12
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
		(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
		(forall T0 . ~committed(indzero, T0))
@   107s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #12 to F[3]
@   108s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   108s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   108s  Learning in F[3]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@   108s  Learning in F[3]: (forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
@   108s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   108s  Learning in F[3]: (exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
@   108s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   108s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   108s  Learning in F[3]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   108s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@   108s  Learning in F[3]: (forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
@   108s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@   108s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   108s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@   108s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   108s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@   108s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   108s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S11 . ~leader(S11)) & (forall S11 . (currentTerm(S11) = termzero)) & (forall S11 . (loglen(S11) = indzero)) & (forall S11, I11 . (log(S11, I11) = termzero)) & (forall I11_1, T11 . ~committed(I11_1, T11)))
	F[1]: #3
		(forall S0, S1, I1, T1, T2 . ((committed(I1, T1) & lte(T1, T2)) -> ((log(S1, loglen(S1)) = T2) | (loglen(S1) = I1) | (T1 = T2) | (S0 = S1) | leader(S0) | (log(S1, loglen(S1)) = T1))))
		(forall I0, T1, Q0, S0, S1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S0, S1, I1 . ((committed(I1, currentTerm(S1)) & (log(S0, loglen(S0)) = log(S1, I1)) & leader(S1) & leader(S0)) -> ((S0 = S1) | (log(S1, I1) = currentTerm(S1)))))
	F[2]: #0
	F[3]: #12
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
		(forall T0 . ~committed(indzero, T0))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
		(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
@   108s  
Adding frame 4...
@   108s  F[2] converged!
Explored 5 frames
@   108s  -------------------------------------------------
### Invariant: #13
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other4]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [other3]	(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
invariant [other6]	(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [other7]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [prop1]	(forall I11, T11, S11 . ((committed(I11, T11) & leader(S11) & (lte(T11, currentTerm(S11)) & ~(T11 = currentTerm(S11)))) -> (log(S11, I11) = T11)))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other5]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other1]	(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other2 -> UNSAT
	#2 global11 -> UNSAT
	#3 other4 -> UNSAT
	#4 other3 -> UNSAT
	#5 other6 -> UNSAT
	#6 other7 -> UNSAT
	#7 prop1  (property) -> UNSAT
	#8 global11_2 -> UNSAT
	#9 other5 -> UNSAT
	#10 global7 -> UNSAT
	#11 other1 -> UNSAT
	#12 global5 -> UNSAT
	#13 global5_1 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other2 -> UNSAT
	#2 global11 -> UNSAT
	#3 other4 -> UNSAT
	#4 other3 -> UNSAT
	#5 other6 -> UNSAT
	#6 other7 -> UNSAT
	#7 prop1  (property) -> UNSAT
	#8 global11_2 -> UNSAT
	#9 other5 -> UNSAT
	#10 global7 -> UNSAT
	#11 other1 -> UNSAT
	#12 global5 -> UNSAT
	#13 global5_1 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e10: -> [`index:e10:0`, `index:e10:1`, `index:e10:2`]
	term -> term:e10: -> [`term:e10:0`, `term:e10:1`, `term:e10:2`]
	quorum -> quorum:e10: -> [`quorum:e10:0`, `quorum:e10:1`]
	server -> server:e10: -> [`server:e10:0`, `server:e10:1`, `server:e10:2`]

Invariant is a proof certificate
@   109s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e11, T:e11, X:e11 . ((__committed:e11(I:e11, T:e11) & __leader:e11(X:e11) & (...(..., ...) & ~...)) -> (__log:e11(X:e11, I:e11) = T:e11)))
raw invariant [other2] (cost: 2, 2F, 0E) 	~(exists Q:index:e11:0, Q:server:e11:0 . (~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [global11] (cost: 1, 1F, 0E) 	~(exists Q:server:e11:0 . ~(...(..., ...) = termzero:e11))
raw invariant [other4] (cost: 2, 2F, 0E) 	~(exists Q:index:e11:0, Q:server:e11:0 . (~(... = ...) & __committed:e11(Q:index:e11:0, termzero:e11)))
raw invariant [other3] (cost: 6, 6F, 0E) 	~(exists Q:server:e10:1, Q:server:e10:2, Q:index:e10:0, Q:term:e10:0, Q:term:e10:1, Q:server:e10:0 . (lte:e11(Q:term:e10:1, Q:term:e10:0) & __committed:e11(Q:index:e10:0, Q:term:e10:1) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & (...(...) = indzero:e11) & ~...(...)))
raw invariant [other6] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e10:0 . (exists Q:server:e10:1, Q:term:e10:0, Q:server:e10:0, Q:index:e10:0 . ((... = ...) & (... = ...) & (... = ...) & ...(..., ...) & ...(...) & ...(...) & ...(..., ...) & ~...)))
raw invariant [global7] (cost: 1, 1F, 0E) 	~(exists Q:term:e11:0 . __committed:e11(indzero:e11, Q:term:e11:0))
raw invariant [other7] (cost: 2, 2F, 0E) 	~(exists Q:index:e11:1, Q:server:e11:0 . (~(... = ...) & (...(..., ...) = ...(...))))
raw invariant [global11_2] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e11:0 . (exists Q:term:e11:0, Q:term:e11:1, Q:server:e11:1, Q:server:e11:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [other5] (cost: 2, 2F, 0E) 	~(exists Q:index:e11:0, Q:server:e11:0 . (~(... = ...) & ~...(...)))
raw invariant [other1] (cost: 6, 6F, 0E) 	~(exists Q:server:e10:1, Q:index:e10:0, Q:term:e10:1, Q:quorum:e10:0, Q:quorum:e10:1, Q:server:e10:0 . (__committed:e11(Q:index:e10:0, Q:term:e10:1) & ~(... = ...) & ~...(..., ...) & member:e11(Q:server:e10:0, Q:quorum:e10:1) & member:e11(Q:server:e10:0, Q:quorum:e10:0) & ~(... = ...)))
raw invariant [global5] (cost: 1, 1F, 0E) 	~(exists Q:server:e11:0 . (~(... = ...) & __leader:e11(Q:server:e11:0) & ~(... = ...)))
raw invariant [global5_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e11:0 . (__leader:e11(Q:server:e11:0) & (...(...) = termzero:e11)))
@   109s  Minimizing certificate of size 13
@   109s  	other3	(cost: 6) -> add
@   109s  	other1	(cost: 6) -> add
@   110s  	other6	(cost: 5) -> add
@   110s  	global11_2	(cost: 5) -> add
@   111s  	prop1	(cost: 3) -> property
@   111s  	other2	(cost: 2) -> add
@   114s  	other4	(cost: 2) -> add
@   114s  	other7	(cost: 2) -> add
@   115s  	other5	(cost: 2) -> add
@   118s  	global11	(cost: 1) -> add
@   118s  	global7	(cost: 1) -> add
@   120s  	global5	(cost: 1) -> add
@   121s  	global5_1	(cost: 1) -> add
	Minimized certificate: 13 -> 13
@   122s  -------------------------------------------------
### Proof certificate (required): #13
invariant [other3]	(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
invariant [other1]	(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
invariant [other6]	(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [prop1]	(forall I11, T11, S11 . ((committed(I11, T11) & leader(S11) & (lte(T11, currentTerm(S11)) & ~(T11 = currentTerm(S11)))) -> (log(S11, I11) = T11)))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other4]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [other7]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other5]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###

	random:	0
	scalls:	3659
	scalls-finite:	3611
	scalls-infinite:	48
	scalls-finite-full:	3611
	cti:	105
	cubes:	109
	subsumed-calls:	3371
	subsumed-subset:	2
	subsumed-varintersect-c:	3223
	subsumed-varintersect-e:	0
	subsumed-query-sat:	131
	subsumed-query-unsat:	15
	subsumed-eq:	268
	unsat-core:	199
	sz-unsat-core-avg:	6.21
	sz-unsat-min-avg:	3.40
	sz-cube-avg:	53.15
	antecedent-reduction-sum:	115
	antecedent-total-sum:	392
	antecedent-reduction-avg:	0.29
	antecedent-calls:	94
	antecedent-calls-reduced:	47
	antecedent-scalls:	485
	time-q-max-finite-ms:	2320
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	11
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	5
	time-cti-bad-unsat:	2
	time-cti-sat:	1
	time-cti-unsat:	23
	time-forward:	15
	time-antecedent:	19
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	5
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	37
	time-qf:	0
	time-sum:	110
@   122s  -------------------------------------------------
@   122s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   122s  (finite convergence checks)
@   122s  (performing finite convergence checks for quorum)
(enumsort) index <-> index:e12:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e12:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e12:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e12:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[q2] = 102
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@   122s  -------------------------------------------------
### Invariant: #13
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other6]	(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
invariant [other7]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other3]	(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
invariant [other5]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other1]	(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
invariant [other4]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [prop1]	(forall I12, T12, S12 . ((committed(I12, T12) & leader(S12) & (lte(T12, currentTerm(S12)) & ~(T12 = currentTerm(S12)))) -> (log(S12, I12) = T12)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global11_2 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other6 -> UNSAT
	#4 other7 -> UNSAT
	#5 global7 -> UNSAT
	#6 global11 -> UNSAT
	#7 other2 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 other3 -> UNSAT
	#10 other5 -> UNSAT
	#11 other1 -> UNSAT
	#12 other4 -> UNSAT
	#13 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global11_2 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other6 -> UNSAT
	#4 other7 -> UNSAT
	#5 global7 -> UNSAT
	#6 global11 -> UNSAT
	#7 other2 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 other3 -> UNSAT
	#10 other5 -> UNSAT
	#11 other1 -> SAT
	#12 other4 -> UNSAT
	#13 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: 1 failed

Finite sorts: #4
	index -> index:e12: -> [`index:e12:0`, `index:e12:1`, `index:e12:2`]
	term -> term:e12: -> [`term:e12:0`, `term:e12:1`, `term:e12:2`]
	quorum -> quorum:e12: -> [`quorum:e12:0`, `quorum:e12:1`, `quorum:e12:2`]
	server -> server:e12: -> [`server:e12:0`, `server:e12:1`, `server:e12:2`]

Invariant is not a proof certificate
@   130s  -------------------------------------------------
@   130s  (extended |quorum| to 3)
@   130s  (finite convergence checks failed for quorum)
(enumsort) index <-> index:e13:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e13:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e13:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e13:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[q2] = 2
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
	dep_height[s2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   130s  (removed 1 long clauses)
		(forall S1, S2, I0, T0, T1, S0 . ((lte(T1, T0) & committed(I0, T1) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I0)) | (S0 = S1) | (T1 = log(S1, I0)) | (S0 = S2) | (S1 = S2) | (T0 = T1) | leader(S0))))
@   130s  -------------------------------------------------
### Checking reusability of clauses: #11
invariant [other1]	(forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other7]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other2]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other5]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other4]	(forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
invariant [global7]	(forall T0 . ~committed(indzero, T0))
invariant [other6]	(exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
###

Checking Init /\ !Inv:
	#1 other1 -> UNSAT
	#2 global11 -> UNSAT
	#3 other7 -> UNSAT
	#4 global5_1 -> UNSAT
	#5 other2 -> UNSAT
	#6 other5 -> UNSAT
	#7 global5 -> UNSAT
	#8 other4 -> UNSAT
	#9 global7 -> UNSAT
	#10 other6 -> UNSAT
	#11 global11_2 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 other1 -> UNSAT
	#2 global11 -> UNSAT
	#3 other7 -> UNSAT
	#4 global5_1 -> UNSAT
	#5 other2 -> UNSAT
	#6 other5 -> UNSAT
	#7 global5 -> UNSAT
	#8 other4 -> UNSAT
	#9 global7 -> UNSAT
	#10 other6 -> UNSAT
	#11 global11_2 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 11 -> 11 (0 + 0 failed)
All clauses reusable
@   130s  -------------------------------------------------
	random:	0
	scalls:	3709
	scalls-finite:	3639
	scalls-infinite:	70
	scalls-finite-full:	3639
	cti:	105
	cubes:	109
	subsumed-calls:	3371
	subsumed-subset:	2
	subsumed-varintersect-c:	3223
	subsumed-varintersect-e:	0
	subsumed-query-sat:	131
	subsumed-query-unsat:	15
	subsumed-eq:	268
	unsat-core:	199
	sz-unsat-core-avg:	6.21
	sz-unsat-min-avg:	3.40
	sz-cube-avg:	53.15
	antecedent-reduction-sum:	115
	antecedent-total-sum:	392
	antecedent-reduction-avg:	0.29
	antecedent-calls:	94
	antecedent-calls-reduced:	47
	antecedent-scalls:	485
	time-q-max-finite-ms:	4815
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	14
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	5
	time-cti-bad-unsat:	2
	time-cti-sat:	1
	time-cti-unsat:	23
	time-forward:	15
	time-antecedent:	19
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	12
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	37
	time-qf:	0
	time-sum:	117
@   130s  -------------------------------------------------
@   130s  -------------------------------------------------
@   130s  (incremental SymIC3)
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[q2] = 2
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
	dep_height[s2] = 302
(use_wires: False)

Checking property...

@   130s  Storing init values:
@   130s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t1)
	(currentTerm(s1) = t1)
	(currentTerm(s2) = t1)
	(log(s0, i0) = t1)
	(log(s0, i1) = t1)
	(log(s0, i2) = t1)
	(log(s1, i0) = t1)
	(log(s1, i1) = t1)
	(log(s1, i2) = t1)
	(log(s2, i0) = t1)
	(log(s2, i1) = t1)
	(log(s2, i2) = t1)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(loglen(s2) = i0)
	(indzero = i0)
	(termzero = t1)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i2, i1)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i2, i1)
	lte(t0, t0)
	lte(t1, t0)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t0)
	lte(t2, t2)
	member(s0, q0)
	member(s0, q1)
	member(s0, q2)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~committed(i2, t0)
	~committed(i2, t1)
	~committed(i2, t2)
	~leader(s0)
	~leader(s1)
	~leader(s2)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i1, i2)
	~indlt(i2, i0)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i1, i2)
	~indlte(i2, i0)
	~indlte(i2, i2)
	~lte(t0, t1)
	~lte(t0, t2)
	~lte(t2, t1)
	~member(s1, q0)
	~member(s1, q1)
	~member(s1, q2)
	~member(s2, q0)
	~member(s2, q1)
	~member(s2, q2)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@   130s  F[0] /\ !P -> UNSAT
@   130s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
@   130s  
Adding frame 1...
@   130s  Is F[0] -> global5_1? -> UNSAT
@   130s  Is global5_1 inductive? -> UNSAT
@   130s  Is F[0] -> other2? -> UNSAT
@   130s  Is other2 inductive? -> SAT
@   130s  Is F[0] /\ T -> other2+? -> UNSAT
@   130s  Learning in F[1]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   130s  Is F[0] -> other5? -> UNSAT
@   130s  Is other5 inductive? -> SAT
@   130s  Is F[0] /\ T -> other5+? -> UNSAT
@   130s  Learning in F[1]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   130s  Is F[0] -> other4? -> UNSAT
@   130s  Is other4 inductive? -> SAT
@   130s  Is F[0] /\ T -> other4+? -> UNSAT
@   130s  Learning in F[1]: (forall I0, S0 . (committed(I0, termzero) -> (I0 = loglen(S0))))
@   130s  Is F[0] -> other7? -> UNSAT
@   130s  Is other7 inductive? -> SAT
@   130s  Is F[0] /\ T -> other7+? -> UNSAT
@   130s  Learning in F[1]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   130s  Is F[0] -> other1? -> UNSAT
@   130s  Is other1 inductive? -> SAT
@   130s  Is F[0] /\ T -> other1+? -> UNSAT
@   130s  Learning in F[1]: (forall S1, I0, T1, Q0, Q1, S0 . ((committed(I0, T1) & member(S0, Q1) & member(S0, Q0)) -> ((Q0 = Q1) | member(S1, Q0) | (log(S0, I0) = T1))))
@   130s  Is F[0] -> global7? -> UNSAT
@   130s  Is global7 inductive? -> UNSAT
@   130s  Is F[0] -> global11_2? -> UNSAT
@   130s  Is global11_2 inductive? -> UNSAT
@   130s  Is F[0] -> global5? -> UNSAT
@   130s  Is global5 inductive? -> UNSAT
@   130s  Is F[0] -> global11? -> UNSAT
@   130s  Is global11 inductive? -> UNSAT
@   130s  Is F[0] -> other6? -> UNSAT
@   130s  Is other6 inductive? -> SAT
@   130s  Is F[0] /\ T -> other6+? -> UNSAT
@   130s  Learning in F[1]: (exists Q0 . (forall S1, T0, S0, I0 . (((currentTerm(S0) = T0) & (loglen(S0) = indzero) & (loglen(S1) = indzero) & committed(I0, T0) & leader(S0) & leader(S1) & member(S1, Q0)) -> (S0 = S1))))
Seeded 11 (global: 5, init: 6) helpers out of 11
@   130s  Learning in F[1]: (forall S0 . (log(S0, indzero) = termzero))
@   130s  Learning in F[1]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   130s  Learning in F[1]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   130s  Learning in F[1]: (forall T0 . ~committed(indzero, T0))
@   130s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   130s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   130s  F[0] /\ T /\ C+ ?
@   130s  	Ans. UNSAT
@   130s  F[1] unsat core #1 	(ucsz: 1 -> 1)
(minimal unsat core)
	committed(i0, t1)
(clause)
	~committed(i0, t1)
(relations)
	committed
(cube: std)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(original clause)
	~committed(i0, t1)
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(clause-type: univ)	(forall T0, I0 . ~committed(I0, T0))
@   130s  is global clause? No
@   130s  Learning in F[1]: (forall T0, I0 . ~committed(I0, T0))
@   130s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
	F[1]: #8
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall T0, I0 . ~committed(I0, T0))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   130s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #7 to F[2]
@   130s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   130s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   130s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   130s  Learning in F[2]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   130s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   130s  Learning in F[2]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   130s  Learning in F[2]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   130s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   130s  Learning in F[2]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   130s  Learning in F[2]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   130s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@   130s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   130s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e14 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e2:e5:e8:e9:e12 -> i0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
@   130s  F[1] /\ T /\ C+ ?
@   131s  	Ans. UNSAT
@   131s  F[2] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	committed(i0, t1)
	(termzero = t1)
(clause)
	(~(termzero = t1) | ~committed(i0, t1))
(relations)
	termzero
	committed
(cube: std)
	committed(INDEX0, TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
(antecedent eq)
(boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(original clause)
	(~(termzero = t1) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(clause-type: univ)	(forall I0 . ~committed(I0, termzero))
@   131s  is global clause? No
@   131s  Learning in F[2]: (forall I0 . ~committed(I0, termzero))
@   131s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   131s  F[1] /\ T /\ C+ ?
@   131s  	Ans. UNSAT
@   131s  F[2] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	~indlte(i1, i1)
	committed(i1, t2)
(clause)
	(~committed(i1, t2) | indlte(i1, i1))
(relations)
	indlte
	committed
(cube: std)
	committed(INDEX0, TERM0)
	~indlte(INDEX0, INDEX0)

(boosted clause)
	(forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | indlte(INDEX0, INDEX0)))
---------------------------
(original clause)
	(~committed(i1, t2) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | indlte(INDEX0, INDEX0)))
---------------------------
(clause-type: univ)	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   131s  is global clause? Yes
@   131s  Learning in F[2]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   131s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   131s  F[1] /\ T /\ C+ ?
@   131s  	Ans. UNSAT
@   131s  F[2] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	member(s0, q0)
	member(s0, q1)
	member(s0, q2)
	(currentTerm(s0) = t1)
	committed(i1, t2)
(clause)
	(~(currentTerm(s0) = t1) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(relations)
	currentTerm
	member
	committed
(fullsorts)
	quorum:e13: -> [ QUORUM0, QUORUM1, QUORUM2, ]
(cube: std)
	member(SERVER0, QUORUM0)
	committed(INDEX0, TERM1)
	(currentTerm(SERVER0) = TERM0)
	member(SERVER0, QUORUM2)
	member(SERVER0, QUORUM1)
(antecedent reduction)
@   131s  antecedent: 5 -> 5

qv2cubes #3
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM2 -> [ member(SERVER0, QUORUM2), ]
qv2ucubes #3
	QUORUM0 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM2 -> [ member(SERVER0, V:quorum:e13:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e13:) -> [ QUORUM0, QUORUM1, QUORUM2, ]
(partition) #1 quorum:e13: -> { QUORUM0, QUORUM1, QUORUM2, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
(epr reduced)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall INDEX0, TERM0, TERM1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   131s  is global clause? No
@   131s  Learning in F[2]: (exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   131s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   131s  F[1] /\ T /\ C+ ?
@   131s  	Ans. UNSAT
@   131s  F[2] unsat core #4 	(ucsz: 8 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i1, t2)
	(currentTerm(s0) = t1)
	(log(s1, i1) = t1)
	(log(s2, i1) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i1) = t1) | ~(log(s2, i1) = t1) | ~committed(i1, t2))
(relations)
	currentTerm
	log
	committed
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	committed(INDEX0, TERM1)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER1, INDEX0) = TERM0)
	(log(SERVER2, INDEX0) = TERM0)
(antecedent reduction)
@   131s  antecedent: 5 -> 5

qv2cubes #3
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM0), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #3
	SERVER1 -> [ (log(V:server:e13:, INDEX0) = TERM0), ]
	SERVER2 -> [ (log(V:server:e13:, INDEX0) = TERM0), ]
	SERVER0 -> [ (currentTerm(V:server:e13:) = TERM0), ]
ucubes2qv #2
	(currentTerm(V:server:e13:) = TERM0) -> [ SERVER0, ]
	(log(V:server:e13:, INDEX0) = TERM0) -> [ SERVER1, SERVER2, ]
(partition) #2 server:e13: -> { SERVER0, | SERVER1, SERVER2, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		(currentTerm(SERVER0) = TERM0)
ucmulti:
	(log(SERVER1, INDEX0) = TERM0)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER1 . (forall INDEX0, TERM0, TERM1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(log(SERVER1, INDEX0) = TERM0)) | ~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = TERM1))))
(non-epr version)
	(forall INDEX0, TERM0, TERM1, SERVER0 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(log(SERVER1, INDEX0) = TERM0)) | ~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = TERM1))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER1 . (forall INDEX0, TERM0, TERM1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(log(SERVER1, INDEX0) = TERM0)) | ~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i1) = t1) | ~(log(s2, i1) = t1) | ~committed(i1, t2))
(learnt sym-boosted clause)
	(exists SERVER1 . (forall INDEX0, TERM0, TERM1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(log(SERVER1, INDEX0) = TERM0)) | ~(currentTerm(SERVER0) = TERM0) | ~committed(INDEX0, TERM1) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
@   131s  is global clause? No
@   131s  Learning in F[2]: (exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
@   131s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   132s  F[1] /\ T /\ C+ ?
@   132s  	Ans. UNSAT
@   132s  F[2] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(loglen(s2) = i0)
	committed(i2, t1)
	~leader(s0)
	(loglen(s1) = i0)
(clause)
	(~(loglen(s1) = i0) | ~(loglen(s2) = i0) | ~committed(i2, t1) | leader(s0))
(relations)
	loglen
	committed
	leader
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~leader(SERVER0)
	committed(INDEX1, TERM0)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@   132s  antecedent: 5 -> 5

qv2cubes #3
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER2 -> [ (loglen(SERVER2) = INDEX0), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #3
	SERVER1 -> [ (loglen(V:server:e13:) = INDEX0), ]
	SERVER2 -> [ (loglen(V:server:e13:) = INDEX0), ]
	SERVER0 -> [ ~leader(V:server:e13:), ]
ucubes2qv #2
	(loglen(V:server:e13:) = INDEX0) -> [ SERVER1, SERVER2, ]
	~leader(V:server:e13:) -> [ SERVER0, ]
(partition) #2 server:e13: -> { SERVER1, SERVER2, | SERVER0, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		~leader(SERVER0)
ucmulti:
	(loglen(SERVER1) = INDEX0)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER1 . (forall TERM0, INDEX0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX0)) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | leader(SERVER0))))
(non-epr version)
	(forall TERM0, INDEX0, INDEX1, SERVER0 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX0)) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | leader(SERVER0))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER1 . (forall TERM0, INDEX0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX0)) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | leader(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s1) = i0) | ~(loglen(s2) = i0) | ~committed(i2, t1) | leader(s0))
(learnt sym-boosted clause)
	(exists SERVER1 . (forall TERM0, INDEX0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX0)) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | leader(SERVER0))))
---------------------------
(clause-type: epr)	(exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
@   132s  is global clause? No
@   132s  Learning in F[2]: (exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
@   132s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   132s  F[1] /\ T /\ C+ ?
@   132s  	Ans. UNSAT
@   132s  F[2] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	member(s0, q0)
	(log(s0, i1) = t0)
	member(s0, q2)
	member(s0, q1)
	committed(i1, t2)
(clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(relations)
	member
	log
	committed
(fullsorts)
	quorum:e13: -> [ QUORUM0, QUORUM1, QUORUM2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM1)
	member(SERVER0, QUORUM0)
	member(SERVER0, QUORUM2)
	member(SERVER0, QUORUM1)
(antecedent reduction)
@   132s  antecedent: 5 -> 5

qv2cubes #3
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM2 -> [ member(SERVER0, QUORUM2), ]
qv2ucubes #3
	QUORUM0 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM2 -> [ member(SERVER0, V:quorum:e13:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e13:) -> [ QUORUM0, QUORUM1, QUORUM2, ]
(partition) #1 quorum:e13: -> { QUORUM0, QUORUM1, QUORUM2, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
(epr reduced)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall INDEX0, TERM0, TERM1, SERVER0 . (exists QUORUM0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM0) | ~committed(INDEX0, TERM1) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   132s  is global clause? No
@   132s  Learning in F[2]: (exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   132s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
	F[1]: #1
		(forall T0, I0 . ~committed(I0, T0))
	F[2]: #14
		(exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (log(S0, indzero) = termzero))
		(exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall T0 . ~committed(indzero, T0))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
		(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   133s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #12 to F[3]
@   145s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   145s  Learning in F[3]: (forall I0 . ~committed(I0, termzero))
@   145s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@   145s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   145s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   145s  Learning in F[3]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   145s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   145s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@   145s  Learning in F[3]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   146s  Learning in F[3]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   146s  Learning in F[3]: (exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
@   146s  Learning in F[3]: (exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   146s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@   146s  Learning in F[3]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   146s  Learning in F[3]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   146s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@   146s  Learning in F[3]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   146s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   146s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   146s  F[2] /\ T /\ C+ ?
@   146s  	Ans. UNSAT
@   146s  F[3] unsat core #4 	(ucsz: 15 -> 11 -> 7 -> 6 -> 4 -> 4)
(minimal unsat core)
	~member(s2, q0)
	~leader(s1)
	~leader(s0)
	committed(i1, t1)
(clause)
	(~committed(i1, t1) | leader(s0) | leader(s1) | member(s2, q0))
(relations)
	member
	committed
	leader
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~member(SERVER2, QUORUM0)
	~leader(SERVER0)
	~leader(SERVER1)
	committed(INDEX0, TERM0)
(antecedent reduction)
@   148s  antecedent: 3 -> 3

qv2cubes #3
	SERVER1 -> [ ~leader(SERVER1), ]
	SERVER2 -> [ ~member(SERVER2, QUORUM0), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #3
	SERVER1 -> [ ~leader(V:server:e13:), ]
	SERVER2 -> [ ~member(V:server:e13:, QUORUM0), ]
	SERVER0 -> [ ~leader(V:server:e13:), ]
ucubes2qv #2
	~member(V:server:e13:, QUORUM0) -> [ SERVER2, ]
	~leader(V:server:e13:) -> [ SERVER1, SERVER0, ]
(partition) #2 server:e13: -> { SERVER2, | SERVER1, SERVER0, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER2:
		~member(SERVER2, QUORUM0)
ucmulti:
	~leader(SERVER0)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(forall QUORUM0 . (exists SERVER0 . (forall TERM0, INDEX0, SERVER2 . ((~(SERVER2 = SERVER0) & leader(SERVER0)) | ~committed(INDEX0, TERM0) | member(SERVER2, QUORUM0)))))
(non-epr version)
	(forall QUORUM0 . (forall TERM0, INDEX0, SERVER2 . (exists SERVER0 . ((~(SERVER2 = SERVER0) & leader(SERVER0)) | ~committed(INDEX0, TERM0) | member(SERVER2, QUORUM0)))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall QUORUM0 . (exists SERVER0 . (forall TERM0, INDEX0, SERVER2 . ((~(SERVER2 = SERVER0) & leader(SERVER0)) | ~committed(INDEX0, TERM0) | member(SERVER2, QUORUM0)))))
---------------------------
(original clause)
	(~committed(i1, t1) | leader(s0) | leader(s1) | member(s2, q0))
(learnt sym-boosted clause)
	(forall QUORUM0 . (exists SERVER0 . (forall TERM0, INDEX0, SERVER2 . ((~(SERVER2 = SERVER0) & leader(SERVER0)) | ~committed(INDEX0, TERM0) | member(SERVER2, QUORUM0)))))
---------------------------
(clause-type: epr)	(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
@   150s  is global clause? No
@   150s  Learning in F[3]: (forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
@   150s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   150s  F[2] /\ T /\ C+ ?
@   150s  	Ans. UNSAT
@   151s  F[3] unsat core #5 	(ucsz: 17 -> 6 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~member(s2, q0)
	(indzero = i0)
	committed(i1, t0)
	(loglen(s0) = i0)
	~member(s1, q0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0) | member(s2, q0))
(relations)
	indzero
	member
	loglen
	committed
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	~member(SERVER2, QUORUM0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
(antecedent reduction)
@   152s  antecedent: 5 -> 3 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~member(SERVER2, QUORUM0)
	~member(SERVER1, QUORUM0)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
(qvars eq)
	TERM0
	QUORUM0
	SERVER0
	SERVER1
	SERVER2
	INDEX1
(antecedent eq)
	server:e13:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER2 -> [ ~member(SERVER2, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
qv2ucubes #3
	SERVER1 -> [ ~member(V:server:e13:, QUORUM0), ]
	SERVER2 -> [ ~member(V:server:e13:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e13:) = indzero), ]
ucubes2qv #2
	(loglen(V:server:e13:) = indzero) -> [ SERVER0, ]
	~member(V:server:e13:, QUORUM0) -> [ SERVER1, SERVER2, ]
(partition) #2 server:e13: -> { SERVER0, | SERVER1, SERVER2, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		(loglen(SERVER0) = indzero)
ucmulti:
	~member(SERVER1, QUORUM0)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(forall QUORUM0 . (exists SERVER1 . (forall TERM0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & member(SERVER1, QUORUM0)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))))
(non-epr version)
	(forall QUORUM0 . (forall TERM0, INDEX1, SERVER0 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & member(SERVER1, QUORUM0)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall QUORUM0 . (exists SERVER1 . (forall TERM0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & member(SERVER1, QUORUM0)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0) | member(s2, q0))
(learnt sym-boosted clause)
	(forall QUORUM0 . (exists SERVER1 . (forall TERM0, INDEX1, SERVER0 . ((~(SERVER0 = SERVER1) & member(SERVER1, QUORUM0)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))))
---------------------------
(clause-type: epr)	(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
@   155s  is global clause? No
@   155s  Learning in F[3]: (forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
@   155s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   155s  F[2] /\ T /\ C+ ?
@   155s  	Ans. UNSAT
@   156s  F[3] unsat core #4 	(ucsz: 11 -> 6 -> 4 -> 4)
(minimal unsat core)
	~leader(s1)
	~leader(s0)
	~leader(s2)
	committed(i0, t0)
(clause)
	(~committed(i0, t0) | leader(s0) | leader(s1) | leader(s2))
(relations)
	committed
	leader
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~leader(SERVER0)
	~leader(SERVER1)
	committed(INDEX0, TERM0)
	~leader(SERVER2)
(antecedent reduction)
@   157s  antecedent: 3 -> 3

qv2cubes #3
	SERVER1 -> [ ~leader(SERVER1), ]
	SERVER2 -> [ ~leader(SERVER2), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #3
	SERVER1 -> [ ~leader(V:server:e13:), ]
	SERVER2 -> [ ~leader(V:server:e13:), ]
	SERVER0 -> [ ~leader(V:server:e13:), ]
ucubes2qv #1
	~leader(V:server:e13:) -> [ SERVER1, SERVER2, SERVER0, ]
(partition) #1 server:e13: -> { SERVER1, SERVER2, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
(non-epr version)
	(forall TERM0, INDEX0 . (exists SERVER0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
---------------------------
(original clause)
	(~committed(i0, t0) | leader(s0) | leader(s1) | leader(s2))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall TERM0, INDEX0 . (~committed(INDEX0, TERM0) | leader(SERVER0))))
---------------------------
(clause-type: epr)	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   158s  is global clause? Yes
@   158s  Learning in F[3]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   158s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   158s  F[2] /\ T /\ C+ ?
@   158s  	Ans. UNSAT
@   159s  F[3] unsat core #5 	(ucsz: 16 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i1) = t2)
	(indzero = i0)
	committed(i1, t0)
	~leader(s0)
	(loglen(s2) = i0)
(clause)
	(~(indzero = i0) | ~(log(s1, i1) = t2) | ~(loglen(s2) = i0) | ~committed(i1, t0) | leader(s0))
(relations)
	indzero
	loglen
	log
	committed
	leader
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~leader(SERVER0)
	(log(SERVER1, INDEX1) = TERM1)
	(loglen(SERVER2) = INDEX0)
	(indzero = INDEX0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@   163s  antecedent: 7 -> 5 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~leader(SERVER0)
	(log(SERVER1, INDEX1) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER2) = indzero)
(qvars eq)
	TERM0
	TERM1
	SERVER0
	SERVER1
	SERVER2
	INDEX1
(antecedent eq)
	term:e13:
	-> ~(TERM0 = TERM1)
	server:e13:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e13: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
	SERVER2 -> [ (loglen(SERVER2) = indzero), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #3
	SERVER1 -> [ (log(V:server:e13:, INDEX1) = TERM1), ]
	SERVER2 -> [ (loglen(V:server:e13:) = indzero), ]
	SERVER0 -> [ ~leader(V:server:e13:), ]
ucubes2qv #3
	(loglen(V:server:e13:) = indzero) -> [ SERVER2, ]
	(log(V:server:e13:, INDEX1) = TERM1) -> [ SERVER1, ]
	~leader(V:server:e13:) -> [ SERVER0, ]
(partition) #3 server:e13: -> { SERVER2, | SERVER1, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX1)
(cube eq: post)
	~(TERM0 = log(SERVER1, INDEX1))
	~leader(SERVER0)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	(loglen(SERVER2) = indzero)
(qvars eq: post)
	TERM0
	SERVER0
	SERVER1
	SERVER2
	INDEX1
(boosted clause)
	(forall TERM0, SERVER0, SERVER1, SERVER2, INDEX1 . ((TERM0 = log(SERVER1, INDEX1)) | leader(SERVER0) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~(loglen(SERVER2) = indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i1) = t2) | ~(loglen(s2) = i0) | ~committed(i1, t0) | leader(s0))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, SERVER1, SERVER2, INDEX1 . ((TERM0 = log(SERVER1, INDEX1)) | leader(SERVER0) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~(loglen(SERVER2) = indzero)))
---------------------------
(clause-type: univ)	(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
@   163s  is global clause? No
@   163s  Learning in F[3]: (forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
@   163s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e14 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e2:e5:e8:e9:e12 -> q0
		V__fml:e1:e2:e5:e8:e9:e12 -> s0
		V__fml:newterm:e1:e2:e5:e8:e9:e12 -> t0
@   163s  F[2] /\ T /\ C+ ?
@   163s  	Ans. UNSAT
@   164s  F[3] unsat core #6 	(ucsz: 15 -> 9 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	(log(s0, i0) = t1)
	committed(i2, t0)
	member(s0, q0)
	member(s0, q1)
	member(s0, q2)
(clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(relations)
	member
	loglen
	log
	committed
(fullsorts)
	quorum:e13: -> [ QUORUM0, QUORUM1, QUORUM2, ]
(cube: std)
	member(SERVER0, QUORUM0)
	committed(INDEX1, TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	member(SERVER0, QUORUM2)
	member(SERVER0, QUORUM1)
(antecedent reduction)
@   168s  antecedent: 7 -> 5 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #3
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
	QUORUM2 -> [ member(SERVER0, QUORUM2), ]
qv2ucubes #3
	QUORUM0 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e13:), ]
	QUORUM2 -> [ member(SERVER0, V:quorum:e13:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e13:) -> [ QUORUM0, QUORUM1, QUORUM2, ]
(partition) #1 quorum:e13: -> { QUORUM0, QUORUM1, QUORUM2, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
(epr reduced)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, INDEX1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(non-epr version)
	(forall INDEX0, TERM0, TERM1, INDEX1, SERVER0 . (exists QUORUM0 . (~(log(SERVER0, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, INDEX1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | ~member(s0, q0) | ~member(s0, q1) | ~member(s0, q2))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall INDEX0, TERM0, TERM1, INDEX1, SERVER0 . (~(log(SERVER0, INDEX0) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | ~member(SERVER0, QUORUM0) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
@   183s  is global clause? No
@   183s  Learning in F[3]: (exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
@   183s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
	F[1]: #1
		(forall T0, I0 . ~committed(I0, T0))
	F[2]: #2
		(exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
		(exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
	F[3]: #17
		(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
		(exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
		(forall T0 . ~committed(indzero, T0))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   194s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #16 to F[4]
@   276s  Learning in F[4]: (forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
@   276s  Learning in F[4]: (forall I0 . ~committed(I0, termzero))
@   276s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@   276s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   276s  Learning in F[4]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   276s  Learning in F[4]: (exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
@   276s  Learning in F[4]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   276s  Learning in F[4]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   276s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   276s  Learning in F[4]: (forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
@   276s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@   276s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   276s  Learning in F[4]: (forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
@   276s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   276s  Learning in F[4]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   276s  Learning in F[4]: (exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   276s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@   276s  Learning in F[4]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   276s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   276s  Learning in F[4]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   276s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@   276s  Learning in F[4]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   276s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   276s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
	F[1]: #1
		(forall T0, I0 . ~committed(I0, T0))
	F[2]: #2
		(exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
		(exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
	F[3]: #1
		(exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
	F[4]: #16
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
		(forall T0 . ~committed(indzero, T0))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
		(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
		(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   280s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #16 to F[5]
@   378s  Learning in F[5]: (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
@   378s  Learning in F[5]: (forall I0 . ~committed(I0, termzero))
@   378s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@   378s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   378s  Learning in F[5]: (forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
@   378s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   378s  Learning in F[5]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   378s  Learning in F[5]: (forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@   378s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   378s  Learning in F[5]: (forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
@   378s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@   378s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   378s  Learning in F[5]: (forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
@   378s  Learning in F[5]: (exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
@   378s  Learning in F[5]: (forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
@   378s  Learning in F[5]: (exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   378s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@   378s  Learning in F[5]: (forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
@   378s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   378s  Learning in F[5]: (exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
@   378s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@   378s  Learning in F[5]: (exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   378s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   378s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S14 . ~leader(S14)) & (forall S14 . (currentTerm(S14) = termzero)) & (forall S14 . (loglen(S14) = indzero)) & (forall S14, I14 . (log(S14, I14) = termzero)) & (forall I14_1, T14 . ~committed(I14_1, T14)))
	F[1]: #1
		(forall T0, I0 . ~committed(I0, T0))
	F[2]: #2
		(exists S1 . (forall T0, I0, I1, S0 . ((((S0 = S1) | (loglen(S1) = I0)) & committed(I1, T0)) -> ((I0 = I1) | leader(S0)))))
		(exists Q0 . (forall I0, T0, T1, S0 . (((log(S0, I0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
	F[3]: #1
		(exists S1 . (forall I0, T0, T1, S0 . ((((S0 = S1) | (log(S1, I0) = T0)) & (currentTerm(S0) = T0) & committed(I0, T1)) -> (T0 = T1))))
	F[4]: #0
	F[5]: #16
		(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
		(forall I0 . ~committed(I0, termzero))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
		(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
		(forall T0 . ~committed(indzero, T0))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
		(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
		(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
		(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
@   382s  
Adding frame 6...
@   382s  F[4] converged!
Explored 7 frames
@   382s  -------------------------------------------------
### Invariant: #17
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other8]	(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global7]	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
invariant [other2]	(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [other3]	(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
invariant [global6]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other5]	(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [prop1]	(forall I14, T14, S14 . ((committed(I14, T14) & leader(S14) & (lte(T14, currentTerm(S14)) & ~(T14 = currentTerm(S14)))) -> (log(S14, I14) = T14)))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global7_1]	(forall T0 . ~committed(indzero, T0))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other4 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other9 -> UNSAT
	#4 other3 -> UNSAT
	#5 global7 -> UNSAT
	#6 other2 -> UNSAT
	#7 other6 -> UNSAT
	#8 other7 -> UNSAT
	#9 other8 -> UNSAT
	#10 global6 -> UNSAT
	#11 other5 -> UNSAT
	#12 global5 -> UNSAT
	#13 prop1  (property) -> UNSAT
	#14 global11 -> UNSAT
	#15 other1 -> UNSAT
	#16 global11_2 -> UNSAT
	#17 global7_1 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other4 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other9 -> UNSAT
	#4 other3 -> UNSAT
	#5 global7 -> UNSAT
	#6 other2 -> UNSAT
	#7 other6 -> UNSAT
	#8 other7 -> UNSAT
	#9 other8 -> UNSAT
	#10 global6 -> UNSAT
	#11 other5 -> UNSAT
	#12 global5 -> UNSAT
	#13 prop1  (property) -> UNSAT
	#14 global11 -> UNSAT
	#15 other1 -> UNSAT
	#16 global11_2 -> UNSAT
	#17 global7_1 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e13: -> [`index:e13:0`, `index:e13:1`, `index:e13:2`]
	term -> term:e13: -> [`term:e13:0`, `term:e13:1`, `term:e13:2`]
	quorum -> quorum:e13: -> [`quorum:e13:0`, `quorum:e13:1`, `quorum:e13:2`]
	server -> server:e13: -> [`server:e13:0`, `server:e13:1`, `server:e13:2`]

Invariant is a proof certificate
@   440s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e14, T:e14, X:e14 . ((__committed:e14(I:e14, T:e14) & __leader:e14(X:e14) & (...(..., ...) & ~...)) -> (__log:e14(X:e14, I:e14) = T:e14)))
raw invariant [other4] (cost: 2, 2F, 0E) 	~(exists Q:index:e14:1, Q:server:e14:0 . (~(... = ...) & (...(..., ...) = ...(...))))
raw invariant [global5_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e14:0 . (__leader:e14(Q:server:e14:0) & (...(...) = termzero:e14)))
raw invariant [other8] (cost: 131, 4F, 1E) 	~(exists Q:quorum:e13:0 . (forall Q:server:e13:0 . (exists Q:term:e13:0, Q:index:e13:0, Q:server:e13:2 . (... & ... & ...))))
raw invariant [other1] (cost: 1, 1F, 0E) 	~(exists Q:index:e13:0 . __committed:e14(Q:index:e13:0, termzero:e14))
raw invariant [global7] (cost: 3, 2F, 1E) 	~(forall Q:server:e13:0 . (exists Q:term:e13:0, Q:index:e13:0 . (...(..., ...) & ~...)))
raw invariant [other2] (cost: 5, 5F, 0E) 	~(exists Q:term:e13:0, Q:server:e13:0, Q:server:e13:1, Q:server:e13:2, Q:index:e13:1 . (~(... = ...) & ~...(...) & __committed:e14(Q:index:e13:1, Q:term:e13:0) & ~(... = ...) & ~(... = ...) & ~(... = ...) & (...(...) = indzero:e14)))
raw invariant [other6] (cost: 2, 2F, 0E) 	~(exists Q:index:e14:0, Q:server:e14:0 . (~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other7] (cost: 6, 5F, 1E) 	~(forall Q:quorum:e13:0 . (exists Q:index:e13:0, Q:term:e13:0, Q:term:e13:1, Q:index:e13:1, Q:server:e13:0 . ((... = ...) & (... = ...) & ...(..., ...) & ...(..., ...) & ~...)))
raw invariant [other3] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e13:0 . (exists Q:index:e13:0, Q:term:e13:0, Q:term:e13:1, Q:server:e13:0 . ((... = ...) & ...(..., ...) & ...(..., ...) & ~...)))
raw invariant [global6] (cost: 2, 2F, 0E) 	~(exists Q:term:e13:0, Q:index:e13:0 . (__committed:e14(Q:index:e13:0, Q:term:e13:0) & ~...(..., ...)))
raw invariant [other9] (cost: 2, 2F, 0E) 	~(exists Q:index:e14:0, Q:server:e14:0 . (~(... = ...) & ~...(...)))
raw invariant [other5] (cost: 131, 4F, 1E) 	~(exists Q:quorum:e13:0 . (forall Q:server:e13:1 . (exists Q:term:e13:0, Q:index:e13:1, Q:server:e13:0 . (... & ... & ...))))
raw invariant [global5] (cost: 1, 1F, 0E) 	~(exists Q:server:e14:0 . (~(... = ...) & __leader:e14(Q:server:e14:0) & ~(... = ...)))
raw invariant [global11] (cost: 1, 1F, 0E) 	~(exists Q:server:e14:0 . ~(...(..., ...) = termzero:e14))
raw invariant [global11_2] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e14:0 . (exists Q:term:e14:0, Q:term:e14:1, Q:server:e14:1, Q:server:e14:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [global7_1] (cost: 1, 1F, 0E) 	~(exists Q:term:e14:0 . __committed:e14(indzero:e14, Q:term:e14:0))
@   440s  Minimizing certificate of size 17
@   440s  	other8	(cost: 131) -> remove
@   462s  	other5	(cost: 131) -> remove
@   488s  	other7	(cost: 6) -> add
@   488s  	other2	(cost: 5) -> remove
@   514s  	other3	(cost: 5) -> remove
@   520s  	global11_2	(cost: 5) -> add
@   524s  	prop1	(cost: 3) -> property
@   524s  	global7	(cost: 3) -> remove
@   529s  	other4	(cost: 2) -> add
@   532s  	other6	(cost: 2) -> add
@   540s  	global6	(cost: 2) -> remove
@   545s  	other9	(cost: 2) -> add
@   550s  	global5_1	(cost: 1) -> add
@   561s  	other1	(cost: 1) -> add
@   561s  	global5	(cost: 1) -> add
@   561s  	global11	(cost: 1) -> add
@   564s  	global7_1	(cost: 1) -> remove
	Minimized certificate: 17 -> 10
@   571s  -------------------------------------------------
### Proof certificate (required): #10
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [prop1]	(forall I14, T14, S14 . ((committed(I14, T14) & leader(S14) & (lte(T14, currentTerm(S14)) & ~(T14 = currentTerm(S14)))) -> (log(S14, I14) = T14)))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
###

### Optional invariants: #7
invariant [other8_optional]	(forall Q0 . (exists S0 . (forall T0, I0, S2 . (((leader(S0) -> (S2 = S0)) & committed(I0, T0)) -> member(S2, Q0)))))
invariant [other5_optional]	(forall Q0 . (exists S1 . (forall T0, I1, S0 . ((member(S1, Q0) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0))))))
invariant [other2_optional]	(forall T0, S0, S1, S2, I1 . ((committed(I1, T0) & (loglen(S2) = indzero)) -> ((T0 = log(S1, I1)) | leader(S0) | (S0 = S1) | (S0 = S2) | (S1 = S2))))
invariant [other3_optional]	(exists Q0 . (forall I0, T0, T1, S0 . (((currentTerm(S0) = T0) & committed(I0, T1) & member(S0, Q0)) -> (T0 = T1))))
invariant [global7_optional]	(exists S0 . (forall T0, I0 . (committed(I0, T0) -> leader(S0))))
invariant [global6_optional]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [global7_1_optional]	(forall T0 . ~committed(indzero, T0))
###

	random:	0
	scalls:	4318
	scalls-finite:	4248
	scalls-infinite:	70
	scalls-finite-full:	4248
	cti:	117
	cubes:	122
	subsumed-calls:	3754
	subsumed-subset:	2
	subsumed-varintersect-c:	3595
	subsumed-varintersect-e:	0
	subsumed-query-sat:	138
	subsumed-query-unsat:	19
	subsumed-eq:	343
	unsat-core:	220
	sz-unsat-core-avg:	6.28
	sz-unsat-min-avg:	3.46
	sz-cube-avg:	55.37
	antecedent-reduction-sum:	121
	antecedent-total-sum:	437
	antecedent-reduction-avg:	0.28
	antecedent-calls:	103
	antecedent-calls-reduced:	50
	antecedent-scalls:	538
	time-q-max-finite-ms:	28265
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	14
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	6
	time-cti-bad-unsat:	21
	time-cti-sat:	1
	time-cti-unsat:	28
	time-forward:	208
	time-antecedent:	31
	time-subsume:	3
	time-subsume-query:	2
	time-inv-check-finite:	71
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	168
	time-qf:	0
	time-sum:	537
@   571s  -------------------------------------------------
@   571s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   572s  (finite convergence checks)
@   572s  (performing finite convergence checks for index)
(enumsort) index <-> index:e15:
	[ INDEX0, INDEX1, INDEX2, INDEX3, ] <-> [ i0, i1, i2, i3, ]
(enumsort) term <-> term:e15:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e15:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e15:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[t0] = 100
	dep_height[t1] = 101
	dep_height[t2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[i0] = 300
	dep_height[i1] = 301
	dep_height[i2] = 302
	dep_height[i3] = 303
(use_wires: False)
@   572s  -------------------------------------------------
### Invariant: #10
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [prop1]	(forall I15, T15, S15 . ((committed(I15, T15) & leader(S15) & (lte(T15, currentTerm(S15)) & ~(T15 = currentTerm(S15)))) -> (log(S15, I15) = T15)))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other1 -> UNSAT
	#2 prop1  (property) -> UNSAT
	#3 other9 -> UNSAT
	#4 global11 -> UNSAT
	#5 other4 -> UNSAT
	#6 other6 -> UNSAT
	#7 global11_2 -> UNSAT
	#8 other7 -> UNSAT
	#9 global5 -> UNSAT
	#10 global5_1 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other1 -> UNSAT
	#2 prop1  (property) -> UNSAT
	#3 other9 -> UNSAT
	#4 global11 -> UNSAT
	#5 other4 -> UNSAT
	#6 other6 -> UNSAT
	#7 global11_2 -> UNSAT
	#8 other7 -> UNSAT
	#9 global5 -> UNSAT
	#10 global5_1 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e15: -> [`index:e15:0`, `index:e15:1`, `index:e15:2`, `index:e15:3`]
	term -> term:e15: -> [`term:e15:0`, `term:e15:1`, `term:e15:2`]
	quorum -> quorum:e15: -> [`quorum:e15:0`, `quorum:e15:1`, `quorum:e15:2`]
	server -> server:e15: -> [`server:e15:0`, `server:e15:1`, `server:e15:2`]

Invariant is a proof certificate
@   581s  -------------------------------------------------
@   581s  (performing finite convergence checks for term)
(enumsort) index <-> index:e16:
	[ INDEX0, INDEX1, INDEX2, INDEX3, ] <-> [ i0, i1, i2, i3, ]
(enumsort) term <-> term:e16:
	[ TERM0, TERM1, TERM2, TERM3, ] <-> [ t0, t1, t2, t3, ]
(enumsort) quorum <-> quorum:e16:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e16:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[q0] = 100
	dep_height[q1] = 101
	dep_height[q2] = 102
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[i3] = 203
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
	dep_height[t3] = 303
(use_wires: False)
@   581s  -------------------------------------------------
### Invariant: #10
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [prop1]	(forall I16, T16, S16 . ((committed(I16, T16) & leader(S16) & (lte(T16, currentTerm(S16)) & ~(T16 = currentTerm(S16)))) -> (log(S16, I16) = T16)))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global5 -> UNSAT
	#2 global11 -> UNSAT
	#3 other1 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other9 -> UNSAT
	#6 other6 -> UNSAT
	#7 other7 -> UNSAT
	#8 other4 -> UNSAT
	#9 global5_1 -> UNSAT
	#10 global11_2 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global5 -> UNSAT
	#2 global11 -> UNSAT
	#3 other1 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other9 -> UNSAT
	#6 other6 -> UNSAT
	#7 other7 -> UNSAT
	#8 other4 -> UNSAT
	#9 global5_1 -> UNSAT
	#10 global11_2 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e16: -> [`index:e16:0`, `index:e16:1`, `index:e16:2`, `index:e16:3`]
	term -> term:e16: -> [`term:e16:0`, `term:e16:1`, `term:e16:2`, `term:e16:3`]
	quorum -> quorum:e16: -> [`quorum:e16:0`, `quorum:e16:1`, `quorum:e16:2`]
	server -> server:e16: -> [`server:e16:0`, `server:e16:1`, `server:e16:2`]

Invariant is a proof certificate
@   607s  -------------------------------------------------
@   607s  (performing finite convergence checks for quorum)
(enumsort) index <-> index:e17:
	[ INDEX0, INDEX1, INDEX2, INDEX3, ] <-> [ i0, i1, i2, i3, ]
(enumsort) term <-> term:e17:
	[ TERM0, TERM1, TERM2, TERM3, ] <-> [ t0, t1, t2, t3, ]
(enumsort) quorum <-> quorum:e17:
	[ QUORUM0, QUORUM1, QUORUM2, QUORUM3, ] <-> [ q0, q1, q2, q3, ]
(enumsort) server <-> server:e17:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[i2] = 2
	dep_height[i3] = 3
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[s2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[q3] = 203
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
	dep_height[t3] = 303
(use_wires: False)
@   607s  -------------------------------------------------
### Invariant: #10
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [prop1]	(forall I17, T17, S17 . ((committed(I17, T17) & leader(S17) & (lte(T17, currentTerm(S17)) & ~(T17 = currentTerm(S17)))) -> (log(S17, I17) = T17)))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other6 -> UNSAT
	#2 global11 -> UNSAT
	#3 other1 -> UNSAT
	#4 other4 -> UNSAT
	#5 global5_1 -> UNSAT
	#6 global11_2 -> UNSAT
	#7 other7 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 other9 -> UNSAT
	#10 global5 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other6 -> UNSAT
	#2 global11 -> UNSAT
	#3 other1 -> UNSAT
	#4 other4 -> UNSAT
	#5 global5_1 -> UNSAT
	#6 global11_2 -> UNSAT
	#7 other7 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 other9 -> UNSAT
	#10 global5 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e17: -> [`index:e17:0`, `index:e17:1`, `index:e17:2`, `index:e17:3`]
	term -> term:e17: -> [`term:e17:0`, `term:e17:1`, `term:e17:2`, `term:e17:3`]
	quorum -> quorum:e17: -> [`quorum:e17:0`, `quorum:e17:1`, `quorum:e17:2`, `quorum:e17:3`]
	server -> server:e17: -> [`server:e17:0`, `server:e17:1`, `server:e17:2`]

Invariant is a proof certificate
@   629s  -------------------------------------------------
@   629s  (performing finite convergence checks for server)
(enumsort) index <-> index:e18:
	[ INDEX0, INDEX1, INDEX2, INDEX3, ] <-> [ i0, i1, i2, i3, ]
(enumsort) term <-> term:e18:
	[ TERM0, TERM1, TERM2, TERM3, ] <-> [ t0, t1, t2, t3, ]
(enumsort) quorum <-> quorum:e18:
	[ QUORUM0, QUORUM1, QUORUM2, QUORUM3, ] <-> [ q0, q1, q2, q3, ]
(enumsort) server <-> server:e18:
	[ SERVER0, SERVER1, SERVER2, SERVER3, ] <-> [ s0, s1, s2, s3, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[s3] = 3
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[i3] = 103
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[t3] = 203
	dep_height[q0] = 300
	dep_height[q1] = 301
	dep_height[q2] = 302
	dep_height[q3] = 303
(use_wires: False)
@   629s  -------------------------------------------------
### Invariant: #10
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [prop1]	(forall I18, T18, S18 . ((committed(I18, T18) & leader(S18) & (lte(T18, currentTerm(S18)) & ~(T18 = currentTerm(S18)))) -> (log(S18, I18) = T18)))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global11 -> UNSAT
	#2 other1 -> UNSAT
	#3 other4 -> UNSAT
	#4 other9 -> UNSAT
	#5 other7 -> UNSAT
	#6 global5 -> UNSAT
	#7 other6 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 global5_1 -> UNSAT
	#10 global11_2 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global11 -> UNSAT
	#2 other1 -> UNSAT
	#3 other4 -> UNSAT
	#4 other9 -> UNSAT
	#5 other7 -> UNSAT
	#6 global5 -> UNSAT
	#7 other6 -> UNSAT
	#8 prop1  (property) -> UNSAT
	#9 global5_1 -> UNSAT
	#10 global11_2 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e18: -> [`index:e18:0`, `index:e18:1`, `index:e18:2`, `index:e18:3`]
	term -> term:e18: -> [`term:e18:0`, `term:e18:1`, `term:e18:2`, `term:e18:3`]
	quorum -> quorum:e18: -> [`quorum:e18:0`, `quorum:e18:1`, `quorum:e18:2`, `quorum:e18:3`]
	server -> server:e18: -> [`server:e18:0`, `server:e18:1`, `server:e18:2`, `server:e18:3`]

Invariant is a proof certificate
@   661s  -------------------------------------------------
@   661s  (all finite convergence checks passed)
(enumsort) index <-> index:e19:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e19:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e19:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e19:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[t0] = 200
	dep_height[t1] = 201
	dep_height[t2] = 202
	dep_height[q0] = 300
	dep_height[q1] = 301
	dep_height[q2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   661s  -------------------------------------------------
### Invariant: #10
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [prop1]	(forall I, T, X . ((committed(I, T) & leader(X) & (lte(T, currentTerm(X)) & ~(T = currentTerm(X)))) -> (log(X, I) = T)))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
###

Printing Init /\ !Inv:
Printing Inv /\ T /\ !Inv+:
Checking Init /\ !Inv:
	#1 global11 -> UNSAT
	#2 other6 -> UNSAT
	#3 other1 -> UNSAT
	#4 global5_1 -> UNSAT
	#5 prop1  (property) -> UNSAT
	#6 other9 -> UNSAT
	#7 global5 -> UNSAT
	#8 other4 -> UNSAT
	#9 global11_2 -> UNSAT
	#10 other7 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global11 -> UNSAT
	#2 other6 -> UNSAT
	#3 other1 -> UNSAT
	#4 global5_1 -> UNSAT
	#5 prop1  (property) -> UNSAT
	#6 other9 -> UNSAT
	#7 global5 -> UNSAT
	#8 other4 -> UNSAT
	#9 global11_2 -> UNSAT
	#10 other7 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #0

Generalized: 10 -> 10
All generalizable clauses

Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT

Invariant is a proof certificate
@   665s  -------------------------------------------------
@   665s  (unbounded induction checks passed)
	random:	0
	scalls:	4428
	scalls-finite:	4336
	scalls-infinite:	92
	scalls-finite-full:	4336
	cti:	117
	cubes:	122
	subsumed-calls:	3754
	subsumed-subset:	2
	subsumed-varintersect-c:	3595
	subsumed-varintersect-e:	0
	subsumed-query-sat:	138
	subsumed-query-unsat:	19
	subsumed-eq:	343
	unsat-core:	220
	sz-unsat-core-avg:	6.28
	sz-unsat-min-avg:	3.46
	sz-cube-avg:	55.37
	antecedent-reduction-sum:	121
	antecedent-total-sum:	437
	antecedent-reduction-avg:	0.28
	antecedent-calls:	103
	antecedent-calls-reduced:	50
	antecedent-scalls:	538
	time-q-max-finite-ms:	28265
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	2078
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	6
	time-cti-bad-unsat:	21
	time-cti-sat:	1
	time-cti-unsat:	28
	time-forward:	208
	time-antecedent:	31
	time-subsume:	3
	time-subsume-query:	2
	time-inv-check-finite:	160
	time-inv-check-infinite:	3
	time-inv-reuse:	0
	time-minimize:	168
	time-qf:	0
	time-sum:	629
@   665s  -------------------------------------------------
@   665s  -------------------------------------------------
### Proof certificate: #10
invariant [prop1]	(forall I, T, X . ((committed(I, T) & leader(X) & (lte(T, currentTerm(X)) & ~(T = currentTerm(X)))) -> (log(X, I) = T)))
invariant [global11]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other6]	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other1]	(forall I0 . ~committed(I0, termzero))
invariant [global5_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other9]	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5]	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other4]	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global11_2]	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other7]	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
###

	(invariant file: results/mongo_raft_simple/mongo_raft_simple.inv)
### Final proof certificate (stats): #10
invariant [prop1] (3F, 0E, 5A, 1C) 	(forall I, T, X . ((committed(I, T) & leader(X) & (lte(T, currentTerm(X)) & ~(T = currentTerm(X)))) -> (log(X, I) = T)))
invariant [global11] (1F, 0E, 1A, 1C) 	(forall S0 . (log(S0, indzero) = termzero))
invariant [other6] (2F, 0E, 3A, 1C) 	(forall I0, S0 . ((termzero = log(S0, I0)) | (currentTerm(S0) = log(S0, I0)) | (termzero = currentTerm(S0))))
invariant [other1] (1F, 0E, 1A, 1C) 	(forall I0 . ~committed(I0, termzero))
invariant [global5_1] (1F, 0E, 2A, 1C) 	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other9] (2F, 0E, 2A, 1C) 	(forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)))
invariant [global5] (1F, 0E, 3A, 1C) 	(forall S0 . (leader(S0) -> ((log(S0, loglen(S0)) = currentTerm(S0)) | (indzero = loglen(S0)))))
invariant [other4] (2F, 0E, 2A, 1C) 	(forall I1, S0 . ((log(S0, I1) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
invariant [global11_2] (4F, 1E, 4A, 1C) 	(exists Q0 . (forall T0, T1, S1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other7] (5F, 1E, 5A, 1C) 	(exists Q0 . (forall I0, T0, T1, I1, S0 . (((log(S0, I0) = T1) & (loglen(S0) = I0) & committed(I1, T0) & member(S0, Q0)) -> (T0 = T1))))
###


stratifying inductive invariant:
  prop1:
    pos:
    neg:
  global11:
    pos:
    neg:
  other6:
    pos:
    neg:
  other1:
    pos:
    neg:
  global5_1:
    pos:
    neg:
  other9:
    pos:
    neg:
  global5:
    pos:
    neg:
  other4:
    pos:
    neg:
  global11_2:
    pos:
    neg:
	skolem arc: quorum -> term
	skolem arc: quorum -> server
  other7:
    pos:
    neg:
	skolem arc: quorum -> index
	skolem arc: quorum -> term
	skolem arc: quorum -> server
	(with inv: epr: True)

Arcs:
	index -> term
	quorum -> index term server
	server -> index term

EPR: True
-----------------------------------------------------------------
	random:	0
@   665s  -------------------------------------------------
@   665s  -------------------------------------------------
