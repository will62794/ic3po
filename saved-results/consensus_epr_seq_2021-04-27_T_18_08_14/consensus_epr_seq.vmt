(declare-sort quorum 0)
(declare-sort node 0)
(declare-sort value 0)
(declare-sort phase 0)

(define-fun .quorum ((S quorum)) quorum (! S :sort 0))
(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .value ((S value)) value (! S :sort 0))
(define-fun .phase ((S phase)) phase (! S :sort 0))

(declare-fun __votes (node node) Bool)
(declare-fun __leader (node) Bool)
(declare-fun __curr_phase () phase)
(declare-fun __vote_request_msg (node node) Bool)
(declare-fun __vote_msg (node node) Bool)
(declare-fun __voted (node) Bool)
(declare-fun __decided (node value) Bool)

(declare-fun votes (node node) Bool)
(declare-fun leader (node) Bool)
(declare-fun curr_phase () phase)
(declare-fun vote_request_msg (node node) Bool)
(declare-fun vote_msg (node node) Bool)
(declare-fun voted (node) Bool)
(declare-fun decided (node value) Bool)

(define-fun .votes ((V0 node) (V1 node)) Bool (! (__votes V0 V1) :next votes))
(define-fun .leader ((V0 node)) Bool (! (__leader V0) :next leader))
(define-fun .curr_phase () phase (! __curr_phase :next curr_phase))
(define-fun .vote_request_msg ((V0 node) (V1 node)) Bool (! (__vote_request_msg V0 V1) :next vote_request_msg))
(define-fun .vote_msg ((V0 node) (V1 node)) Bool (! (__vote_msg V0 V1) :next vote_msg))
(define-fun .voted ((V0 node)) Bool (! (__voted V0) :next voted))
(define-fun .decided ((V0 node) (V1 value)) Bool (! (__decided V0 V1) :next decided))

(declare-fun phase_becomeLeader () phase)
(declare-fun phase_recvVote () phase)
(declare-fun phase_decide () phase)
(declare-fun phase_sendVote () phase)
(declare-fun phase_sendRequestVote () phase)
(declare-fun member (node quorum) Bool)

(define-fun .phase_becomeLeader () phase (! phase_becomeLeader :global true))
(define-fun .phase_recvVote () phase (! phase_recvVote :global true))
(define-fun .phase_decide () phase (! phase_decide :global true))
(define-fun .phase_sendVote () phase (! phase_sendVote :global true))
(define-fun .phase_sendRequestVote () phase (! phase_sendRequestVote :global true))
(define-fun .member ((V0 node) (V1 quorum)) Bool (! (member V0 V1) :global true))

(define-fun .prop () Bool (! 
 (let (($v (forall ((N1 node) (N2 node) (V1 value) (V2 value)) (=> (and (__decided N1 V1) (__decided N2 V2)) (= V1 V2)))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v (and (forall ((Q1 quorum) (Q2 quorum)) (exists ((N node)) (and (member N Q1) (member N Q2)))) (not (= phase_sendRequestVote phase_sendVote)) (not (= phase_sendRequestVote phase_recvVote)) (not (= phase_sendRequestVote phase_becomeLeader)) (not (= phase_sendRequestVote phase_decide)) (not (= phase_sendVote phase_recvVote)) (not (= phase_sendVote phase_becomeLeader)) (not (= phase_sendVote phase_decide)) (not (= phase_recvVote phase_becomeLeader)) (not (= phase_recvVote phase_decide)) (not (= phase_becomeLeader phase_decide)))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node) (V1 node)) (= (__vote_request_msg V0 V1) false)) (forall ((V0 node)) (= (__voted V0) false)) (forall ((V0 node) (V1 node)) (= (__vote_msg V0 V1) false)) (forall ((V0 node) (V1 node)) (= (__votes V0 V1) false)) (forall ((V0 node)) (= (__leader V0) false)) (forall ((V0 node) (V1 value)) (= (__decided V0 V1) false)) (= __curr_phase phase_sendRequestVote))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:send_vote () Bool (! 
 (let (($v (exists ((V__fml:dst node) (V__fml:src node)) (and (forall ((V0 node) (V1 node)) (= (vote_msg V0 V1) (ite (and (= V0 V__fml:src) (= V1 V__fml:dst)) true (__vote_msg V0 V1)))) (forall ((V0 node)) (= (voted V0) (ite (= V0 V__fml:src) true (__voted V0)))) (= __curr_phase phase_sendVote) (not (__voted V__fml:src)) (__vote_request_msg V__fml:dst V__fml:src) (forall ((X0 node) (X1 node)) (or (not (vote_request_msg X0 X1)) (__vote_request_msg X0 X1) (= X0 V__fml:src))) (forall ((X0 node) (X1 node)) (or (not (vote_request_msg X0 X1)) (__vote_request_msg X0 X1) (= X1 V__fml:dst))) (forall ((X0 node) (X1 node)) (or (vote_request_msg X0 X1) (not (__vote_request_msg X0 X1)) (= X0 V__fml:src))) (forall ((X0 node) (X1 node)) (or (vote_request_msg X0 X1) (not (__vote_request_msg X0 X1)) (= X1 V__fml:dst)))))
 ))
 (and $v))
 :action ext:send_vote))

(define-fun .action_ext:become_leader () Bool (! 
 (let (($v (exists ((V__fml:n node) (V__fml:q quorum)) (and (forall ((V0 node)) (= (leader V0) (ite (= V0 V__fml:n) true (__leader V0)))) (= __curr_phase phase_becomeLeader) (forall ((N node)) (=> (member N V__fml:q) (__votes V__fml:n N)))))
 ))
 (and $v))
 :action ext:become_leader))

(define-fun .action_ext:recv_vote () Bool (! 
 (let (($v (exists ((V__fml:n node) (V__fml:sender node)) (and (forall ((V0 node) (V1 node)) (= (votes V0 V1) (ite (and (= V0 V__fml:n) (= V1 V__fml:sender)) true (__votes V0 V1)))) (= __curr_phase phase_recvVote) (__vote_msg V__fml:sender V__fml:n)))
 ))
 (and $v))
 :action ext:recv_vote))

(define-fun .action_ext:send_request_vote () Bool (! 
 (let (($v (exists ((V__fml:dst node) (V__fml:src node)) (and (forall ((V0 node) (V1 node)) (= (vote_request_msg V0 V1) (ite (and (= V0 V__fml:src) (= V1 V__fml:dst)) true (__vote_request_msg V0 V1)))) (= __curr_phase phase_sendRequestVote)))
 ))
 (and $v))
 :action ext:send_request_vote))

(define-fun .action_ext:decide () Bool (! 
 (let (($v (exists ((V__fml:n node) (V__fml:v value)) (and (forall ((V0 node) (V1 value)) (= (decided V0 V1) (ite (and (= V0 V__fml:n) (= V1 V__fml:v)) true (__decided V0 V1)))) (= __curr_phase phase_decide) (__leader V__fml:n) (forall ((V value)) (not (__decided V__fml:n V)))))
 ))
 (and $v))
 :action ext:decide))

(define-fun .action_ext:next_phase4 () Bool (! 
 (let (($v (and (= curr_phase phase_decide) (= __curr_phase phase_becomeLeader))
 ))
 (and $v))
 :action ext:next_phase4))

(define-fun .action_ext:next_phase3 () Bool (! 
 (let (($v (and (= curr_phase phase_becomeLeader) (= __curr_phase phase_recvVote))
 ))
 (and $v))
 :action ext:next_phase3))

(define-fun .action_ext:next_phase2 () Bool (! 
 (let (($v (and (= curr_phase phase_recvVote) (= __curr_phase phase_sendVote))
 ))
 (and $v))
 :action ext:next_phase2))

(define-fun .action_ext:next_phase1 () Bool (! 
 (let (($v (and (= curr_phase phase_sendVote) (= __curr_phase phase_sendRequestVote))
 ))
 (and $v))
 :action ext:next_phase1))

