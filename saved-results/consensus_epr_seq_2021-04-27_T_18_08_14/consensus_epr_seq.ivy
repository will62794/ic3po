#lang ivy1.7

type node
type value
type quorum
type phase

relation member(N:node, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:node. member(N, Q1) & member(N, Q2)

relation vote_request_msg(N0:node, N1:node)
relation voted(N:node)
relation vote_msg(N0:node, N1:node)
relation votes(N0:node, N1:node)
relation leader(N:node)
relation decided(N:node, V:value)

individual curr_phase : phase


individual phase_sendRequestVote : phase
individual phase_sendVote : phase
individual phase_recvVote : phase
individual phase_becomeLeader : phase
individual phase_decide : phase

axiom ~(phase_sendRequestVote = phase_sendVote) & ~(phase_sendRequestVote = phase_recvVote) & ~(phase_sendRequestVote = phase_becomeLeader) & ~(phase_sendRequestVote = phase_decide)
axiom ~(phase_sendVote = phase_recvVote) & ~(phase_sendVote = phase_becomeLeader) & ~(phase_sendVote = phase_decide)
axiom ~(phase_recvVote = phase_becomeLeader) & ~(phase_recvVote = phase_decide)
axiom ~(phase_becomeLeader = phase_decide)

after init  {
	vote_request_msg(N1, N2) := false;
	voted(N) := false;
	vote_msg(N1, N2) := false;
	votes(N1, N2) := false;
	leader(N1) := false;
	decided(N, V) := false;
    curr_phase := phase_sendRequestVote;
}

# action all(i:node, v:value, q1:quorum) = {
#     # Send out vote requests to some quorum.
#     vote_request_msg(i, Q) := member(Q,q1);

#     # Send votes from some quorum.
#     require member(Q, q1) -> ~voted(Q);
#     vote_msg(Q, i) := member(Q,q1);
#     voted(Q) := member(Q,q1);
    
#     # Potential leader receives votes from the quorum.
#     votes(i, Q) := member(Q,q1);

#     # Become leader.
#     leader(i) := true;

#     # Decide on a value.
#     decided(i,v) := true;
# }
# export all

action send_request_vote(src: node, dst: node) = {
    require curr_phase = phase_sendRequestVote;

    vote_request_msg(src, dst) := true;
}

# action send_request_vote(src: node, q: quorum) = {
#     require curr_phase = phase_sendRequestVote;

#     # vote_request_msg(src, dst) := true;
#     vote_request_msg(src, Q) := member(Q,q);
# }

action send_vote(src: node, dst: node) = {
  require curr_phase = phase_sendVote;

  require ~voted(src);
  require vote_request_msg(dst, src);
  
  vote_msg(src, dst) := true;
  voted(src) := true;
  vote_request_msg(src, dst) := *;
}

action recv_vote(n: node, sender: node) = {
  require curr_phase = phase_recvVote;

  require vote_msg(sender, n);
  
  votes(n, sender) := true;
}

action become_leader(n: node, q: quorum) = {
  require curr_phase = phase_becomeLeader;

  require member(N, q) -> votes(n, N);
  
  leader(n) := true;
}

action decide(n: node, v: value) = {
  require curr_phase = phase_decide;

  require leader(n);
  require ~decided(n, V);
  
  decided(n,v) := true;
}

action next_phase1 = {
    require curr_phase = phase_sendRequestVote;
    curr_phase := phase_sendVote;
}
action next_phase2 = {
    require curr_phase = phase_sendVote;
    curr_phase := phase_recvVote;
}
action next_phase3 = {
    require curr_phase = phase_recvVote;
    curr_phase := phase_becomeLeader;
}
action next_phase4 = {
    require curr_phase = phase_becomeLeader;
    curr_phase := phase_decide;
}
export next_phase1
export next_phase2
export next_phase3
export next_phase4

export send_request_vote
export send_vote
export recv_vote
export become_leader
export decide

# safety property:
# invariant [safety] (vote_msg(N0,N1) & vote_msg(N0,N2) -> N1 = N2) & (leader(N1) & leader(N2) -> N1 = N2) & (decided(N1, V1) & decided(N2, V2) -> V1 = V2)
# invariant [safety] (leader(N1) & leader(N2) -> N1 = N2) & (decided(N1, V1) & decided(N2, V2) -> V1 = V2)
invariant [safety] (decided(N1, V1) & decided(N2, V2) -> V1 = V2)

# unique leader.
# invariant [safety] leader(N1) & leader(N2) -> N1 = N2

# nodes only vote once.
# invariant [safety] vote_msg(N0,N1) & vote_msg(N0,N2) -> N1 = N2


#invariant [manual_1] leader(N1) & leader(N2) -> N1 = N2
#invariant [manual_2] votes(N, N1) -> vote_msg(N1, N)
#invariant [manual_3] vote_msg(N, N1) & vote_msg(N, N2) -> N1 = N2
#invariant [manual_4] vote_msg(N, N1) -> voted(N)
#invariant [manual_5] exists Q. forall N, M. leader(N) & member(M, Q) -> votes(N, M)
#invariant [manual_6] decided(N, V) -> leader(N)
