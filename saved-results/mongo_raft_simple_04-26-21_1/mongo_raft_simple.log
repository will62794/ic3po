
Printing isolate this:
OK
	(mode: ic3po)
	(reuse: 1)
	(opt: 1)
	(const: 1)
	(wires: 1)
	(using z3 4.8.10.0 with seed 0)
@     0s  Reading from file results/mongo_raft_simple/mongo_raft_simple.vmt
-----------------------------------------------------------------

Action inputs:
	ext:commitEntry: set([V__fml:i, V__fml:q])
	ext:becomeLeader: set([V__fml:i, V__fml:newterm, V__fml:q])
	ext:clientRequest: set([V__fml:i, V__fml:nextInd])
	ext:getEntries: set([V__fml:i, V__fml:nextInd, V__fml:j])

Action definitions:
	ext:commitEntry: {}
	ext:becomeLeader: {}
	ext:clientRequest: {}
	ext:getEntries: {}

Action preconditions:

	ext:commitEntry:
		member(V__fml:i, V__fml:q)
		~(__loglen(V__fml:i) = indzero)
		(forall X . (member(X, V__fml:q) -> (__currentTerm(X) = __currentTerm(V__fml:i))))
		(forall X . (member(X, V__fml:q) -> (indlte(__loglen(X), __loglen(V__fml:i)) & (__log(X, __loglen(V__fml:i)) = __log(V__fml:i, __loglen(V__fml:i))))))
		__leader(V__fml:i)

	ext:becomeLeader:
		~(V__fml:newterm = termzero)
		lte(__currentTerm(V__fml:i), V__fml:newterm)
		~(V__fml:newterm = __currentTerm(V__fml:i))
		member(V__fml:i, V__fml:q)
		(forall X . (member(X, V__fml:q) -> (lte(__currentTerm(X), V__fml:newterm) & ~(__currentTerm(X) = V__fml:newterm))))
		(forall X . (member(X, V__fml:q) -> ((__loglen(X) = indzero) | ((__log(V__fml:i, __loglen(V__fml:i)) = __log(X, __loglen(X))) & indlt(__loglen(V__fml:i), __loglen(X))) | (lte(__log(X, __loglen(X)), __log(V__fml:i, __loglen(V__fml:i))) & ~(__log(X, __loglen(X)) = __log(V__fml:i, __loglen(V__fml:i)))))))

	ext:clientRequest:
		succ(__loglen(V__fml:i), V__fml:nextInd)
		__leader(V__fml:i)

	ext:getEntries:
		~(indzero = __loglen(V__fml:i))
		indlt(indzero, __loglen(V__fml:i))
		indlt(__loglen(V__fml:j), __loglen(V__fml:i))
		succ(__loglen(V__fml:j), V__fml:nextInd)
		((__loglen(V__fml:j) = indzero) ? True : (__log(V__fml:j, __loglen(V__fml:j)) = __log(V__fml:i, __loglen(V__fml:i))))

Action postconditions:

	ext:commitEntry:
		(forall V038, V139 . (committed(V038, V139) <-> (((V038 = __loglen(V__fml:i)) & (V139 = __log(V__fml:i, __loglen(V__fml:i)))) ? True : __committed(V038, V139))))

	ext:becomeLeader:
		(forall V0 . (currentTerm(V0) = (member(V0, V__fml:q) ? V__fml:newterm : __currentTerm(V0))))
		(forall V0 . (leader(V0) <-> ((V0 = V__fml:i) ? True : (member(V0, V__fml:q) ? False : __leader(V0)))))

	ext:clientRequest:
		(forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:i) & (V1 = V__fml:nextInd)) ? __currentTerm(V__fml:i) : __log(V0, V1))))
		(forall V0 . (loglen(V0) = ((V0 = V__fml:i) ? V__fml:nextInd : __loglen(V0))))

	ext:getEntries:
		(forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:j) & (V1 = V__fml:nextInd)) ? __log(V__fml:i, V__fml:nextInd) : __log(V0, V1))))
		(forall V0 . (loglen(V0) = ((V0 = V__fml:j) ? V__fml:nextInd : __loglen(V0))))

Update map:
	log ->  ext:clientRequest ext:getEntries
	currentTerm ->  ext:becomeLeader
	loglen ->  ext:clientRequest ext:getEntries
	committed ->  ext:commitEntry
	leader ->  ext:becomeLeader

stratifying state variables:
	function arc: server -> term
	function arc: server -> index
	function arc: server -> term
	function arc: index -> term

stratifying axioms:
	skolem arc: quorum -> server

stratifying action ext:commitEntry:

stratifying action ext:clientRequest:

stratifying action ext:getEntries:

stratifying action ext:becomeLeader:

stratifying property:
    pos:
    neg:
	(epr: True)

stratifying helpers:

Arcs:
	index -> term
	quorum -> server
	server -> index term

EPR: True
-----------------------------------------------------------------
	(gen: prefer_epr)
-----------------------------------------------------------------
	(found #4 actions)
adding #4 noops to action ext:commitEntry
	noop(log)
	noop(currentTerm)
	noop(loglen)
	noop(leader)
adding #3 noops to action ext:clientRequest
	noop(currentTerm)
	noop(committed)
	noop(leader)
adding #3 noops to action ext:getEntries
	noop(currentTerm)
	noop(committed)
	noop(leader)
adding #3 noops to action ext:becomeLeader
	noop(log)
	noop(loglen)
	noop(committed)
-----------------------------------------------------------------
Init #1
	((forall V0 . ~__leader(V0)) & (forall V0 . (__currentTerm(V0) = termzero)) & (forall V0 . (__loglen(V0) = indzero)) & (forall V0, V1 . (__log(V0, V1) = termzero)) & (forall V036, V137 . ~__committed(V036, V137)))
		with variables frozenset([indzero, __currentTerm, __loglen, __committed, __leader, __log, termzero])

Axioms #12
	(forall Y, X24 . (~lte(X24, Y) | ~lte(Y, X24) | (X24 = Y)))
		with variables frozenset([lte])
	(forall X33, Y34, Z35 . (succ(X33, Z35) -> (indlt(X33, Z35) & ~(indlt(X33, Y34) & indlt(Y34, Z35)))))
		with variables frozenset([indlt, succ])
	(forall Y, X25 . (lte(X25, Y) | lte(Y, X25)))
		with variables frozenset([lte])
	(forall A, B . ((indlte(A, B) <-> indlt(A, B)) | (A = B)))
		with variables frozenset([indlte, indlt])
	(forall Q1, Q2 . (exists N . (member(N, Q1) & member(N, Q2))))
		with variables frozenset([member])
	(forall X21 . lte(termzero, X21))
		with variables frozenset([lte, termzero])
	(forall X22 . lte(X22, X22))
		with variables frozenset([lte])
	(forall X29 . ~indlt(X29, X29))
		with variables frozenset([indlt])
	(forall X23, Y, Z . (~lte(X23, Y) | ~lte(Y, Z) | lte(X23, Z)))
		with variables frozenset([lte])
	(forall X30, Y31 . (indlt(X30, Y31) | (X30 = Y31) | indlt(Y31, X30)))
		with variables frozenset([indlt])
	(forall Y27, Z28, X26 . ((indlt(X26, Y27) & indlt(Y27, Z28)) -> indlt(X26, Z28)))
		with variables frozenset([indlt])
	(forall X32 . ((X32 = indzero) | indlt(indzero, X32)))
		with variables frozenset([indzero, indlt])

Actions #5
	0:	ext:commitEntry (en: en_ext:commitEntry)	(((forall V038, V139 . (...(..., ...) <-> (... ? ... : ...))) & __leader(V__fml:i) & ~(...(...) = indzero) & member(V__fml:i, V__fml:q) & (forall X . (...(..., ...) -> (... = ...))) & (forall X . (...(..., ...) -> (... & ...)))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([indzero, indlte, __currentTerm, __loglen, V__fml:i, __leader, __log, currentTerm, loglen, committed, leader, log, V__fml:q, __committed, member])
	1:	ext:clientRequest (en: en_ext:clientRequest)	(((forall V0, V1 . (...(..., ...) = (... ? ... : ...))) & (forall V0 . (...(...) = (... ? ... : ...))) & __leader(V__fml:i) & succ(__loglen(V__fml:i), V__fml:nextInd)) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([__currentTerm, __loglen, V__fml:i, V__fml:nextInd, __log, currentTerm, loglen, committed, leader, log, __committed, __leader, succ])
	2:	ext:getEntries (en: en_ext:getEntries)	(((forall V0, V1 . (...(..., ...) = (... ? ... : ...))) & (forall V0 . (...(...) = (... ? ... : ...))) & ~(indzero = ...(...)) & indlt(indzero, __loglen(V__fml:i)) & indlt(__loglen(V__fml:j), __loglen(V__fml:i)) & succ(__loglen(V__fml:j), V__fml:nextInd) & ((...(...) = indzero) ? True : (...(..., ...) = ...(..., ...)))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([__currentTerm, __loglen, __committed, __leader, __log, currentTerm, loglen, committed, leader, log, succ, indzero, indlt, V__fml:i, V__fml:nextInd, V__fml:j])
	3:	ext:becomeLeader (en: en_ext:becomeLeader)	(((forall V0 . (...(...) = (... ? ... : ...))) & (forall V0 . (...(...) <-> (... ? ... : ...))) & ~(V__fml:newterm = termzero) & lte(__currentTerm(V__fml:i), V__fml:newterm) & ~(V__fml:newterm = ...(...)) & member(V__fml:i, V__fml:q) & (forall X . (...(..., ...) -> (... & ...))) & (forall X . (...(..., ...) -> (... | ... | ...)))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))))
		with variables frozenset([__currentTerm, __loglen, __committed, __leader, __log, currentTerm, loglen, committed, leader, log, V__fml:newterm, V__fml:q, member, termzero, indzero, lte, indlt, V__fml:i])
	4:	noop (en: en_noop)	((forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))
		with variables frozenset([__currentTerm, __loglen, __committed, __leader, __log, currentTerm, loglen, committed, leader, log])

Properties #1
	(forall I, T, X . ((__committed(I, T) & __leader(X) & (...(..., ...) & ~...)) -> (__log(X, I) = T)))
		with variables frozenset([lte, __currentTerm, __committed, __leader, __log])

Variables #22
	__currentTerm of type server -> term
	__loglen of type server -> index
	__committed of type index -> term -> Bool
	__leader of type server -> Bool
	__log of type server -> index -> term
	currentTerm of type server -> term
	loglen of type server -> index
	committed of type index -> term -> Bool
	leader of type server -> Bool
	log of type server -> index -> term
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	V__fml:i of type server
	V__fml:nextInd of type index
	V__fml:j of type server
	V__fml:newterm of type term
	V__fml:q of type quorum

State variables #12
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	__currentTerm of type server -> term
	__loglen of type server -> index
	__committed of type index -> term -> Bool
	__leader of type server -> Bool
	__log of type server -> index -> term
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Nex state variables #12
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	currentTerm of type server -> term
	loglen of type server -> index
	committed of type index -> term -> Bool
	leader of type server -> Bool
	log of type server -> index -> term
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Global variables #7
	indzero of type index
	lte of type term -> term -> Bool
	indlte of type index -> index -> Bool
	indlt of type index -> index -> Bool
	member of type server -> quorum -> Bool
	succ of type index -> index -> Bool
	termzero of type term

Ordered variables #0

Nex to pre #5
	log <- __log
	currentTerm <- __currentTerm
	loglen <- __loglen
	committed <- __committed
	leader <- __leader

Pre to nex #5
	__loglen -> loglen
	__committed -> committed
	__leader -> leader
	__log -> log
	__currentTerm -> currentTerm

Other variables #5
	V__fml:i of type server
	V__fml:nextInd of type index
	V__fml:j of type server
	V__fml:q of type quorum
	V__fml:newterm of type term

Axiom variables #7
	indzero
	lte
	indlte
	indlt
	member
	succ
	termzero

Predicates #0

Helpers #0

Inferences #0

Definitions #0

Trel:
((en_ext:commitEntry -> (((forall V038, V139 . (committed(V038, V139) <-> (((V038 = __loglen(V__fml:i)) & (V139 = __log(V__fml:i, __loglen(V__fml:i)))) ? True : __committed(V038, V139)))) & __leader(V__fml:i) & ~(__loglen(V__fml:i) = indzero) & member(V__fml:i, V__fml:q) & (forall X . (member(X, V__fml:q) -> (__currentTerm(X) = __currentTerm(V__fml:i)))) & (forall X . (member(X, V__fml:q) -> (indlte(__loglen(X), __loglen(V__fml:i)) & (__log(X, __loglen(V__fml:i)) = __log(V__fml:i, __loglen(V__fml:i))))))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:clientRequest -> (((forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:i) & (V1 = V__fml:nextInd)) ? __currentTerm(V__fml:i) : __log(V0, V1)))) & (forall V0 . (loglen(V0) = ((V0 = V__fml:i) ? V__fml:nextInd : __loglen(V0)))) & __leader(V__fml:i) & succ(__loglen(V__fml:i), V__fml:nextInd)) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:getEntries -> (((forall V0, V1 . (log(V0, V1) = (((V0 = V__fml:j) & (V1 = V__fml:nextInd)) ? __log(V__fml:i, V__fml:nextInd) : __log(V0, V1)))) & (forall V0 . (loglen(V0) = ((V0 = V__fml:j) ? V__fml:nextInd : __loglen(V0)))) & ~(indzero = __loglen(V__fml:i)) & indlt(indzero, __loglen(V__fml:i)) & indlt(__loglen(V__fml:j), __loglen(V__fml:i)) & succ(__loglen(V__fml:j), V__fml:nextInd) & ((__loglen(V__fml:j) = indzero) ? True : (__log(V__fml:j, __loglen(V__fml:j)) = __log(V__fml:i, __loglen(V__fml:i))))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:becomeLeader -> (((forall V0 . (currentTerm(V0) = (member(V0, V__fml:q) ? V__fml:newterm : __currentTerm(V0)))) & (forall V0 . (leader(V0) <-> ((V0 = V__fml:i) ? True : (member(V0, V__fml:q) ? False : __leader(V0))))) & ~(V__fml:newterm = termzero) & lte(__currentTerm(V__fml:i), V__fml:newterm) & ~(V__fml:newterm = __currentTerm(V__fml:i)) & member(V__fml:i, V__fml:q) & (forall X . (member(X, V__fml:q) -> (lte(__currentTerm(X), V__fml:newterm) & ~(__currentTerm(X) = V__fml:newterm)))) & (forall X . (member(X, V__fml:q) -> ((__loglen(X) = indzero) | ((__log(V__fml:i, __loglen(V__fml:i)) = __log(X, __loglen(X))) & indlt(__loglen(V__fml:i), __loglen(X))) | (lte(__log(X, __loglen(X)), __log(V__fml:i, __loglen(V__fml:i))) & ~(__log(X, __loglen(X)) = __log(V__fml:i, __loglen(V__fml:i)))))))) & (forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))))) & (en_noop -> ((forall 1:server, 2:index . (__log(1:server, 2:index) = log(1:server, 2:index))) & (forall 1:server . (__currentTerm(1:server) = currentTerm(1:server))) & (forall 1:server . (__loglen(1:server) = loglen(1:server))) & (forall 1:index, 2:term . (__committed(1:index, 2:term) <-> committed(1:index, 2:term))) & (forall 1:server . (__leader(1:server) <-> leader(1:server))))) & (en_ext:commitEntry | en_ext:clientRequest | en_ext:getEntries | en_ext:becomeLeader | en_noop) & (~en_ext:commitEntry | ~en_ext:clientRequest) & (~en_ext:commitEntry | ~en_ext:getEntries) & (~en_ext:commitEntry | ~en_ext:becomeLeader) & (~en_ext:commitEntry | ~en_noop) & (~en_ext:clientRequest | ~en_ext:getEntries) & (~en_ext:clientRequest | ~en_ext:becomeLeader) & (~en_ext:clientRequest | ~en_noop) & (~en_ext:getEntries | ~en_ext:becomeLeader) & (~en_ext:getEntries | ~en_noop) & (~en_ext:becomeLeader | ~en_noop))
-----------------------------------------------------------------
(enumsort) index <-> index:e0:
	[ INDEX0, INDEX1, ] <-> [ i0, i1, ]
(enumsort) quorum <-> quorum:e0:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e0:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
(enumsort) term <-> term:e0:
	[ TERM0, TERM1, ] <-> [ t0, t1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
(use_wires: False)

Checking property...

@     4s  Storing init values:
@     4s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlte(i0, i1)
	lte(t0, t0)
	lte(t0, t1)
	lte(t1, t1)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i1, t0)
	~committed(i1, t1)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~lte(t1, t0)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i1, i0)
	~succ(i1, i1)

@     4s  F[0] /\ !P -> UNSAT
@     4s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
@     4s  
Adding frame 1...
@     4s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

@     4s  F[0] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(indzero = i1)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i1) | ~(loglen(s0) = i0))
(relations)
	indzero
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
(antecedent reduction)
@     4s  antecedent: 2 -> 2

(eq map)
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	SERVER0
	INDEX0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = indzero)
(fullsorts)
	index:e0: -> [ INDEX0, indzero, ]
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(original clause)
	(~(indzero = i1) | ~(loglen(s0) = i0))
(learnt sym-boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(clause-type: univ)	(forall S0 . (loglen(S0) = indzero))
@     4s  is global clause? No
@     4s  Learning in F[1]: (forall S0 . (loglen(S0) = indzero))
@     4s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e0 with value True
	inputs:
actionName ext:becomeLeader
		V__fml -> s0
		V__fml:newterm -> t0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i1, t0) = false
	committed(i1, t1) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i1, t0) = false
	committed(i1, t1) = true
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

@     4s  F[0] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[1] unsat core #1 	(ucsz: 1 -> 1)
(minimal unsat core)
	committed(i0, t1)
(clause)
	~committed(i0, t1)
(relations)
	committed
(cube: std)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(original clause)
	~committed(i0, t1)
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(clause-type: univ)	(forall T0, I0 . ~committed(I0, T0))
@     4s  is global clause? No
@     4s  Learning in F[1]: (forall T0, I0 . ~committed(I0, T0))
@     4s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . (loglen(S0) = indzero))
@     4s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #1 to F[2]
@     4s  Learning in F[2]: (forall T0, I0 . ~committed(I0, T0))
@     4s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #3 	(ucsz: 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i1)
	(indzero = i0)
	~succ(i0, i1)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | succ(i0, i1))
(relations)
	indzero
	succ
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	~succ(INDEX0, INDEX1)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@     4s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	~succ(indzero, INDEX1)
(qvars eq)
	INDEX1
	SERVER0
(antecedent eq)
	index:e0:
	-> ~(indzero = INDEX1)
(fullsorts)
	index:e0: -> [ indzero, INDEX1, ]
qv2cubes #2
	indzero -> [ ~succ(indzero, INDEX1), ]
	INDEX1 -> [ ~succ(indzero, INDEX1), (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	indzero -> [ ~succ(V:index:e0:, INDEX1), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e0:), ~succ(indzero, V:index:e0:), ]
ucubes2qv #2
	~succ(V:index:e0:, INDEX1) -> [ indzero, ]
	((loglen(SERVER0) = V:index:e0:) & ~succ(indzero, V:index:e0:)) -> [ INDEX1, ]
(partition) #2 index:e0: -> { indzero, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~succ(indzero, loglen(SERVER0))
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     4s  is global clause? Yes
@     4s  Learning in F[2]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     4s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     4s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s0
		V__fml:nextInd -> i1
@     4s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     4s  F[0] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(log(s1, i0) = t1)
	(termzero = t0)
(clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0))
(relations)
	log
	termzero
(fullsorts)
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@     4s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	TERM1
	SERVER0
	INDEX0
(antecedent eq)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	term:e0: -> [ termzero, TERM1, ]
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER0, INDEX0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(original clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(clause-type: univ)	(forall S0, I0 . (termzero = log(S0, I0)))
@     4s  is global clause? No
@     4s  Learning in F[1]: (forall S0, I0 . (termzero = log(S0, I0)))
@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #3 	(ucsz: 6 -> 3 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i0) = t1)
	(termzero = t0)
	indlt(i0, i1)
(clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0) | ~indlt(i0, i1))
(relations)
	log
	indlt
	termzero
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	indlt(INDEX0, INDEX1)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@     4s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM0 -> termzero
(cube eq)
	indlt(INDEX0, INDEX1)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	TERM1
	INDEX1
	SERVER0
	INDEX0
(antecedent eq)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ termzero, TERM1, ]
qv2cubes #2
	INDEX1 -> [ indlt(INDEX0, INDEX1), ]
	INDEX0 -> [ indlt(INDEX0, INDEX1), (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	INDEX1 -> [ indlt(INDEX0, V:index:e0:), ]
	INDEX0 -> [ (log(SERVER0, V:index:e0:) = TERM1), indlt(V:index:e0:, INDEX1), ]
ucubes2qv #2
	((log(SERVER0, V:index:e0:) = TERM1) & indlt(V:index:e0:, INDEX1)) -> [ INDEX0, ]
	indlt(INDEX0, V:index:e0:) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e0:), ]
ucubes2qv #2
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { termzero, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	indlt(INDEX0, INDEX1)
	~(termzero = log(SERVER0, INDEX0))
(qvars eq: post)
	INDEX1
	SERVER0
	INDEX0
(boosted clause)
	(forall INDEX1, SERVER0, INDEX0 . (~indlt(INDEX0, INDEX1) | (termzero = log(SERVER0, INDEX0))))
---------------------------
(original clause)
	(~(log(s1, i0) = t1) | ~(termzero = t0) | ~indlt(i0, i1))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0, INDEX0 . (~indlt(INDEX0, INDEX1) | (termzero = log(SERVER0, INDEX0))))
---------------------------
(clause-type: univ)	(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     4s  is global clause? Yes
@     4s  Learning in F[2]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     4s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #3 	(ucsz: 8 -> 5 -> 3 -> 3)
(minimal unsat core)
	(loglen(s1) = i1)
	(loglen(s0) = i1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1))
(relations)
	indzero
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
	(loglen(SERVER1) = INDEX1)
(antecedent reduction)
@     4s  antecedent: 4 -> 4

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(loglen(SERVER1) = INDEX1)
(qvars eq)
	INDEX1
	SERVER0
	SERVER1
(antecedent eq)
	index:e0:
	-> ~(indzero = INDEX1)
	server:e0:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	index:e0: -> [ indzero, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	indzero -> [ ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), (loglen(SERVER1) = INDEX1), ]
qv2ucubes #2
	indzero -> [ ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e0:), (loglen(SERVER1) = V:index:e0:), ]
ucubes2qv #2
	true -> [ indzero, ]
	((loglen(SERVER0) = V:index:e0:) & (loglen(SERVER1) = V:index:e0:)) -> [ INDEX1, ]
(partition) #2 index:e0: -> { indzero, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX1), ]
	SERVER1 -> [ (loglen(V:server:e0:) = INDEX1), ]
ucubes2qv #1
	(loglen(V:server:e0:) = INDEX1) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e0: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
(non-epr version)
	(forall INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
@     4s  is global clause? No
@     4s  Learning in F[2]: (exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
@     4s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     4s  F[1] /\ T /\ C+ ?
@     4s  	Ans. UNSAT
@     4s  F[2] unsat core #3 	(ucsz: 6 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i1)
	(log(s1, i1) = t1)
	(termzero = t0)
(clause)
	(~(log(s1, i1) = t1) | ~(loglen(s0) = i1) | ~(termzero = t0))
(relations)
	log
	termzero
	loglen
(fullsorts)
	server:e0: -> [ SERVER0, SERVER1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(termzero = TERM0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@     4s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(qvars eq)
	TERM1
	SERVER0
	SERVER1
	INDEX0
(antecedent eq)
	server:e0:
	-> ~(SERVER0 = SERVER1)
	term:e0:
	-> ~(termzero = TERM1)
(fullsorts)
	server:e0: -> [ SERVER0, SERVER1, ]
	term:e0: -> [ termzero, TERM1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (log(V:server:e0:, INDEX0) = TERM1), ]
ucubes2qv #2
	(log(V:server:e0:, INDEX0) = TERM1) -> [ SERVER1, ]
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, ]
(partition) #2 server:e0: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	termzero -> [ ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e0:), ]
ucubes2qv #2
	true -> [ termzero, ]
	(log(SERVER1, INDEX0) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { termzero, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(termzero = log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (termzero = log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(log(s1, i1) = t1) | ~(loglen(s0) = i1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (termzero = log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
@     4s  is global clause? No
@     4s  Learning in F[2]: (forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
@     4s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0, I0 . (termzero = log(S0, I0)))
		(forall S0 . (loglen(S0) = indzero))
	F[2]: #5
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     4s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #2 to F[3]
@     5s  Learning in F[3]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     5s  Learning in F[3]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     5s  Learning in F[3]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     5s  Learning in F[3]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     5s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e0 with value True
	inputs:
actionName ext:becomeLeader
		V__fml -> s0
		V__fml:newterm -> t0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t1

@     5s  F[2] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[3] unsat core #2 	(ucsz: 3 -> 2 -> 2)
(minimal unsat core)
	committed(i1, t1)
	~succ(i0, i1)
(clause)
	(~committed(i1, t1) | succ(i0, i1))
(relations)
	committed
	succ
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	~succ(INDEX0, INDEX1)
	committed(INDEX1, TERM0)
(antecedent reduction)
@     5s  antecedent: 2 -> 2

qv2cubes #2
	INDEX1 -> [ ~succ(INDEX0, INDEX1), committed(INDEX1, TERM0), ]
	INDEX0 -> [ ~succ(INDEX0, INDEX1), ]
qv2ucubes #2
	INDEX1 -> [ committed(V:index:e0:, TERM0), ~succ(INDEX0, V:index:e0:), ]
	INDEX0 -> [ ~succ(V:index:e0:, INDEX1), ]
ucubes2qv #2
	(committed(V:index:e0:, TERM0) & ~succ(INDEX0, V:index:e0:)) -> [ INDEX1, ]
	~succ(V:index:e0:, INDEX1) -> [ INDEX0, ]
(partition) #2 index:e0: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX0, INDEX1)))
---------------------------
(original clause)
	(~committed(i1, t1) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX0, INDEX1)))
---------------------------
(clause-type: univ)	(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     5s  is global clause? No
@     5s  Learning in F[3]: (forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     5s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

@     5s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s1
		V__fml:nextInd -> i0
@     5s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0			--> modified
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i1			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

@     5s  F[1] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[2] unsat core #4 	(ucsz: 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t0)
	(indzero = i1)
(clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0))
(relations)
	indzero
	log
	currentTerm
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     5s  antecedent: 4 -> 4

(eq map)
	INDEX1 -> indzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	TERM1
	SERVER0
	TERM0
	INDEX0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = indzero)
	term:e0:
	-> ~(TERM0 = TERM1)
(fullsorts)
	index:e0: -> [ INDEX0, indzero, ]
	term:e0: -> [ TERM0, TERM1, ]
qv2cubes #2
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	indzero -> [ ]
	INDEX0 -> [ (log(SERVER0, V:index:e0:) = TERM0), (loglen(SERVER0) = V:index:e0:), ]
ucubes2qv #2
	true -> [ indzero, ]
	((log(SERVER0, V:index:e0:) = TERM0) & (loglen(SERVER0) = V:index:e0:)) -> [ INDEX0, ]
(partition) #2 index:e0: -> { indzero, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e0:), ]
ucubes2qv #2
	(currentTerm(SERVER0) = V:term:e0:) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e0:) -> [ TERM0, ]
(partition) #2 term:e0: -> { TERM1, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
	~(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | (loglen(SERVER0) = indzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0))
(learnt sym-boosted clause)
	(forall SERVER0 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | (loglen(SERVER0) = indzero)))
---------------------------
(clause-type: univ)	(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (loglen(S0) = indzero)))
@     5s  is global clause? No
@     5s  Learning in F[2]: (forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (loglen(S0) = indzero)))
@     5s  F[2] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[3] unsat core #4 	(ucsz: 12 -> 11 -> 10 -> 9 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	(log(s1, i0) = t1)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0))
(relations)
	log
	currentTerm
	loglen
(fullsorts)
	server:e0: -> [ SERVER0, SERVER1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     5s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (currentTerm(V:server:e0:) = TERM1), (log(V:server:e0:, INDEX0) = TERM0), (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (log(V:server:e0:, INDEX0) = TERM1), ]
ucubes2qv #2
	(log(V:server:e0:, INDEX0) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e0:) = TERM1) & (log(V:server:e0:, INDEX0) = TERM0) & (loglen(V:server:e0:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e0: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e0:), (log(SERVER1, INDEX0) = V:term:e0:), ]
ucubes2qv #2
	(log(SERVER0, INDEX0) = V:term:e0:) -> [ TERM0, ]
	((currentTerm(SERVER0) = V:term:e0:) & (log(SERVER1, INDEX0) = V:term:e0:)) -> [ TERM1, ]
(partition) #2 term:e0: -> { TERM0, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER0))
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER0)) | (log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER0)) | (log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((log(S1, loglen(S0)) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@     5s  is global clause? No
@     5s  Learning in F[3]: (forall S0, S1 . ((log(S1, loglen(S0)) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
@     5s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

@     5s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s0
		V__fml:nextInd -> i0
@     5s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

@     5s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s1
		V__fml:nextInd -> i0
@     5s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0			--> modified
	log(s1, i1) = t0
	loglen(s0) = i1
	loglen(s1) = i1			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	termzero = t0

@     5s  F[0] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[1] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(currentTerm(s0) = t0)
	leader(s0)
	(termzero = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	termzero
	leader
	currentTerm
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  is global clause? Yes
@     5s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  F[1] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[2] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(currentTerm(s0) = t0)
	leader(s0)
	(termzero = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	termzero
	leader
	currentTerm
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  is global clause? Yes
@     5s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  F[2] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[3] unsat core #3 	(ucsz: 6 -> 3 -> 3)
(minimal unsat core)
	(currentTerm(s0) = t0)
	leader(s0)
	(termzero = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(relations)
	termzero
	leader
	currentTerm
(cube: std)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
(antecedent eq)
(boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  is global clause? Yes
@     5s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     5s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e0 with value True
	inputs:
actionName ext:becomeLeader
		V__fml -> s0
		V__fml:newterm -> t1
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     5s  F[2] /\ T /\ C+ ?
@     5s  	Ans. UNSAT
@     5s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(termzero = t0)
	committed(i1, t0)
(clause)
	(~(termzero = t0) | ~committed(i1, t0))
(relations)
	termzero
	committed
(cube: std)
	committed(INDEX0, TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
(antecedent eq)
(boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(original clause)
	(~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall INDEX0 . ~committed(INDEX0, termzero))
---------------------------
(clause-type: univ)	(forall I0 . ~committed(I0, termzero))
@     5s  is global clause? No
@     5s  Learning in F[3]: (forall I0 . ~committed(I0, termzero))
@     5s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0, I0 . (termzero = log(S0, I0)))
		(forall S0 . (loglen(S0) = indzero))
	F[2]: #4
		(forall T0, I0 . ~committed(I0, T0))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (loglen(S0) = indzero)))
		(forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
	F[3]: #6
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . ((log(S1, loglen(S0)) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0 . ~committed(I0, termzero))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     5s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #4 to F[4]
@     6s  Learning in F[4]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     6s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     6s  Learning in F[4]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     6s  Learning in F[4]: (forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     6s  Learning in F[4]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     6s  Learning in F[4]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     6s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     6s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e0 with value True
	inputs:
actionName ext:becomeLeader
		V__fml -> s0
		V__fml:newterm -> t1
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[3] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[4] unsat core #3 	(ucsz: 6 -> 3 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	committed(i1, t0)
	~indlte(i1, i1)
(clause)
	(~(termzero = t0) | ~committed(i1, t0) | indlte(i1, i1))
(relations)
	indlte
	termzero
	committed
(cube: std)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, TERM0)
	(termzero = TERM0)

(eq map)
	TERM0 -> termzero
(cube eq)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, termzero)
(qvars eq)
	INDEX0
(antecedent eq)
(boosted clause)
	(forall INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, termzero)))
---------------------------
(original clause)
	(~(termzero = t0) | ~committed(i1, t0) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, termzero)))
---------------------------
(clause-type: univ)	(forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
@     6s  is global clause? Yes
@     6s  Learning in F[4]: (forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
@     6s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s0
		V__fml:nextInd -> i1
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[3] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[4] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(termzero = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	committed(i1, t0)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(relations)
	termzero
	committed
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@     6s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, termzero)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	INDEX1
	SERVER0
	SERVER1
	INDEX0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = INDEX1)
	server:e0:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	INDEX1 -> [ committed(INDEX1, termzero), ]
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	INDEX1 -> [ committed(V:index:e0:, termzero), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e0:), (loglen(SERVER0) = V:index:e0:), ]
ucubes2qv #2
	((loglen(SERVER0) = V:index:e0:) & (loglen(SERVER1) = V:index:e0:)) -> [ INDEX0, ]
	committed(V:index:e0:, termzero) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e0:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e0: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
(non-epr version)
	(forall INDEX1, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I1, I0 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
@     6s  is global clause? No
@     6s  Learning in F[4]: (exists S0 . (forall I1, I0 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
@     6s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s0
		V__fml:nextInd -> i1
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[3] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[4] unsat core #5 	(ucsz: 5 -> 5)
(minimal unsat core)
	~member(s1, q1)
	(termzero = t0)
	(loglen(s0) = i0)
	committed(i1, t0)
	~member(s1, q0)
(clause)
	(~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | member(s1, q0) | member(s1, q1))
(relations)
	termzero
	loglen
	committed
	member
(fullsorts)
	quorum:e0: -> [ QUORUM0, QUORUM1, ]
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	(termzero = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	~member(SERVER1, QUORUM1)
(antecedent reduction)
@     6s  antecedent: 6 -> 6

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, termzero)
	~member(SERVER1, QUORUM0)
	(loglen(SERVER0) = INDEX0)
	~member(SERVER1, QUORUM1)
(qvars eq)
	INDEX0
	INDEX1
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(antecedent eq)
	quorum:e0:
	-> ~(QUORUM0 = QUORUM1)
	index:e0:
	-> ~(INDEX0 = INDEX1)
	server:e0:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	quorum:e0: -> [ QUORUM0, QUORUM1, ]
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	QUORUM0 -> [ ~member(SERVER1, QUORUM0), ]
	QUORUM1 -> [ ~member(SERVER1, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER1, V:quorum:e0:), ]
	QUORUM1 -> [ ~member(SERVER1, V:quorum:e0:), ]
ucubes2qv #1
	~member(SERVER1, V:quorum:e0:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e0: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
qv2cubes #2
	INDEX1 -> [ committed(INDEX1, termzero), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	INDEX1 -> [ committed(V:index:e0:, termzero), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e0:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e0:) -> [ INDEX0, ]
	committed(V:index:e0:, termzero) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ ~member(V:server:e0:, QUORUM0), ]
ucubes2qv #2
	~member(V:server:e0:, QUORUM0) -> [ SERVER1, ]
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, ]
(partition) #2 server:e0: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall INDEX1, SERVER0, SERVER1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0))))
(non-epr version)
	(forall INDEX1, SERVER0, SERVER1, INDEX0 . (exists QUORUM0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall INDEX1, SERVER0, SERVER1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | member(s1, q0) | member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall INDEX1, SERVER0, SERVER1, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall I1, S0, S1, I0 . (((loglen(S0) = I0) & committed(I1, termzero)) -> ((I0 = I1) | (S0 = S1) | member(S1, Q0)))))
@     6s  is global clause? No
@     6s  Learning in F[4]: (exists Q0 . (forall I1, S0, S1, I0 . (((loglen(S0) = I0) & committed(I1, termzero)) -> ((I0 = I1) | (S0 = S1) | member(S1, Q0)))))
@     6s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e0 with value True
	inputs:
actionName ext:clientRequest
		V__fml -> s0
		V__fml:nextInd -> i1
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s1
		V__fml:q -> q0
@     6s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[2] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[3] unsat core #6 	(ucsz: 15 -> 12 -> 11 -> 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s1) = i1)
	(loglen(s0) = i0)
	indlt(i0, i1)
	(currentTerm(s1) = t1)
	(log(s1, i1) = t0)
	leader(s1)
(clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~indlt(i0, i1) | ~leader(s1))
(relations)
	loglen
	log
	indlt
	currentTerm
	leader
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	leader(SERVER1)
	(log(SERVER1, INDEX1) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	(loglen(SERVER0) = INDEX0)
	indlt(INDEX0, INDEX1)
	(loglen(SERVER1) = INDEX1)
(antecedent reduction)
@     6s  antecedent: 6 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	INDEX1 -> [ indlt(INDEX0, INDEX1), (log(SERVER1, INDEX1) = TERM0), (loglen(SERVER1) = INDEX1), ]
	INDEX0 -> [ indlt(INDEX0, INDEX1), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	INDEX1 -> [ (loglen(SERVER1) = V:index:e0:), (log(SERVER1, V:index:e0:) = TERM0), indlt(INDEX0, V:index:e0:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e0:), indlt(V:index:e0:, INDEX1), ]
ucubes2qv #2
	((log(SERVER1, V:index:e0:) = TERM0) & (loglen(SERVER1) = V:index:e0:) & indlt(INDEX0, V:index:e0:)) -> [ INDEX1, ]
	((loglen(SERVER0) = V:index:e0:) & indlt(V:index:e0:, INDEX1)) -> [ INDEX0, ]
(partition) #2 index:e0: -> { INDEX1, | INDEX0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ leader(SERVER1), (log(SERVER1, INDEX1) = TERM0), (currentTerm(SERVER1) = TERM1), (loglen(SERVER1) = INDEX1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e0:) = INDEX0), ]
	SERVER1 -> [ (currentTerm(V:server:e0:) = TERM1), leader(V:server:e0:), (loglen(V:server:e0:) = INDEX1), (log(V:server:e0:, INDEX1) = TERM0), ]
ucubes2qv #2
	((currentTerm(V:server:e0:) = TERM1) & (log(V:server:e0:, INDEX1) = TERM0) & (loglen(V:server:e0:) = INDEX1) & leader(V:server:e0:)) -> [ SERVER1, ]
	(loglen(V:server:e0:) = INDEX0) -> [ SERVER0, ]
(partition) #2 server:e0: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER1, INDEX1) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER1, INDEX1) = V:term:e0:), ]
	TERM1 -> [ (currentTerm(SERVER1) = V:term:e0:), ]
ucubes2qv #2
	(log(SERVER1, INDEX1) = V:term:e0:) -> [ TERM0, ]
	(currentTerm(SERVER1) = V:term:e0:) -> [ TERM1, ]
(partition) #2 term:e0: -> { TERM0, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER1, loglen(SERVER1))
	TERM1 -> currentTerm(SERVER1)
	INDEX1 -> loglen(SERVER1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))
	leader(SERVER1)
	indlt(loglen(SERVER0), loglen(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | ~leader(SERVER1) | ~indlt(loglen(SERVER0), loglen(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~indlt(i0, i1) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | ~leader(SERVER1) | ~indlt(loglen(SERVER0), loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     6s  is global clause? Yes
@     6s  Learning in F[4]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     6s  F[3] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     6s  F[4] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t0)
	(loglen(s0) = i0)
	committed(i1, t0)
(clause)
	(~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(relations)
	termzero
	committed
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
(cube: std)
	(termzero = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@     6s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, termzero)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	INDEX1
	SERVER0
	INDEX0
(antecedent eq)
	index:e0:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
qv2cubes #2
	INDEX1 -> [ committed(INDEX1, termzero), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	INDEX1 -> [ committed(V:index:e0:, termzero), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e0:), ]
ucubes2qv #2
	(loglen(SERVER0) = V:index:e0:) -> [ INDEX0, ]
	committed(V:index:e0:, termzero) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, termzero)
	~(loglen(SERVER0) = INDEX1)
(qvars eq: post)
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(clause-type: univ)	(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
@     6s  is global clause? No
@     6s  Learning in F[4]: (forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
@     6s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e0 with value True
	inputs:
actionName ext:commitEntry
		V__fml -> s0
		V__fml:q -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	termzero = t0

@     6s  F[3] /\ T /\ C+ ?
@     6s  	Ans. UNSAT
@     7s  F[4] unsat core #5 	(ucsz: 16 -> 14 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i1)
	leader(s0)
	(log(s1, i1) = t1)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(log(s1, i1) = t1) | ~(loglen(s0) = i1) | ~leader(s0))
(relations)
	log
	leader
	loglen
(fullsorts)
	index:e0: -> [ INDEX0, INDEX1, ]
	server:e0: -> [ SERVER0, SERVER1, ]
	term:e0: -> [ TERM0, TERM1, ]
(cube: std)
	leader(SERVER0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX1) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@     7s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), (log(SERVER1, INDEX1) = TERM1), (log(SERVER0, INDEX1) = TERM0), ]
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	INDEX1 -> [ (log(SERVER0, V:index:e0:) = TERM0), (loglen(SERVER0) = V:index:e0:), (log(SERVER1, V:index:e0:) = TERM1), ]
	INDEX0 -> [ (log(SERVER0, V:index:e0:) = TERM0), ]
ucubes2qv #2
	(log(SERVER0, V:index:e0:) = TERM0) -> [ INDEX0, ]
	((log(SERVER0, V:index:e0:) = TERM0) & (log(SERVER1, V:index:e0:) = TERM1) & (loglen(SERVER0) = V:index:e0:)) -> [ INDEX1, ]
(partition) #2 index:e0: -> { INDEX0, | INDEX1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e0:, INDEX0) = TERM0), (loglen(V:server:e0:) = INDEX1), leader(V:server:e0:), (log(V:server:e0:, INDEX1) = TERM0), ]
	SERVER1 -> [ (log(V:server:e0:, INDEX1) = TERM1), ]
ucubes2qv #2
	(log(V:server:e0:, INDEX1) = TERM1) -> [ SERVER1, ]
	((log(V:server:e0:, INDEX0) = TERM0) & (log(V:server:e0:, INDEX1) = TERM0) & (loglen(V:server:e0:) = INDEX1) & leader(V:server:e0:)) -> [ SERVER0, ]
(partition) #2 server:e0: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e0:), (log(SERVER0, INDEX1) = V:term:e0:), ]
	TERM1 -> [ (log(SERVER1, INDEX1) = V:term:e0:), ]
ucubes2qv #2
	(log(SERVER1, INDEX1) = V:term:e0:) -> [ TERM1, ]
	((log(SERVER0, INDEX0) = V:term:e0:) & (log(SERVER0, INDEX1) = V:term:e0:)) -> [ TERM0, ]
(partition) #2 term:e0: -> { TERM1, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER0))
(cube eq: post)
	leader(SERVER0)
	~(INDEX0 = loglen(SERVER0))
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))
	(log(SERVER0, INDEX0) = log(SERVER0, loglen(SERVER0)))
(qvars eq: post)
	INDEX0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER0) | (INDEX0 = loglen(SERVER0)) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0))) | ~(log(SERVER0, INDEX0) = log(SERVER0, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(log(s1, i1) = t1) | ~(loglen(s0) = i1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER0) | (INDEX0 = loglen(SERVER0)) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0))) | ~(log(SERVER0, INDEX0) = log(SERVER0, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     7s  is global clause? No
@     7s  Learning in F[4]: (forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     7s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0, I0 . (termzero = log(S0, I0)))
		(forall S0 . (loglen(S0) = indzero))
	F[2]: #4
		(forall T0, I0 . ~committed(I0, T0))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (loglen(S0) = indzero)))
		(forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
	F[3]: #2
		(forall I0 . ~committed(I0, termzero))
		(forall S0, S1 . ((log(S1, loglen(S0)) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
	F[4]: #8
		(forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     7s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #8 to F[5]
@     7s  Learning in F[5]: (forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
@     7s  Learning in F[5]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     7s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     7s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     7s  Learning in F[5]: (forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
@     7s  Learning in F[5]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     7s  Learning in F[5]: (forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     7s  Learning in F[5]: (forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     7s  Learning in F[5]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     7s  Learning in F[5]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     7s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     7s  Learning in F[5]: (forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
@     7s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     7s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S0 . ~leader(S0)) & (forall S0 . (currentTerm(S0) = termzero)) & (forall S0 . (loglen(S0) = indzero)) & (forall S0, I0 . (log(S0, I0) = termzero)) & (forall I0_1, T0 . ~committed(I0_1, T0)))
	F[1]: #2
		(forall S0, I0 . (termzero = log(S0, I0)))
		(forall S0 . (loglen(S0) = indzero))
	F[2]: #4
		(forall T0, I0 . ~committed(I0, T0))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S0 . ((log(S0, loglen(S0)) = currentTerm(S0)) | (loglen(S0) = indzero)))
		(forall S0, S1 . ((S0 = S1) | (termzero = log(S1, loglen(S0)))))
	F[3]: #2
		(forall I0 . ~committed(I0, termzero))
		(forall S0, S1 . ((log(S1, loglen(S0)) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))))
	F[4]: #0
	F[5]: #8
		(forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     7s  
Adding frame 6...
@     7s  F[4] converged!
Explored 7 frames
@     7s  -------------------------------------------------
### Invariant: #9
invariant [global1]	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
invariant [global4]	(forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global2]	(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
invariant [prop1]	(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0) & (lte(T0, currentTerm(S0)) & ~(T0 = currentTerm(S0)))) -> (log(S0, I0) = T0)))
invariant [other3]	(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other2]	(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
invariant [other1]	(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other3 -> UNSAT
	#2 global4 -> UNSAT
	#3 global4_1 -> UNSAT
	#4 other1 -> UNSAT
	#5 global2 -> UNSAT
	#6 prop1  (property) -> UNSAT
	#7 global5 -> UNSAT
	#8 other2 -> UNSAT
	#9 global1 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other3 -> UNSAT
	#2 global4 -> UNSAT
	#3 global4_1 -> UNSAT
	#4 other1 -> UNSAT
	#5 global2 -> UNSAT
	#6 prop1  (property) -> UNSAT
	#7 global5 -> UNSAT
	#8 other2 -> UNSAT
	#9 global1 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e0: -> [`index:e0:0`, `index:e0:1`]
	term -> term:e0: -> [`term:e0:0`, `term:e0:1`]
	quorum -> quorum:e0: -> [`quorum:e0:0`, `quorum:e0:1`]
	server -> server:e0: -> [`server:e0:0`, `server:e0:1`]

Invariant is a proof certificate
@     7s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e0, T:e0, X:e0 . ((__committed:e0(I:e0, T:e0) & __leader:e0(X:e0) & (...(..., ...) & ~...)) -> (__log:e0(X:e0, I:e0) = T:e0)))
raw invariant [global1] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . (~...(..., ...) & ~(... = ...)))
raw invariant [global4] (cost: 1, 1F, 0E) 	~(exists Q:index:e0:0 . (~...(..., ...) & __committed:e0(Q:index:e0:0, termzero:e0)))
raw invariant [global4_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e0:0 . (__leader:e0(Q:server:e0:0) & (...(...) = termzero:e0)))
raw invariant [global2] (cost: 3, 3F, 0E) 	~(exists Q:index:e0:1, Q:server:e0:0, Q:index:e0:0 . (indlt:e0(Q:index:e0:0, Q:index:e0:1) & ~(... = ...)))
raw invariant [other3] (cost: 3, 3F, 0E) 	~(exists Q:index:e0:0, Q:server:e0:0, Q:server:e0:1 . (__leader:e0(Q:server:e0:0) & ~(... = ...) & ~(... = ...) & (...(..., ...) = ...(..., ...))))
raw invariant [global5] (cost: 2, 2F, 0E) 	~(exists Q:server:e0:0, Q:server:e0:1 . (~(... = ...) & __leader:e0(Q:server:e0:1) & indlt:e0(...(...), ...(...))))
raw invariant [other2] (cost: 3, 3F, 0E) 	~(exists Q:index:e0:1, Q:term:e0:0, Q:index:e0:0 . (__committed:e0(Q:index:e0:1, Q:term:e0:0) & ~(... = ...) & ~...(..., ...)))
raw invariant [other1] (cost: 2, 2F, 0E) 	~(exists Q:index:e0:1, Q:server:e0:0 . (__committed:e0(Q:index:e0:1, termzero:e0) & ~(... = ...)))
@     7s  Minimizing certificate of size 9
@     7s  	prop1	(cost: 3) -> property
@     7s  	global2	(cost: 3) -> add
@     7s  	other3	(cost: 3) -> add
@     7s  	other2	(cost: 3) -> add
@     8s  	global5	(cost: 2) -> add
@     8s  	other1	(cost: 2) -> add
@     8s  	global1	(cost: 1) -> add
@     8s  	global4	(cost: 1) -> remove
@     8s  	global4_1	(cost: 1) -> add
	Minimized certificate: 9 -> 8
@     8s  -------------------------------------------------
### Proof certificate (required): #8
invariant [prop1]	(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0) & (lte(T0, currentTerm(S0)) & ~(T0 = currentTerm(S0)))) -> (log(S0, I0) = T0)))
invariant [global2]	(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
invariant [other3]	(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
invariant [other2]	(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other1]	(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
invariant [global1]	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###

### Optional invariants: #1
invariant [global4_optional]	(forall I0 . (committed(I0, termzero) -> indlte(I0, I0)))
###

	random:	0
	scalls:	290
	scalls-finite:	290
	scalls-infinite:	0
	scalls-finite-full:	290
	cti:	20
	cubes:	21
	subsumed-calls:	189
	subsumed-subset:	0
	subsumed-varintersect-c:	183
	subsumed-varintersect-e:	0
	subsumed-query-sat:	4
	subsumed-query-unsat:	2
	subsumed-eq:	27
	unsat-core:	34
	sz-unsat-core-avg:	4.97
	sz-unsat-min-avg:	3.12
	sz-cube-avg:	36.00
	antecedent-reduction-sum:	10
	antecedent-total-sum:	52
	antecedent-reduction-avg:	0.19
	antecedent-calls:	14
	antecedent-calls-reduced:	4
	antecedent-scalls:	66
	time-q-max-finite-ms:	30
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	0
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	0
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	1
	time-forward:	0
	time-antecedent:	1
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	0
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	1
	time-qf:	0
	time-sum:	4
@     8s  -------------------------------------------------
@     8s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@     8s  (finite convergence checks)
@     8s  (performing finite convergence checks for index)
(enumsort) index <-> index:e1:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e1:
	[ TERM0, TERM1, ] <-> [ t0, t1, ]
(enumsort) quorum <-> quorum:e1:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e1:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[t0] = 0
	dep_height[t1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[i0] = 300
	dep_height[i1] = 301
	dep_height[i2] = 302
(use_wires: False)
@     8s  -------------------------------------------------
### Invariant: #8
invariant [global1]	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
invariant [other3]	(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [prop1]	(forall I1, T1, S1 . ((committed(I1, T1) & leader(S1) & (lte(T1, currentTerm(S1)) & ~(T1 = currentTerm(S1)))) -> (log(S1, I1) = T1)))
invariant [other1]	(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [global2]	(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
invariant [other2]	(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global1 -> UNSAT
	#2 other3 -> UNSAT
	#3 global4_1 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other1 -> UNSAT
	#6 global5 -> UNSAT
	#7 global2 -> UNSAT
	#8 other2 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global1 -> SAT
	#2 other3 -> SAT
	#3 global4_1 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other1 -> UNSAT
	#6 global5 -> UNSAT
	#7 global2 -> SAT
	#8 other2 -> SAT
	Inv_all /\ T /\ !Inv+: 4 failed

Finite sorts: #4
	index -> index:e1: -> [`index:e1:0`, `index:e1:1`, `index:e1:2`]
	term -> term:e1: -> [`term:e1:0`, `term:e1:1`]
	quorum -> quorum:e1: -> [`quorum:e1:0`, `quorum:e1:1`]
	server -> server:e1: -> [`server:e1:0`, `server:e1:1`]

Invariant is not a proof certificate
@     8s  -------------------------------------------------
@     8s  (extended |index| to 3)
@     8s  (finite convergence checks failed for index)
(enumsort) index <-> index:e2:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e2:
	[ TERM0, TERM1, ] <-> [ t0, t1, ]
(enumsort) quorum <-> quorum:e2:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e2:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@     8s  -------------------------------------------------
### Checking reusability of clauses: #7
invariant [global2]	(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [global1]	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other3]	(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
invariant [other2]	(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
invariant [other1]	(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
###

Checking Init /\ !Inv:
	#1 global2 -> UNSAT
	#2 global5 -> UNSAT
	#3 global1 -> UNSAT
	#4 global4_1 -> UNSAT
	#5 other3 -> UNSAT
	#6 other2 -> UNSAT
	#7 other1 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 global2 -> UNSAT
	#2 global5 -> UNSAT
	#3 global1 -> UNSAT
	#4 global4_1 -> UNSAT
	#5 other3 -> UNSAT
	#6 other2 -> UNSAT
	#7 other1 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 7 -> 7 (0 + 0 failed)
All clauses reusable
@     9s  -------------------------------------------------
	random:	0
	scalls:	322
	scalls-finite:	308
	scalls-infinite:	14
	scalls-finite-full:	308
	cti:	20
	cubes:	21
	subsumed-calls:	189
	subsumed-subset:	0
	subsumed-varintersect-c:	183
	subsumed-varintersect-e:	0
	subsumed-query-sat:	4
	subsumed-query-unsat:	2
	subsumed-eq:	27
	unsat-core:	34
	sz-unsat-core-avg:	4.97
	sz-unsat-min-avg:	3.12
	sz-cube-avg:	36.00
	antecedent-reduction-sum:	10
	antecedent-total-sum:	52
	antecedent-reduction-avg:	0.19
	antecedent-calls:	14
	antecedent-calls-reduced:	4
	antecedent-scalls:	66
	time-q-max-finite-ms:	30
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	5
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	0
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	1
	time-forward:	0
	time-antecedent:	1
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	0
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	1
	time-qf:	0
	time-sum:	4
@     9s  -------------------------------------------------
@     9s  -------------------------------------------------
@     9s  (incremental SymIC3)
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[s0] = 200
	dep_height[s1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
(use_wires: False)

Checking property...

@     9s  Storing init values:
@     9s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s0, i2) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(log(s1, i2) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i1, i2)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i1, i2)
	lte(t0, t0)
	lte(t0, t1)
	lte(t1, t1)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i2, t0)
	~committed(i2, t1)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i2, i0)
	~indlt(i2, i1)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i2, i0)
	~indlte(i2, i1)
	~indlte(i2, i2)
	~lte(t1, t0)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@     9s  F[0] /\ !P -> UNSAT
@     9s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
@     9s  
Adding frame 1...
@     9s  Is F[0] -> global5? -> UNSAT
@     9s  Is global5 inductive? -> UNSAT
@     9s  Is F[0] -> global2? -> UNSAT
@     9s  Is global2 inductive? -> SAT
@     9s  Is F[0] /\ T -> global2+? -> UNSAT
@     9s  Learning in F[1]: (forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
@     9s  Is F[0] -> other1? -> UNSAT
@     9s  Is other1 inductive? -> SAT
@     9s  Is F[0] /\ T -> other1+? -> UNSAT
@     9s  Learning in F[1]: (forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
@     9s  Is F[0] -> other2? -> UNSAT
@     9s  Is other2 inductive? -> SAT
@     9s  Is F[0] /\ T -> other2+? -> UNSAT
@     9s  Learning in F[1]: (forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
@     9s  Is F[0] -> global1? -> UNSAT
@     9s  Is global1 inductive? -> SAT
@     9s  Is F[0] /\ T -> global1+? -> UNSAT
@     9s  Learning in F[1]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@     9s  Is F[0] -> other3? -> UNSAT
@     9s  Is other3 inductive? -> SAT
@     9s  Is F[0] /\ T -> other3+? -> UNSAT
@     9s  Learning in F[1]: (forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@     9s  Is F[0] -> global4_1? -> UNSAT
@     9s  Is global4_1 inductive? -> UNSAT
Seeded 7 (global: 2, init: 5) helpers out of 7
@     9s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     9s  Learning in F[1]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     9s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
	F[1]: #7
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     9s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #3 to F[2]
@     9s  Learning in F[2]: (forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
@     9s  Learning in F[2]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     9s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     9s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@     9s  Learning in F[2]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@     9s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e3 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1 -> q0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@     9s  F[1] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[2] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(log(s1, i0) = t0)
	(loglen(s1) = i2)
	indlt(i0, i2)
	(termzero = t1)
(clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i2) | ~(termzero = t1) | ~indlt(i0, i2))
(relations)
	loglen
	termzero
	indlt
	log
(fullsorts)
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	indlt(INDEX0, INDEX1)
	(termzero = TERM1)
	(loglen(SERVER0) = INDEX1)
(antecedent reduction)
@     9s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	indlt(INDEX0, INDEX1)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	TERM0
	SERVER0
	INDEX1
	INDEX0
(antecedent eq)
	term:e2:
	-> ~(TERM0 = termzero)
(fullsorts)
	term:e2: -> [ TERM0, termzero, ]
qv2cubes #2
	termzero -> [ ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	termzero -> [ ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e2:), ]
ucubes2qv #2
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e2:) -> [ TERM0, ]
(partition) #2 term:e2: -> { termzero, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	indlt(INDEX0, loglen(SERVER0))
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (~indlt(INDEX0, loglen(SERVER0)) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i2) | ~(termzero = t1) | ~indlt(i0, i2))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (~indlt(INDEX0, loglen(SERVER0)) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
@     9s  is global clause? No
@     9s  Learning in F[2]: (forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
@     9s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e3 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1 -> t0
		V__fml:q:e1 -> q0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@     9s  F[1] /\ T /\ C+ ?
@     9s  	Ans. UNSAT
@     9s  F[2] unsat core #2 	(ucsz: 5 -> 4 -> 3 -> 2 -> 2)
(minimal unsat core)
	committed(i0, t0)
	(log(s0, i0) = t1)
(clause)
	(~(log(s0, i0) = t1) | ~committed(i0, t0))
(relations)
	log
	committed
(fullsorts)
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	committed(INDEX0, TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@    10s  antecedent: 2 -> 2

qv2cubes #2
	TERM0 -> [ committed(INDEX0, TERM0), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ committed(INDEX0, V:term:e2:), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e2:), ]
ucubes2qv #2
	(log(SERVER0, INDEX0) = V:term:e2:) -> [ TERM1, ]
	committed(INDEX0, V:term:e2:) -> [ TERM0, ]
(partition) #2 term:e2: -> { TERM1, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(TERM0 = log(SERVER0, INDEX0))
	committed(INDEX0, TERM0)
(qvars eq: post)
	SERVER0
	TERM0
	INDEX0
(boosted clause)
	(forall SERVER0, TERM0, INDEX0 . ((TERM0 = log(SERVER0, INDEX0)) | ~committed(INDEX0, TERM0)))
---------------------------
(original clause)
	(~(log(s0, i0) = t1) | ~committed(i0, t0))
(learnt sym-boosted clause)
	(forall SERVER0, TERM0, INDEX0 . ((TERM0 = log(SERVER0, INDEX0)) | ~committed(INDEX0, TERM0)))
---------------------------
(clause-type: univ)	(forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
@    10s  is global clause? No
@    10s  Learning in F[2]: (forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
@    10s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e3 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1 -> q0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false			--> modified
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    10s  F[1] /\ T /\ C+ ?
@    10s  	Ans. UNSAT
@    10s  F[2] unsat core #4 	(ucsz: 9 -> 6 -> 4 -> 4)
(minimal unsat core)
	~succ(i0, i2)
	(termzero = t1)
	indlt(i2, i1)
	(log(s1, i2) = t0)
(clause)
	(~(log(s1, i2) = t0) | ~(termzero = t1) | ~indlt(i2, i1) | succ(i0, i2))
(relations)
	indlt
	termzero
	succ
	log
(fullsorts)
	term:e2: -> [ TERM0, TERM1, ]
	index:e2: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(termzero = TERM1)
	indlt(INDEX2, INDEX1)
	(log(SERVER0, INDEX2) = TERM0)
	~succ(INDEX0, INDEX2)
(antecedent reduction)
@    10s  antecedent: 5 -> 5

(eq map)
	TERM1 -> termzero
(cube eq)
	~succ(INDEX0, INDEX2)
	indlt(INDEX2, INDEX1)
	(log(SERVER0, INDEX2) = TERM0)
(qvars eq)
	INDEX0
	INDEX1
	INDEX2
	TERM0
	SERVER0
(antecedent eq)
	term:e2:
	-> ~(TERM0 = termzero)
	index:e2:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	term:e2: -> [ TERM0, termzero, ]
	index:e2: -> [ INDEX0, INDEX1, INDEX2, ]
qv2cubes #2
	termzero -> [ ]
	TERM0 -> [ (log(SERVER0, INDEX2) = TERM0), ]
qv2ucubes #2
	termzero -> [ ]
	TERM0 -> [ (log(SERVER0, INDEX2) = V:term:e2:), ]
ucubes2qv #2
	true -> [ termzero, ]
	(log(SERVER0, INDEX2) = V:term:e2:) -> [ TERM0, ]
(partition) #2 term:e2: -> { termzero, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #3
	INDEX2 -> [ ~succ(INDEX0, INDEX2), indlt(INDEX2, INDEX1), (log(SERVER0, INDEX2) = TERM0), ]
	INDEX0 -> [ ~succ(INDEX0, INDEX2), ]
	INDEX1 -> [ indlt(INDEX2, INDEX1), ]
qv2ucubes #3
	INDEX2 -> [ indlt(V:index:e2:, INDEX1), (log(SERVER0, V:index:e2:) = TERM0), ~succ(INDEX0, V:index:e2:), ]
	INDEX0 -> [ ~succ(V:index:e2:, INDEX2), ]
	INDEX1 -> [ indlt(INDEX2, V:index:e2:), ]
ucubes2qv #3
	indlt(INDEX2, V:index:e2:) -> [ INDEX1, ]
	((log(SERVER0, V:index:e2:) = TERM0) & indlt(V:index:e2:, INDEX1) & ~succ(INDEX0, V:index:e2:)) -> [ INDEX2, ]
	~succ(V:index:e2:, INDEX2) -> [ INDEX0, ]
(partition) #3 index:e2: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX2)
(cube eq: post)
	~(INDEX0 = INDEX1)
	~(INDEX0 = INDEX2)
	~(INDEX1 = INDEX2)
	~succ(INDEX0, INDEX2)
	indlt(INDEX2, INDEX1)
	~(log(SERVER0, INDEX2) = termzero)
(qvars eq: post)
	INDEX2
	INDEX0
	SERVER0
	INDEX1
(boosted clause)
	(forall INDEX2, INDEX0, SERVER0, INDEX1 . ((INDEX0 = INDEX1) | (INDEX0 = INDEX2) | (INDEX1 = INDEX2) | succ(INDEX0, INDEX2) | ~indlt(INDEX2, INDEX1) | (log(SERVER0, INDEX2) = termzero)))
---------------------------
(original clause)
	(~(log(s1, i2) = t0) | ~(termzero = t1) | ~indlt(i2, i1) | succ(i0, i2))
(learnt sym-boosted clause)
	(forall INDEX2, INDEX0, SERVER0, INDEX1 . ((INDEX0 = INDEX1) | (INDEX0 = INDEX2) | (INDEX1 = INDEX2) | succ(INDEX0, INDEX2) | ~indlt(INDEX2, INDEX1) | (log(SERVER0, INDEX2) = termzero)))
---------------------------
(clause-type: univ)	(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    10s  is global clause? Yes
@    10s  Learning in F[2]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    10s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e3 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1 -> q0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false			--> modified
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    10s  F[1] /\ T /\ C+ ?
@    10s  	Ans. UNSAT
@    10s  F[2] unsat core #5 	(ucsz: 12 -> 11 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i1)
	(log(s1, i1) = t0)
	(log(s0, i1) = t1)
	leader(s0)
	(currentTerm(s0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i1) | ~leader(s0))
(relations)
	loglen
	log
	leader
	currentTerm
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	leader(SERVER0)
(antecedent reduction)
@    10s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM0), (log(SERVER0, INDEX0) = TERM1), leader(SERVER0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER0 -> [ (log(V:server:e2:, INDEX0) = TERM1), leader(V:server:e2:), (loglen(V:server:e2:) = INDEX0), (currentTerm(V:server:e2:) = TERM0), ]
	SERVER1 -> [ (log(V:server:e2:, INDEX0) = TERM0), ]
ucubes2qv #2
	((currentTerm(V:server:e2:) = TERM0) & (log(V:server:e2:, INDEX0) = TERM1) & (loglen(V:server:e2:) = INDEX0) & leader(V:server:e2:)) -> [ SERVER0, ]
	(log(V:server:e2:, INDEX0) = TERM0) -> [ SERVER1, ]
(partition) #2 server:e2: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ (log(SERVER1, INDEX0) = TERM0), (currentTerm(SERVER0) = TERM0), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ (log(SERVER1, INDEX0) = V:term:e2:), (currentTerm(SERVER0) = V:term:e2:), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e2:), ]
ucubes2qv #2
	(log(SERVER0, INDEX0) = V:term:e2:) -> [ TERM1, ]
	((currentTerm(SERVER0) = V:term:e2:) & (log(SERVER1, INDEX0) = V:term:e2:)) -> [ TERM0, ]
(partition) #2 term:e2: -> { TERM1, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER1, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, loglen(SERVER0))
(cube eq: post)
	~(log(SERVER1, loglen(SERVER0)) = log(SERVER0, loglen(SERVER0)))
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0)))
	leader(SERVER0)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER0)) = log(SERVER0, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER0)) = log(SERVER0, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    10s  is global clause? No
@    10s  Learning in F[2]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    10s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
	F[1]: #4
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
	F[2]: #7
		(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
		(forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    10s  
Adding frame 3...
Trying forwarding F[1]
Trying forwarding F[2]
Forwarded #4 to F[3]
@    11s  Learning in F[3]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    11s  Learning in F[3]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    11s  Learning in F[3]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    11s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    11s  Learning in F[3]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    11s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    11s  Learning in F[3]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    11s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e3 with value True
	inputs:
actionName ext:getEntries
		V__fml:j:e1 -> s0
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0			--> modified
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    11s  F[2] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    11s  F[3] unsat core #3 	(ucsz: 10 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i1)
	committed(i0, t0)
	(log(s1, i0) = t1)
(clause)
	(~(log(s1, i0) = t1) | ~(loglen(s0) = i1) | ~committed(i0, t0))
(relations)
	loglen
	log
	committed
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	committed(INDEX0, TERM0)
	(loglen(SERVER0) = INDEX1)
(antecedent reduction)
@    11s  antecedent: 6 -> 6

qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e2:) = INDEX1), ]
	SERVER1 -> [ (log(V:server:e2:, INDEX0) = TERM1), ]
ucubes2qv #2
	(log(V:server:e2:, INDEX0) = TERM1) -> [ SERVER1, ]
	(loglen(V:server:e2:) = INDEX1) -> [ SERVER0, ]
(partition) #2 server:e2: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	TERM0 -> [ committed(INDEX0, TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	TERM0 -> [ committed(INDEX0, V:term:e2:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e2:), ]
ucubes2qv #2
	(log(SERVER1, INDEX0) = V:term:e2:) -> [ TERM1, ]
	committed(INDEX0, V:term:e2:) -> [ TERM0, ]
(partition) #2 term:e2: -> { TERM1, | TERM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(TERM0 = log(SERVER1, INDEX0))
	committed(INDEX0, TERM0)
	~(INDEX0 = loglen(SERVER0))
	~(SERVER0 = SERVER1)
(qvars eq: post)
	INDEX0
	TERM0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, TERM0, SERVER0, SERVER1 . ((TERM0 = log(SERVER1, INDEX0)) | ~committed(INDEX0, TERM0) | (INDEX0 = loglen(SERVER0)) | (SERVER0 = SERVER1)))
---------------------------
(original clause)
	(~(log(s1, i0) = t1) | ~(loglen(s0) = i1) | ~committed(i0, t0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0, SERVER0, SERVER1 . ((TERM0 = log(SERVER1, INDEX0)) | ~committed(INDEX0, TERM0) | (INDEX0 = loglen(SERVER0)) | (SERVER0 = SERVER1)))
---------------------------
(clause-type: univ)	(forall I0, T0, S0, S1 . (committed(I0, T0) -> ((T0 = log(S1, I0)) | (I0 = loglen(S0)) | (S0 = S1))))
@    11s  is global clause? No
@    11s  Learning in F[3]: (forall I0, T0, S0, S1 . (committed(I0, T0) -> ((T0 = log(S1, I0)) | (I0 = loglen(S0)) | (S0 = S1))))
@    11s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    11s  F[2] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    11s  F[3] unsat core #4 	(ucsz: 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i0)
	committed(i1, t0)
	(termzero = t0)
	(loglen(s0) = i0)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(relations)
	loglen
	termzero
	committed
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(termzero = TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@    11s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, termzero)
	(loglen(SERVER1) = INDEX0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX0
(antecedent eq)
	server:e2:
	-> ~(SERVER0 = SERVER1)
	index:e2:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e2:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e2:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e2:) = INDEX0) -> [ SERVER0, SERVER1, ]
(partition) #1 server:e2: -> { SERVER0, SERVER1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
(non-epr version)
	(forall INDEX0, INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX0, INDEX1 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, termzero) | (INDEX0 = INDEX1))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I0, I1 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
@    11s  is global clause? No
@    11s  Learning in F[3]: (exists S0 . (forall I0, I1 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
@    11s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e3 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:newterm:e1 -> t0
		V__fml:q:e1 -> q0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    11s  F[2] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    11s  F[3] unsat core #5 	(ucsz: 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	~leader(s1)
	(currentTerm(s0) = t0)
	committed(i1, t0)
	(termzero = t0)
	(loglen(s0) = i0)
(clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | leader(s1))
(relations)
	loglen
	termzero
	leader
	currentTerm
	committed
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	committed(INDEX1, TERM0)
	(currentTerm(SERVER0) = TERM0)
	~leader(SERVER1)
(antecedent reduction)
@    11s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	committed(INDEX1, termzero)
	(currentTerm(SERVER0) = termzero)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX0
(antecedent eq)
	server:e2:
	-> ~(SERVER0 = SERVER1)
	index:e2:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = termzero), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (currentTerm(V:server:e2:) = termzero), (loglen(V:server:e2:) = INDEX0), ]
	SERVER1 -> [ ~leader(V:server:e2:), ]
ucubes2qv #2
	~leader(V:server:e2:) -> [ SERVER1, ]
	((currentTerm(V:server:e2:) = termzero) & (loglen(V:server:e2:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e2: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~leader(SERVER1)
	~(SERVER0 = SERVER1)
	committed(INDEX1, termzero)
	(currentTerm(SERVER0) = termzero)
	~(loglen(SERVER0) = INDEX1)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (leader(SERVER1) | (SERVER0 = SERVER1) | ~committed(INDEX1, termzero) | ~(currentTerm(SERVER0) = termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (leader(SERVER1) | (SERVER0 = SERVER1) | ~committed(INDEX1, termzero) | ~(currentTerm(SERVER0) = termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((committed(I1, termzero) & (currentTerm(S0) = termzero)) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1))))
@    11s  is global clause? No
@    11s  Learning in F[3]: (forall S0, S1, I1 . ((committed(I1, termzero) & (currentTerm(S0) = termzero)) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1))))
@    11s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0			--> modified
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

@    11s  F[2] /\ T /\ C+ ?
@    11s  	Ans. UNSAT
@    12s  F[3] unsat core #4 	(ucsz: 11 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i0, t0)
	indlt(i1, i0)
	(log(s0, i1) = t1)
	(termzero = t0)
(clause)
	(~(log(s0, i1) = t1) | ~(termzero = t0) | ~committed(i0, t0) | ~indlt(i1, i0))
(relations)
	termzero
	indlt
	committed
	log
(fullsorts)
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	(termzero = TERM0)
	indlt(INDEX1, INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
	committed(INDEX0, TERM0)
(antecedent reduction)
@    12s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
	indlt(INDEX1, INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	INDEX1
	INDEX0
(antecedent eq)
	term:e2:
	-> ~(termzero = TERM1)
(fullsorts)
	term:e2: -> [ termzero, TERM1, ]
qv2cubes #2
	termzero -> [ committed(INDEX0, termzero), ]
	TERM1 -> [ (log(SERVER0, INDEX1) = TERM1), ]
qv2ucubes #2
	termzero -> [ committed(INDEX0, V:term:e2:), ]
	TERM1 -> [ (log(SERVER0, INDEX1) = V:term:e2:), ]
ucubes2qv #2
	committed(INDEX0, V:term:e2:) -> [ termzero, ]
	(log(SERVER0, INDEX1) = V:term:e2:) -> [ TERM1, ]
(partition) #2 term:e2: -> { termzero, | TERM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
(cube eq: post)
	committed(INDEX0, termzero)
	indlt(INDEX1, INDEX0)
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	INDEX0
	SERVER0
	INDEX1
(boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . (~committed(INDEX0, termzero) | ~indlt(INDEX1, INDEX0) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t1) | ~(termzero = t0) | ~committed(i0, t0) | ~indlt(i1, i0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, INDEX1 . (~committed(INDEX0, termzero) | ~indlt(INDEX1, INDEX0) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall I0, S0, I1 . ((committed(I0, termzero) & indlt(I1, I0)) -> (termzero = log(S0, I1))))
@    12s  is global clause? No
@    12s  Learning in F[3]: (forall I0, S0, I1 . ((committed(I0, termzero) & indlt(I1, I0)) -> (termzero = log(S0, I1))))
@    12s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    12s  F[2] /\ T /\ C+ ?
@    12s  	Ans. UNSAT
@    12s  F[3] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	committed(i2, t0)
	~indlte(i2, i2)
	(termzero = t0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i2, t0) | indlte(i2, i2))
(relations)
	loglen
	indlte
	termzero
	committed
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX1, TERM0)
	(termzero = TERM0)
	~indlte(INDEX1, INDEX1)
(antecedent reduction)
@    12s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	~indlte(INDEX1, INDEX1)
	committed(INDEX1, termzero)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	SERVER0
	INDEX0
	INDEX1
(antecedent eq)
	index:e2:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~indlte(INDEX1, INDEX1)
	committed(INDEX1, termzero)
	~(loglen(SERVER0) = INDEX1)
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | indlte(INDEX1, INDEX1) | ~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i2, t0) | indlte(i2, i2))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | indlte(INDEX1, INDEX1) | ~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1)))
---------------------------
(clause-type: univ)	(forall S0, I1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, termzero)) -> (indlte(I1, I1) | (loglen(S0) = I1))))
@    12s  is global clause? No
@    12s  Learning in F[3]: (forall S0, I1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, termzero)) -> (indlte(I1, I1) | (loglen(S0) = I1))))
@    12s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    12s  F[2] /\ T /\ C+ ?
@    12s  	Ans. UNSAT
@    12s  F[3] unsat core #4 	(ucsz: 11 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(indzero = i0)
	committed(i1, t0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t0))
(relations)
	loglen
	indzero
	log
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(indzero = INDEX0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
(antecedent reduction)
@    12s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER0, indzero) = TERM0)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
(qvars eq)
	TERM0
	SERVER0
	INDEX1
(antecedent eq)
	index:e2:
	-> ~(indzero = INDEX1)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	(loglen(SERVER0) = indzero)
	~(indzero = INDEX1)
	committed(INDEX1, log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~(loglen(SERVER0) = indzero) | (indzero = INDEX1) | ~committed(INDEX1, log(SERVER0, indzero))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~(loglen(SERVER0) = indzero) | (indzero = INDEX1) | ~committed(INDEX1, log(SERVER0, indzero))))
---------------------------
(clause-type: univ)	(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    12s  is global clause? No
@    12s  Learning in F[3]: (forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    12s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    12s  F[2] /\ T /\ C+ ?
@    12s  	Ans. UNSAT
@    12s  F[3] unsat core #5 	(ucsz: 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~leader(s1)
	(loglen(s0) = i1)
	(termzero = t0)
	~succ(i2, i1)
	committed(i2, t0)
(clause)
	(~(loglen(s0) = i1) | ~(termzero = t0) | ~committed(i2, t0) | leader(s1) | succ(i2, i1))
(relations)
	loglen
	leader
	termzero
	succ
	committed
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	committed(INDEX1, TERM0)
	(termzero = TERM0)
	~succ(INDEX1, INDEX0)
(antecedent reduction)
@    12s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	committed(INDEX1, termzero)
	~succ(INDEX1, INDEX0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	INDEX0
(antecedent eq)
	server:e2:
	-> ~(SERVER0 = SERVER1)
	index:e2:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e2:) = INDEX0), ]
	SERVER1 -> [ ~leader(V:server:e2:), ]
ucubes2qv #2
	~leader(V:server:e2:) -> [ SERVER1, ]
	(loglen(V:server:e2:) = INDEX0) -> [ SERVER0, ]
(partition) #2 server:e2: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~leader(SERVER1)
	committed(INDEX1, termzero)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (leader(SERVER1) | ~committed(INDEX1, termzero) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i1) | ~(termzero = t0) | ~committed(i2, t0) | leader(s1) | succ(i2, i1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (leader(SERVER1) | ~committed(INDEX1, termzero) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . (committed(I1, termzero) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
@    12s  is global clause? No
@    12s  Learning in F[3]: (forall S0, S1, I1 . (committed(I1, termzero) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
@    12s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
	F[1]: #4
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
	F[2]: #3
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
		(forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
	F[3]: #11
		(forall I0, S0, I1 . ((committed(I0, termzero) & indlt(I1, I0)) -> (termzero = log(S0, I1))))
		(forall I0, T0, S0, S1 . (committed(I0, T0) -> ((T0 = log(S1, I0)) | (I0 = loglen(S0)) | (S0 = S1))))
		(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
		(exists S0 . (forall I0, I1 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S0, I1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, termzero)) -> (indlte(I1, I1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . ((committed(I1, termzero) & (currentTerm(S0) = termzero)) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . (committed(I1, termzero) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    13s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #5 to F[4]
@    13s  Learning in F[4]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    13s  Learning in F[4]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    13s  Learning in F[4]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    13s  Learning in F[4]: (forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    13s  Learning in F[4]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    13s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    13s  Learning in F[4]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    13s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e3 with value True
	inputs:
actionName ext:getEntries
		V__fml:j:e1 -> s0
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    13s  F[3] /\ T /\ C+ ?
@    13s  	Ans. UNSAT
@    13s  F[4] unsat core #4 	(ucsz: 11 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i2, t0)
	leader(s0)
	(termzero = t0)
	(log(s1, i2) = t1)
(clause)
	(~(log(s1, i2) = t1) | ~(termzero = t0) | ~committed(i2, t0) | ~leader(s0))
(relations)
	termzero
	leader
	committed
	log
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	term:e2: -> [ TERM0, TERM1, ]
(cube: std)
	committed(INDEX0, TERM0)
	(log(SERVER1, INDEX0) = TERM1)
	(termzero = TERM0)
	leader(SERVER0)
(antecedent reduction)
@    13s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, termzero)
	(log(SERVER1, INDEX0) = TERM1)
	leader(SERVER0)
(qvars eq)
	INDEX0
	SERVER0
	SERVER1
	TERM1
(antecedent eq)
	term:e2:
	-> ~(termzero = TERM1)
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	term:e2: -> [ termzero, TERM1, ]
qv2cubes #2
	SERVER0 -> [ leader(SERVER0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER0 -> [ leader(V:server:e2:), ]
	SERVER1 -> [ (log(V:server:e2:, INDEX0) = TERM1), ]
ucubes2qv #2
	(log(V:server:e2:, INDEX0) = TERM1) -> [ SERVER1, ]
	leader(V:server:e2:) -> [ SERVER0, ]
(partition) #2 server:e2: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #2
	termzero -> [ committed(INDEX0, termzero), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #2
	termzero -> [ committed(INDEX0, V:term:e2:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e2:), ]
ucubes2qv #2
	(log(SERVER1, INDEX0) = V:term:e2:) -> [ TERM1, ]
	committed(INDEX0, V:term:e2:) -> [ termzero, ]
(partition) #2 term:e2: -> { TERM1, | termzero, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER1, INDEX0))
	committed(INDEX0, termzero)
	leader(SERVER0)
(qvars eq: post)
	SERVER0
	INDEX0
	SERVER1
(boosted clause)
	(forall SERVER0, INDEX0, SERVER1 . ((termzero = log(SERVER1, INDEX0)) | ~committed(INDEX0, termzero) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s1, i2) = t1) | ~(termzero = t0) | ~committed(i2, t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, SERVER1 . ((termzero = log(SERVER1, INDEX0)) | ~committed(INDEX0, termzero) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
@    13s  is global clause? No
@    13s  Learning in F[4]: (forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
@    13s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

@    14s  F[3] /\ T /\ C+ ?
@    14s  	Ans. UNSAT
@    14s  F[4] unsat core #6 	(ucsz: 12 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~succ(i0, i2)
	~leader(s1)
	~succ(i1, i2)
	(loglen(s0) = i2)
	committed(i1, t0)
	(termzero = t0)
(clause)
	(~(loglen(s0) = i2) | ~(termzero = t0) | ~committed(i1, t0) | leader(s1) | succ(i0, i2) | succ(i1, i2))
(relations)
	loglen
	succ
	termzero
	leader
	committed
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	index:e2: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	committed(INDEX1, TERM0)
	(termzero = TERM0)
	~succ(INDEX0, INDEX2)
	~leader(SERVER1)
	~succ(INDEX1, INDEX2)
	(loglen(SERVER0) = INDEX2)
(antecedent reduction)
@    14s  antecedent: 5 -> 5

(eq map)
	TERM0 -> termzero
(cube eq)
	~succ(INDEX0, INDEX2)
	committed(INDEX1, termzero)
	~leader(SERVER1)
	~succ(INDEX1, INDEX2)
	(loglen(SERVER0) = INDEX2)
(qvars eq)
	INDEX0
	INDEX1
	INDEX2
	SERVER0
	SERVER1
(antecedent eq)
	server:e2:
	-> ~(SERVER0 = SERVER1)
	index:e2:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	server:e2: -> [ SERVER0, SERVER1, ]
	index:e2: -> [ INDEX0, INDEX1, INDEX2, ]
qv2cubes #2
	SERVER0 -> [ (loglen(SERVER0) = INDEX2), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #2
	SERVER0 -> [ (loglen(V:server:e2:) = INDEX2), ]
	SERVER1 -> [ ~leader(V:server:e2:), ]
ucubes2qv #2
	~leader(V:server:e2:) -> [ SERVER1, ]
	(loglen(V:server:e2:) = INDEX2) -> [ SERVER0, ]
(partition) #2 server:e2: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
qv2cubes #3
	INDEX2 -> [ ~succ(INDEX0, INDEX2), ~succ(INDEX1, INDEX2), (loglen(SERVER0) = INDEX2), ]
	INDEX0 -> [ ~succ(INDEX0, INDEX2), ]
	INDEX1 -> [ committed(INDEX1, termzero), ~succ(INDEX1, INDEX2), ]
qv2ucubes #3
	INDEX2 -> [ ~succ(INDEX0, V:index:e2:), ~succ(INDEX1, V:index:e2:), (loglen(SERVER0) = V:index:e2:), ]
	INDEX0 -> [ ~succ(V:index:e2:, INDEX2), ]
	INDEX1 -> [ committed(V:index:e2:, termzero), ~succ(V:index:e2:, INDEX2), ]
ucubes2qv #3
	((loglen(SERVER0) = V:index:e2:) & ~succ(INDEX0, V:index:e2:) & ~succ(INDEX1, V:index:e2:)) -> [ INDEX2, ]
	(committed(V:index:e2:, termzero) & ~succ(V:index:e2:, INDEX2)) -> [ INDEX1, ]
	~succ(V:index:e2:, INDEX2) -> [ INDEX0, ]
(partition) #3 index:e2: -> { INDEX2, | INDEX1, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
	~(SERVER0 = SERVER1)
	~leader(SERVER1)
	committed(INDEX1, termzero)
	~(INDEX0 = loglen(SERVER0))
	~(INDEX1 = loglen(SERVER0))
	~succ(INDEX0, loglen(SERVER0))
(qvars eq: post)
	SERVER1
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER1, SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | succ(INDEX1, loglen(SERVER0)) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, termzero) | (INDEX0 = loglen(SERVER0)) | (INDEX1 = loglen(SERVER0)) | succ(INDEX0, loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i2) | ~(termzero = t0) | ~committed(i1, t0) | leader(s1) | succ(i0, i2) | succ(i1, i2))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | succ(INDEX1, loglen(SERVER0)) | (SERVER0 = SERVER1) | leader(SERVER1) | ~committed(INDEX1, termzero) | (INDEX0 = loglen(SERVER0)) | (INDEX1 = loglen(SERVER0)) | succ(INDEX0, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
@    14s  is global clause? No
@    14s  Learning in F[4]: (forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
@    14s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e3 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1 -> i0
		V__fml:e1 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    14s  F[3] /\ T /\ C+ ?
@    14s  	Ans. UNSAT
@    14s  F[4] unsat core #4 	(ucsz: 17 -> 14 -> 9 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i2, t0)
	~indlt(i2, i1)
	(termzero = t0)
	(loglen(s0) = i1)
(clause)
	(~(loglen(s0) = i1) | ~(termzero = t0) | ~committed(i2, t0) | indlt(i2, i1))
(relations)
	loglen
	termzero
	indlt
	committed
(cube: std)
	(loglen(SERVER0) = INDEX0)
	~indlt(INDEX1, INDEX0)
	committed(INDEX1, TERM0)
	(termzero = TERM0)
(antecedent reduction)
@    14s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	~indlt(INDEX1, INDEX0)
	committed(INDEX1, termzero)
(qvars eq)
	SERVER0
	INDEX0
	INDEX1
(antecedent eq)
	index:e2:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, termzero)
	~(loglen(SERVER0) = INDEX1)
	~indlt(INDEX1, loglen(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1) | indlt(INDEX1, loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i1) | ~(termzero = t0) | ~committed(i2, t0) | indlt(i2, i1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~committed(INDEX1, termzero) | (loglen(SERVER0) = INDEX1) | indlt(INDEX1, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
@    14s  is global clause? No
@    14s  Learning in F[4]: (forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
@    14s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
	F[1]: #4
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
	F[2]: #3
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
		(forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
	F[3]: #6
		(forall I0, S0, I1 . ((committed(I0, termzero) & indlt(I1, I0)) -> (termzero = log(S0, I1))))
		(forall I0, T0, S0, S1 . (committed(I0, T0) -> ((T0 = log(S1, I0)) | (I0 = loglen(S0)) | (S0 = S1))))
		(exists S0 . (forall I0, I1 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
		(forall S0, I1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, termzero)) -> (indlte(I1, I1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . ((committed(I1, termzero) & (currentTerm(S0) = termzero)) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . (committed(I1, termzero) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
	F[4]: #8
		(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
		(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
		(forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
		(forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    14s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #8 to F[5]
@    15s  Learning in F[5]: (forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
@    15s  Learning in F[5]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    15s  Learning in F[5]: (forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
@    15s  Learning in F[5]: (forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
@    15s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    15s  Learning in F[5]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    15s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    15s  Learning in F[5]: (forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    15s  Learning in F[5]: (forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    15s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    15s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    15s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S3 . ~leader(S3)) & (forall S3 . (currentTerm(S3) = termzero)) & (forall S3 . (loglen(S3) = indzero)) & (forall S3, I3 . (log(S3, I3) = termzero)) & (forall I3_1, T3 . ~committed(I3_1, T3)))
	F[1]: #4
		(forall I1, S0, I0 . (indlt(I0, I1) -> (termzero = log(S0, I0))))
		(forall I0, S0, S1 . ((leader(S0) & (log(S0, I0) = log(S0, loglen(S0)))) -> ((I0 = loglen(S0)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall I1, T0, I0 . (committed(I1, T0) -> ((I0 = I1) | succ(I0, I1))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
	F[2]: #3
		(forall I1, S0 . (committed(I1, termzero) -> (loglen(S0) = I1)))
		(forall S0, I0 . (indlt(I0, loglen(S0)) -> (log(S0, I0) = termzero)))
		(forall S0, T0, I0 . (committed(I0, T0) -> (T0 = log(S0, I0))))
	F[3]: #6
		(forall I0, S0, I1 . ((committed(I0, termzero) & indlt(I1, I0)) -> (termzero = log(S0, I1))))
		(forall I0, T0, S0, S1 . (committed(I0, T0) -> ((T0 = log(S1, I0)) | (I0 = loglen(S0)) | (S0 = S1))))
		(exists S0 . (forall I0, I1 . (((loglen(S0) = I0) & committed(I1, termzero)) -> (I0 = I1))))
		(forall S0, I1 . (((log(S0, loglen(S0)) = termzero) & committed(I1, termzero)) -> (indlte(I1, I1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . ((committed(I1, termzero) & (currentTerm(S0) = termzero)) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1))))
		(forall S0, S1, I1 . (committed(I1, termzero) -> (leader(S1) | (S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
	F[4]: #0
	F[5]: #8
		(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
		(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
		(forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
		(forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
@    15s  
Adding frame 6...
@    15s  F[4] converged!
Explored 7 frames
@    15s  -------------------------------------------------
### Invariant: #9
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other2]	(forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
invariant [global3]	(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
invariant [other5]	(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
invariant [prop1]	(forall I3, T3, S3 . ((committed(I3, T3) & leader(S3) & (lte(T3, currentTerm(S3)) & ~(T3 = currentTerm(S3)))) -> (log(S3, I3) = T3)))
invariant [other1]	(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
invariant [other3]	(forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
invariant [other4]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 global5 -> UNSAT
	#2 other2 -> UNSAT
	#3 global3 -> UNSAT
	#4 other5 -> UNSAT
	#5 prop1  (property) -> UNSAT
	#6 other1 -> UNSAT
	#7 other3 -> UNSAT
	#8 other4 -> UNSAT
	#9 global4_1 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 global5 -> UNSAT
	#2 other2 -> UNSAT
	#3 global3 -> UNSAT
	#4 other5 -> UNSAT
	#5 prop1  (property) -> UNSAT
	#6 other1 -> UNSAT
	#7 other3 -> UNSAT
	#8 other4 -> UNSAT
	#9 global4_1 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e2: -> [`index:e2:0`, `index:e2:1`, `index:e2:2`]
	term -> term:e2: -> [`term:e2:0`, `term:e2:1`]
	quorum -> quorum:e2: -> [`quorum:e2:0`, `quorum:e2:1`]
	server -> server:e2: -> [`server:e2:0`, `server:e2:1`]

Invariant is a proof certificate
@    15s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e3, T:e3, X:e3 . ((__committed:e3(I:e3, T:e3) & __leader:e3(X:e3) & (...(..., ...) & ~...)) -> (__log:e3(X:e3, I:e3) = T:e3)))
raw invariant [global5] (cost: 2, 2F, 0E) 	~(exists Q:server:e3:0, Q:server:e3:1 . (~(... = ...) & __leader:e3(Q:server:e3:1) & indlt:e3(...(...), ...(...))))
raw invariant [other2] (cost: 3, 3F, 0E) 	~(exists Q:server:e2:0, Q:index:e2:0, Q:server:e2:1 . (~(... = ...) & __committed:e3(Q:index:e2:0, termzero:e3) & __leader:e3(Q:server:e2:0)))
raw invariant [global3] (cost: 4, 4F, 0E) 	~(exists Q:index:e2:2, Q:index:e2:0, Q:server:e2:0, Q:index:e2:1 . (~(... = ...) & ~(... = ...) & ~(... = ...) & ~...(..., ...) & indlt:e3(Q:index:e2:2, Q:index:e2:1) & ~(... = ...)))
raw invariant [other5] (cost: 2, 2F, 0E) 	~(exists Q:server:e2:0, Q:index:e2:1 . ((...(...) = indzero:e3) & ~(... = ...) & __committed:e3(Q:index:e2:1, ...(..., ...))))
raw invariant [other1] (cost: 2, 2F, 0E) 	~(exists Q:server:e2:0, Q:index:e2:1 . (__committed:e3(Q:index:e2:1, termzero:e3) & ~(... = ...) & ~...(..., ...)))
raw invariant [other3] (cost: 4, 4F, 0E) 	~(exists Q:server:e2:1, Q:server:e2:0, Q:index:e2:0, Q:index:e2:1 . (~(... = ...) & ~...(..., ...) & ~(... = ...) & ~...(...) & __committed:e3(Q:index:e2:1, termzero:e3) & ~(... = ...) & ~(... = ...) & ~...(..., ...)))
raw invariant [other4] (cost: 2, 2F, 0E) 	~(exists Q:server:e2:0, Q:server:e2:1 . (~(... = ...) & (...(...) = ...(..., ...)) & __leader:e3(Q:server:e2:0)))
raw invariant [global4_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e3:0 . (__leader:e3(Q:server:e3:0) & (...(...) = termzero:e3)))
@    15s  Minimizing certificate of size 9
@    15s  	global3	(cost: 4) -> add
@    15s  	other3	(cost: 4) -> remove
@    16s  	prop1	(cost: 3) -> property
@    16s  	other2	(cost: 3) -> remove
@    16s  	global5	(cost: 2) -> add
@    16s  	other5	(cost: 2) -> remove
@    16s  	other1	(cost: 2) -> add
@    17s  	other4	(cost: 2) -> add
@    17s  	global4_1	(cost: 1) -> add
	Minimized certificate: 9 -> 6
@    17s  -------------------------------------------------
### Proof certificate (required): #6
invariant [global3]	(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
invariant [prop1]	(forall I3, T3, S3 . ((committed(I3, T3) & leader(S3) & (lte(T3, currentTerm(S3)) & ~(T3 = currentTerm(S3)))) -> (log(S3, I3) = T3)))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other1]	(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
invariant [other4]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
###

### Optional invariants: #3
invariant [other3_optional]	(forall S1, S0, I0, I1 . (committed(I1, termzero) -> ((I0 = I1) | succ(I1, loglen(S0)) | (S0 = S1) | leader(S1) | (I0 = loglen(S0)) | (I1 = loglen(S0)) | succ(I0, loglen(S0)))))
invariant [other2_optional]	(forall S0, I0, S1 . ((committed(I0, termzero) & leader(S0)) -> (termzero = log(S1, I0))))
invariant [other5_optional]	(forall S0, I1 . (((loglen(S0) = indzero) & committed(I1, log(S0, indzero))) -> (indzero = I1)))
###

	random:	0
	scalls:	603
	scalls-finite:	589
	scalls-infinite:	14
	scalls-finite-full:	589
	cti:	34
	cubes:	36
	subsumed-calls:	461
	subsumed-subset:	0
	subsumed-varintersect-c:	451
	subsumed-varintersect-e:	0
	subsumed-query-sat:	8
	subsumed-query-unsat:	2
	subsumed-eq:	58
	unsat-core:	62
	sz-unsat-core-avg:	5.66
	sz-unsat-min-avg:	3.37
	sz-cube-avg:	43.92
	antecedent-reduction-sum:	18
	antecedent-total-sum:	104
	antecedent-reduction-avg:	0.17
	antecedent-calls:	28
	antecedent-calls-reduced:	8
	antecedent-scalls:	132
	time-q-max-finite-ms:	104
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	5
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	1
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	3
	time-forward:	2
	time-antecedent:	2
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	1
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	2
	time-qf:	0
	time-sum:	11
@    17s  -------------------------------------------------
@    17s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@    17s  (finite convergence checks)
@    17s  (performing finite convergence checks for term)
(enumsort) index <-> index:e4:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e4:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e4:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e4:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[i0] = 0
	dep_height[i1] = 1
	dep_height[i2] = 2
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@    17s  -------------------------------------------------
### Invariant: #6
invariant [other4]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [prop1]	(forall I4, T4, S4 . ((committed(I4, T4) & leader(S4) & (lte(T4, currentTerm(S4)) & ~(T4 = currentTerm(S4)))) -> (log(S4, I4) = T4)))
invariant [other1]	(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
invariant [global3]	(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> SAT
Checking Init /\ !Inv:
	#1 other4 -> UNSAT
	#2 global5 -> UNSAT
	#3 global4_1 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other1 -> UNSAT
	#6 global3 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other4 -> UNSAT
	#2 global5 -> UNSAT
	#3 global4_1 -> UNSAT
	#4 prop1  (property) -> SAT
	#5 other1 -> UNSAT
	#6 global3 -> UNSAT
	Inv_all /\ T /\ !Inv+: 1 failed

Finite sorts: #4
	index -> index:e4: -> [`index:e4:0`, `index:e4:1`, `index:e4:2`]
	term -> term:e4: -> [`term:e4:0`, `term:e4:1`, `term:e4:2`]
	quorum -> quorum:e4: -> [`quorum:e4:0`, `quorum:e4:1`]
	server -> server:e4: -> [`server:e4:0`, `server:e4:1`]

Invariant is not a proof certificate
@    17s  -------------------------------------------------
@    17s  (extended |term| to 3)
@    17s  (finite convergence checks failed for term)
(enumsort) index <-> index:e5:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e5:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e5:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e5:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@    17s  (removed 1 long clauses)
		(forall I2, I0, S0, I1 . (indlt(I2, I1) -> ((I0 = I1) | (I0 = I2) | (I1 = I2) | succ(I0, I2) | (log(S0, I2) = termzero))))
@    17s  -------------------------------------------------
### Checking reusability of clauses: #4
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other4]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [global5]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other1]	(forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
###

Checking Init /\ !Inv:
	#1 global4_1 -> UNSAT
	#2 other4 -> UNSAT
	#3 global5 -> UNSAT
	#4 other1 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 global4_1 -> UNSAT
	#2 other4 -> UNSAT
	#3 global5 -> UNSAT
	#4 other1 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 4 -> 4 (0 + 0 failed)
All clauses reusable
@    17s  -------------------------------------------------
	random:	0
	scalls:	625
	scalls-finite:	603
	scalls-infinite:	22
	scalls-finite-full:	603
	cti:	34
	cubes:	36
	subsumed-calls:	461
	subsumed-subset:	0
	subsumed-varintersect-c:	451
	subsumed-varintersect-e:	0
	subsumed-query-sat:	8
	subsumed-query-unsat:	2
	subsumed-eq:	58
	unsat-core:	62
	sz-unsat-core-avg:	5.66
	sz-unsat-min-avg:	3.37
	sz-cube-avg:	43.92
	antecedent-reduction-sum:	18
	antecedent-total-sum:	104
	antecedent-reduction-avg:	0.17
	antecedent-calls:	28
	antecedent-calls-reduced:	8
	antecedent-scalls:	132
	time-q-max-finite-ms:	104
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	5
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	1
	time-cti-bad-unsat:	0
	time-cti-sat:	0
	time-cti-unsat:	3
	time-forward:	2
	time-antecedent:	2
	time-subsume:	0
	time-subsume-query:	0
	time-inv-check-finite:	1
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	2
	time-qf:	0
	time-sum:	11
@    17s  -------------------------------------------------
@    17s  -------------------------------------------------
@    17s  (incremental SymIC3)
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)

Checking property...

@    17s  Storing init values:
@    17s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s0, i2) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(log(s1, i2) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i2, i1)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i2, i1)
	lte(t0, t0)
	lte(t0, t1)
	lte(t0, t2)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t2)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~committed(i2, t0)
	~committed(i2, t1)
	~committed(i2, t2)
	~leader(s0)
	~leader(s1)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i1, i2)
	~indlt(i2, i0)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i1, i2)
	~indlte(i2, i0)
	~indlte(i2, i2)
	~lte(t1, t0)
	~lte(t2, t0)
	~lte(t2, t1)
	~member(s0, q0)
	~member(s0, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@    17s  F[0] /\ !P -> UNSAT
@    17s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
@    17s  
Adding frame 1...
@    17s  Is F[0] -> other4? -> UNSAT
@    17s  Is other4 inductive? -> SAT
@    17s  Is F[0] /\ T -> other4+? -> UNSAT
@    17s  Learning in F[1]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    17s  Is F[0] -> global5? -> UNSAT
@    17s  Is global5 inductive? -> UNSAT
@    17s  Is F[0] -> global4_1? -> UNSAT
@    17s  Is global4_1 inductive? -> UNSAT
@    17s  Is F[0] -> other1? -> UNSAT
@    17s  Is other1 inductive? -> SAT
@    17s  Is F[0] /\ T -> other1+? -> UNSAT
@    17s  Learning in F[1]: (forall S0, I1 . (committed(I1, termzero) -> ((loglen(S0) = I1) | indlt(I1, loglen(S0)))))
Seeded 4 (global: 2, init: 2) helpers out of 4
@    17s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    17s  Learning in F[1]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    17s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[1])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    18s  F[0] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(loglen(s0) = i0)
	(indzero = i2)
(clause)
	(~(indzero = i2) | ~(loglen(s0) = i0))
(relations)
	loglen
	indzero
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
(antecedent reduction)
@    18s  antecedent: 2 -> 2

(eq map)
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
(qvars eq)
	SERVER0
	INDEX0
(antecedent eq)
	index:e5:
	-> ~(INDEX0 = indzero)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(original clause)
	(~(indzero = i2) | ~(loglen(s0) = i0))
(learnt sym-boosted clause)
	(forall SERVER0 . (loglen(SERVER0) = indzero))
---------------------------
(clause-type: univ)	(forall S0 . (loglen(S0) = indzero))
@    18s  is global clause? No
@    18s  Learning in F[1]: (forall S0 . (loglen(S0) = indzero))
@    18s  F[1] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[1])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    18s  F[0] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[1] unsat core #1 	(ucsz: 1 -> 1)
(minimal unsat core)
	committed(i0, t0)
(clause)
	~committed(i0, t0)
(relations)
	committed
(cube: std)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(original clause)
	~committed(i0, t0)
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . ~committed(INDEX0, TERM0))
---------------------------
(clause-type: univ)	(forall T0, I0 . ~committed(I0, T0))
@    18s  is global clause? No
@    18s  Learning in F[1]: (forall T0, I0 . ~committed(I0, T0))
@    18s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #5
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S0 . (loglen(S0) = indzero))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    18s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #3 to F[2]
@    18s  Learning in F[2]: (forall T0, I0 . ~committed(I0, T0))
@    18s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    18s  Learning in F[2]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    18s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    18s  Learning in F[2]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    18s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false			--> modified
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    18s  F[1] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[2] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(indzero = i0)
	~succ(i0, i1)
	(loglen(s0) = i1)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | succ(i0, i1))
(relations)
	loglen
	indzero
	succ
(cube: std)
	~succ(INDEX0, INDEX1)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    18s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
(cube eq)
	~succ(indzero, INDEX1)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	INDEX1
	SERVER0
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~succ(indzero, loglen(SERVER0))
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i1) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER0 . (succ(indzero, loglen(SERVER0)) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@    18s  is global clause? No
@    18s  Learning in F[2]: (forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
@    18s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false			--> modified
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    18s  F[1] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[2] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(loglen(s1) = i2)
	(loglen(s0) = i2)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i2) | ~(loglen(s1) = i2))
(relations)
	loglen
	indzero
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    18s  antecedent: 4 -> 4

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	INDEX1
	SERVER1
	SERVER0
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX1), ]
ucubes2qv #1
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, SERVER0, ]
(partition) #1 server:e5: -> { SERVER1, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
(non-epr version)
	(forall INDEX1 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i2) | ~(loglen(s1) = i2))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX1 . (~(loglen(SERVER0) = INDEX1) | (indzero = INDEX1))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
@    18s  is global clause? No
@    18s  Learning in F[2]: (exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
@    18s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    18s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    18s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    18s  F[0] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[1] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	(termzero = t1)
	(log(s0, i0) = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(termzero = t1))
(relations)
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
(antecedent reduction)
@    18s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	SERVER0
	TERM0
	INDEX0
(antecedent eq)
	term:e5:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (log(SERVER0, INDEX0) = termzero))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (log(SERVER0, INDEX0) = termzero))
---------------------------
(clause-type: univ)	(forall I0, S0 . (log(S0, I0) = termzero))
@    18s  is global clause? No
@    18s  Learning in F[1]: (forall I0, S0 . (log(S0, I0) = termzero))
@    18s  F[1] /\ T /\ C+ ?
@    18s  	Ans. UNSAT
@    18s  F[2] unsat core #4 	(ucsz: 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s0) = t0)
	(indzero = i0)
	(log(s0, i0) = t0)
	(loglen(s0) = i1)
(clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i1))
(relations)
	currentTerm
	loglen
	indzero
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(indzero = INDEX0)
	(loglen(SERVER0) = INDEX1)
(antecedent reduction)
@    19s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER0, indzero) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	INDEX1
	TERM0
	SERVER0
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	~(indzero = loglen(SERVER0))
	(currentTerm(SERVER0) = log(SERVER0, indzero))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . ((indzero = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER0, indzero))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i1))
(learnt sym-boosted clause)
	(forall SERVER0 . ((indzero = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER0, indzero))))
---------------------------
(clause-type: univ)	(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
@    19s  is global clause? No
@    19s  Learning in F[2]: (forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
@    19s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false			--> modified
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    19s  F[1] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[2] unsat core #3 	(ucsz: 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(termzero = t1)
	(indzero = i0)
	(log(s1, i0) = t0)
(clause)
	(~(indzero = i0) | ~(log(s1, i0) = t0) | ~(termzero = t1))
(relations)
	indzero
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(indzero = INDEX0)
(antecedent reduction)
@    19s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	SERVER0
	TERM0
(antecedent eq)
	term:e5:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
(cube eq: post)
	~(log(SERVER0, indzero) = termzero)
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i0) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER0 . (log(SERVER0, indzero) = termzero))
---------------------------
(clause-type: univ)	(forall S0 . (log(S0, indzero) = termzero))
@    19s  is global clause? Yes
@    19s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@    19s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false			--> modified
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    19s  F[1] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[2] unsat core #4 	(ucsz: 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i2)
	(currentTerm(s0) = t0)
	(log(s0, i1) = t0)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i2) | ~leader(s0))
(relations)
	currentTerm
	loglen
	log
	leader
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX1)
(antecedent reduction)
@    19s  antecedent: 2 -> 2

(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	leader(SERVER0)
	~(INDEX0 = loglen(SERVER0))
	(currentTerm(SERVER0) = log(SERVER0, INDEX0))
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~leader(SERVER0) | (INDEX0 = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i2) | ~leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~leader(SERVER0) | (INDEX0 = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX0))))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
@    19s  is global clause? No
@    19s  Learning in F[2]: (forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
@    19s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    19s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    19s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    19s  F[0] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[1] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(termzero = t1)
	(currentTerm(s1) = t2)
	~member(s1, q0)
	~member(s1, q1)
(clause)
	(~(currentTerm(s1) = t2) | ~(termzero = t1) | member(s1, q0) | member(s1, q1))
(relations)
	currentTerm
	member
	termzero
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	~member(SERVER0, QUORUM1)
	~member(SERVER0, QUORUM0)
	(termzero = TERM0)
(antecedent reduction)
@    19s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	~member(SERVER0, QUORUM1)
	~member(SERVER0, QUORUM0)
(qvars eq)
	QUORUM0
	QUORUM1
	SERVER0
	TERM1
(antecedent eq)
	quorum:e5:
	-> ~(QUORUM0 = QUORUM1)
	term:e5:
	-> ~(termzero = TERM1)
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
qv2cubes #2
	QUORUM0 -> [ ~member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ ~member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER0, V:quorum:e5:), ]
	QUORUM1 -> [ ~member(SERVER0, V:quorum:e5:), ]
ucubes2qv #1
	~member(SERVER0, V:quorum:e5:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e5: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
(non-epr version)
	(forall TERM1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(termzero = t1) | member(s1, q0) | member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM1) | (termzero = TERM1) | member(SERVER0, QUORUM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    19s  is global clause? Yes
@    19s  Learning in F[2]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    19s  F[1] /\ T /\ C+ ?
@    19s  	Ans. UNSAT
@    19s  F[2] unsat core #3 	(ucsz: 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	~member(s1, q0)
	~member(s1, q1)
	leader(s1)
(clause)
	(~leader(s1) | member(s1, q0) | member(s1, q1))
(relations)
	member
	leader
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~member(SERVER0, QUORUM1)
	leader(SERVER0)
	~member(SERVER0, QUORUM0)
(antecedent reduction)
@    19s  antecedent: 2 -> 2

qv2cubes #2
	QUORUM0 -> [ ~member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ ~member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER0, V:quorum:e5:), ]
	QUORUM1 -> [ ~member(SERVER0, V:quorum:e5:), ]
ucubes2qv #1
	~member(SERVER0, V:quorum:e5:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e5: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
(non-epr version)
	(forall SERVER0 . (exists QUORUM0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
---------------------------
(original clause)
	(~leader(s1) | member(s1, q0) | member(s1, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER0 . (~leader(SERVER0) | member(SERVER0, QUORUM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    19s  is global clause? Yes
@    19s  Learning in F[2]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    19s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false			--> modified
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    20s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    20s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    20s  F[0] /\ T /\ C+ ?
@    20s  	Ans. UNSAT
@    20s  F[1] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(termzero = t1)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(termzero = t1))
(relations)
	currentTerm
	termzero
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER1) = TERM2)
	(currentTerm(SERVER0) = TERM0)
	(termzero = TERM1)
(antecedent reduction)
@    20s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	TERM1 -> termzero
(cube eq)
	(currentTerm(SERVER1) = TERM2)
	(currentTerm(SERVER0) = TERM0)
(qvars eq)
	TERM2
	SERVER1
	TERM0
	SERVER0
(antecedent eq)
	term:e5:
	-> ~(TERM0 = termzero)
	-> ~(TERM0 = TERM2)
	-> ~(termzero = TERM2)
(fullsorts)
	term:e5: -> [ TERM0, termzero, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
	TERM0 -> [ (currentTerm(SERVER0) = TERM0), ]
	termzero -> [ ]
qv2ucubes #3
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e5:), ]
	TERM0 -> [ (currentTerm(SERVER0) = V:term:e5:), ]
	termzero -> [ ]
ucubes2qv #3
	true -> [ termzero, ]
	(currentTerm(SERVER1) = V:term:e5:) -> [ TERM2, ]
	(currentTerm(SERVER0) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { termzero, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM2), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM2), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), ]
ucubes2qv #2
	(currentTerm(V:server:e5:) = TERM0) -> [ SERVER0, ]
	(currentTerm(V:server:e5:) = TERM2) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM2 -> currentTerm(SERVER1)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	~(currentTerm(SERVER0) = currentTerm(SERVER1))
	~(termzero = currentTerm(SERVER1))
	~(currentTerm(SERVER0) = termzero)
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | (termzero = currentTerm(SERVER1)) | (currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | (termzero = currentTerm(SERVER1)) | (currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
@    20s  is global clause? No
@    20s  Learning in F[1]: (forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
@    20s  F[1] /\ T /\ C+ ?
@    20s  	Ans. UNSAT
@    20s  F[2] unsat core #5 	(ucsz: 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i2)
	(currentTerm(s0) = t0)
	(indzero = i0)
	(currentTerm(s1) = t2)
	leader(s1)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i0) | ~(loglen(s0) = i2) | ~leader(s1))
(relations)
	currentTerm
	loglen
	indzero
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	leader(SERVER1)
	(loglen(SERVER0) = INDEX1)
	(currentTerm(SERVER0) = TERM0)
	(indzero = INDEX0)
	(currentTerm(SERVER1) = TERM1)
(antecedent reduction)
@    20s  antecedent: 6 -> 4 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX1)
	leader(SERVER1)
	(currentTerm(SERVER1) = TERM1)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
	term:e5:
	-> ~(TERM0 = TERM1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ leader(SERVER1), (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	SERVER1 -> [ leader(V:server:e5:), (currentTerm(V:server:e5:) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = INDEX1), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & leader(V:server:e5:)) -> [ SERVER1, ]
	((currentTerm(V:server:e5:) = TERM0) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM0 -> currentTerm(SERVER0)
	TERM1 -> currentTerm(SERVER1)
(cube eq: post)
	~(currentTerm(SERVER0) = currentTerm(SERVER1))
	~(indzero = loglen(SERVER0))
	leader(SERVER1)
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | (indzero = loglen(SERVER0)) | ~leader(SERVER1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i0) | ~(loglen(s0) = i2) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | (indzero = loglen(SERVER0)) | ~leader(SERVER1)))
---------------------------
(clause-type: univ)	(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
@    20s  is global clause? No
@    20s  Learning in F[2]: (forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
@    20s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #4
		(forall S0 . (loglen(S0) = indzero))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #11
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall S0 . (log(S0, indzero) = termzero))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall T0, I0 . ~committed(I0, T0))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    20s  
Adding frame 3...
Trying forwarding F[1]
Forwarded #1 to F[2]
@    20s  Learning in F[2]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
Trying forwarding F[2]
Forwarded #6 to F[3]
@    20s  Learning in F[3]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    20s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@    20s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    20s  Learning in F[3]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    20s  Learning in F[3]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    20s  Learning in F[3]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    20s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@    20s  Learning in F[3]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    20s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    20s  Learning in F[3]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    20s  Learning in F[3]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    20s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t1			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    20s  F[2] /\ T /\ C+ ?
@    20s  	Ans. UNSAT
@    20s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	committed(i0, t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~committed(i0, t1))
(relations)
	indzero
	committed
(cube: std)
	committed(INDEX0, TERM0)
	(indzero = INDEX0)

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(indzero, TERM0)
(qvars eq)
	TERM0
(antecedent eq)
(boosted clause)
	(forall TERM0 . ~committed(indzero, TERM0))
---------------------------
(original clause)
	(~(indzero = i0) | ~committed(i0, t1))
(learnt sym-boosted clause)
	(forall TERM0 . ~committed(indzero, TERM0))
---------------------------
(clause-type: univ)	(forall T0 . ~committed(indzero, T0))
@    20s  is global clause? Yes
@    20s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@    20s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

@    21s  F[2] /\ T /\ C+ ?
@    21s  	Ans. UNSAT
@    21s  F[3] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i2)
	(loglen(s1) = i0)
	committed(i1, t0)
(clause)
	(~(loglen(s0) = i2) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(relations)
	loglen
	committed
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX2)
(antecedent reduction)
@    21s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = INDEX2), ]
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = V:index:e5:), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e5:), ]
ucubes2qv #3
	committed(V:index:e5:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX0, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX2, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX0, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX2), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX2), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, ]
	(loglen(V:server:e5:) = INDEX2) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER0)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(loglen(SERVER1) = INDEX1)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(INDEX1 = loglen(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (loglen(SERVER1) = INDEX1) | (loglen(SERVER1) = loglen(SERVER0)) | (INDEX1 = loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i2) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (loglen(SERVER1) = INDEX1) | (loglen(SERVER1) = loglen(SERVER0)) | (INDEX1 = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
@    21s  is global clause? No
@    21s  Learning in F[3]: (forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
@    21s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    21s  F[2] /\ T /\ C+ ?
@    21s  	Ans. UNSAT
@    21s  F[3] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i0)
	committed(i2, t0)
	(loglen(s1) = i0)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0))
(relations)
	loglen
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
(antecedent reduction)
@    21s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, SERVER0, ]
(partition) #1 server:e5: -> { SERVER1, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1, TERM0, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
(non-epr version)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0))
(learnt sym-boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0))))
---------------------------
(clause-type: non-epr)	(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
@    21s  is global clause? No
@    21s  Learning in F[3]: (forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
@    21s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    21s  F[2] /\ T /\ C+ ?
@    21s  	Ans. UNSAT
@    21s  F[3] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(indzero = i0)
	~succ(i0, i1)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~committed(i1, t0) | succ(i0, i1))
(relations)
	indzero
	committed
	succ
(cube: std)
	committed(INDEX1, TERM0)
	~succ(INDEX0, INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@    21s  antecedent: 2 -> 0 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	~succ(indzero, INDEX1)
(qvars eq)
	INDEX1
	TERM0
(antecedent eq)
(boosted clause)
	(forall INDEX1, TERM0 . (~committed(INDEX1, TERM0) | succ(indzero, INDEX1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~committed(i1, t0) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall INDEX1, TERM0 . (~committed(INDEX1, TERM0) | succ(indzero, INDEX1)))
---------------------------
(clause-type: univ)	(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
@    21s  is global clause? No
@    21s  Learning in F[3]: (forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
@    21s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    21s  F[2] /\ T /\ C+ ?
@    21s  	Ans. UNSAT
@    21s  F[3] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i0)
	~leader(s1)
	committed(i1, t0)
(clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s1))
(relations)
	loglen
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
(antecedent reduction)
@    21s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ ~leader(SERVER1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~leader(V:server:e5:), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER0, ]
	~leader(V:server:e5:) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	~leader(SERVER1)
(qvars eq: post)
	INDEX1
	SERVER1
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | leader(SERVER1)))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s1))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | leader(SERVER1)))
---------------------------
(clause-type: univ)	(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
@    21s  is global clause? No
@    21s  Learning in F[3]: (forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
@    21s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    22s  F[2] /\ T /\ C+ ?
@    22s  	Ans. UNSAT
@    22s  F[3] unsat core #2 	(ucsz: 2 -> 2)
(minimal unsat core)
	~indlte(i2, i2)
	committed(i2, t1)
(clause)
	(~committed(i2, t1) | indlte(i2, i2))
(relations)
	indlte
	committed
(cube: std)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, TERM0)

(boosted clause)
	(forall TERM0, INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM0)))
---------------------------
(original clause)
	(~committed(i2, t1) | indlte(i2, i2))
(learnt sym-boosted clause)
	(forall TERM0, INDEX0 . (indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM0)))
---------------------------
(clause-type: univ)	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    22s  is global clause? Yes
@    22s  Learning in F[3]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    22s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    22s  F[2] /\ T /\ C+ ?
@    22s  	Ans. UNSAT
@    22s  F[3] unsat core #5 	(ucsz: 11 -> 9 -> 7 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s1) = t1)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(log(s0, i0) = t0)
	(log(s1, i0) = t2)
(clause)
	(~(currentTerm(s1) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(relations)
	currentTerm
	loglen
	log
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	(currentTerm(SERVER1) = TERM1)
(antecedent reduction)
@    22s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM2 -> [ (log(SERVER1, INDEX0) = TERM2), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ (log(SERVER1, INDEX0) = V:term:e5:), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
	TERM1 -> [ (currentTerm(SERVER1) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e5:) -> [ TERM2, ]
	(currentTerm(SERVER1) = V:term:e5:) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { TERM2, | TERM1, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (log(SERVER1, INDEX0) = TERM2), (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM1), (log(V:server:e5:, INDEX0) = TERM2), (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & (log(V:server:e5:, INDEX0) = TERM2) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX0) = TERM0) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM2 -> log(SERVER1, loglen(SERVER1))
	TERM0 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER1)
	TERM1 -> currentTerm(SERVER1)
(cube eq: post)
	~(currentTerm(SERVER1) = log(SERVER1, loglen(SERVER1)))
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1)))
	(loglen(SERVER0) = loglen(SERVER1))
	~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((currentTerm(SERVER1) = log(SERVER1, loglen(SERVER1))) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1))) | ~(loglen(SERVER0) = loglen(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((currentTerm(SERVER1) = log(SERVER1, loglen(SERVER1))) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1))) | ~(loglen(SERVER0) = loglen(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    22s  is global clause? No
@    22s  Learning in F[3]: (forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    22s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    22s  F[2] /\ T /\ C+ ?
@    22s  	Ans. UNSAT
@    22s  F[3] unsat core #6 	(ucsz: 11 -> 7 -> 7 -> 6 -> 6)
(minimal unsat core)
	~succ(i2, i0)
	(loglen(s1) = i0)
	(currentTerm(s1) = t2)
	(indzero = i2)
	(currentTerm(s0) = t0)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i2) | ~(loglen(s1) = i0) | ~leader(s0) | succ(i2, i0))
(relations)
	currentTerm
	leader
	loglen
	indzero
	succ
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	~succ(INDEX1, INDEX0)
	(loglen(SERVER1) = INDEX0)
	(indzero = INDEX1)
	leader(SERVER0)
(antecedent reduction)
@    22s  antecedent: 6 -> 4 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	INDEX1 -> indzero
(cube eq)
	~succ(indzero, INDEX0)
	(currentTerm(SERVER0) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	leader(SERVER0)
	(loglen(SERVER1) = INDEX0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX0
	TERM0
	TERM1
(antecedent eq)
	index:e5:
	-> ~(INDEX0 = indzero)
	term:e5:
	-> ~(TERM0 = TERM1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), (currentTerm(V:server:e5:) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), leader(V:server:e5:), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER1, ]
	((currentTerm(V:server:e5:) = TERM0) & leader(V:server:e5:)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER1)
	TERM1 -> currentTerm(SERVER1)
(cube eq: post)
	~(currentTerm(SERVER0) = currentTerm(SERVER1))
	~succ(indzero, loglen(SERVER1))
	~(loglen(SERVER1) = indzero)
	leader(SERVER0)
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | succ(indzero, loglen(SERVER1)) | (loglen(SERVER1) = indzero) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i2) | ~(loglen(s1) = i0) | ~leader(s0) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((currentTerm(SERVER0) = currentTerm(SERVER1)) | succ(indzero, loglen(SERVER1)) | (loglen(SERVER1) = indzero) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
@    22s  is global clause? No
@    22s  Learning in F[3]: (forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
@    22s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    22s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    22s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1			--> modified
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    22s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    23s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t2
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    23s  F[0] /\ T /\ C+ ?
@    23s  	Ans. UNSAT
@    23s  F[1] unsat core #5 	(ucsz: 5 -> 5)
(minimal unsat core)
	(termzero = t1)
	(currentTerm(s0) = t1)
	(currentTerm(s1) = t2)
	member(s0, q0)
	member(s0, q1)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(termzero = t1) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	currentTerm
	member
	termzero
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	(termzero = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(currentTerm(SERVER1) = TERM1)
(antecedent reduction)
@    23s  antecedent: 6 -> 4 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	TERM0 -> termzero
(cube eq)
	member(SERVER0, QUORUM1)
	(currentTerm(SERVER0) = termzero)
	member(SERVER0, QUORUM0)
	(currentTerm(SERVER1) = TERM1)
(qvars eq)
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
	TERM1
(antecedent eq)
	quorum:e5:
	-> ~(QUORUM0 = QUORUM1)
	term:e5:
	-> ~(termzero = TERM1)
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER0, V:quorum:e5:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e5:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e5:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e5: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (currentTerm(SERVER0) = termzero), member(SERVER0, QUORUM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = termzero), member(V:server:e5:, QUORUM0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = termzero) & member(V:server:e5:, QUORUM0)) -> [ SERVER0, ]
	(currentTerm(V:server:e5:) = TERM1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER1, TERM1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
(non-epr version)
	(forall SERVER1, TERM1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(termzero = t1) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM1, SERVER0 . (~(currentTerm(SERVER0) = termzero) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | (termzero = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    23s  is global clause? Yes
@    23s  Learning in F[3]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    23s  F[1] /\ T /\ C+ ?
@    23s  	Ans. UNSAT
@    23s  F[2] unsat core #5 	(ucsz: 8 -> 7 -> 5 -> 5)
(minimal unsat core)
	member(s0, q0)
	(currentTerm(s0) = t0)
	~lte(t2, t0)
	(currentTerm(s1) = t2)
	member(s0, q1)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t0))
(relations)
	currentTerm
	member
	lte
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	member(SERVER0, QUORUM0)
	member(SERVER0, QUORUM1)
	(currentTerm(SERVER0) = TERM0)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER1) = TERM1)
(antecedent reduction)
@    23s  antecedent: 6 -> 2 (reduced)
	removed: SERVER1
	removed: SERVER0
	removed: TERM0
	removed: TERM1

qv2cubes #2
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER0, V:quorum:e5:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e5:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e5:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e5: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ member(SERVER0, QUORUM0), (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), member(V:server:e5:, QUORUM0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM0) & member(V:server:e5:, QUORUM0)) -> [ SERVER0, ]
	(currentTerm(V:server:e5:) = TERM1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER1, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(non-epr version)
	(forall SERVER1, TERM0, TERM1, SERVER0 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t2, t0))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER1, TERM0, TERM1, SERVER0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~member(SERVER0, QUORUM0) | lte(TERM1, TERM0))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    23s  is global clause? Yes
@    23s  Learning in F[3]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    23s  F[2] /\ T /\ C+ ?
@    23s  	Ans. UNSAT
@    23s  F[3] unsat core #4 	(ucsz: 9 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s0) = t0)
	~lte(t2, t0)
	~member(s1, q0)
	(currentTerm(s1) = t2)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | lte(t2, t0) | member(s1, q0))
(relations)
	currentTerm
	member
	lte
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER1) = TERM1)
(antecedent reduction)
@    23s  antecedent: 4 -> 0 (reduced)
	removed: TERM0
	removed: TERM1
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM1), ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), ]
ucubes2qv #2
	(currentTerm(V:server:e5:) = TERM0) -> [ SERVER0, ]
	((currentTerm(V:server:e5:) = TERM1) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	TERM1 -> currentTerm(SERVER1)
(cube eq: post)
	~lte(currentTerm(SERVER1), currentTerm(SERVER0))
	~member(SERVER1, QUORUM0)
(qvars eq: post)
	SERVER1
	QUORUM0
	SERVER0
(boosted clause)
	(forall SERVER1, QUORUM0, SERVER0 . (lte(currentTerm(SERVER1), currentTerm(SERVER0)) | member(SERVER1, QUORUM0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | lte(t2, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall SERVER1, QUORUM0, SERVER0 . (lte(currentTerm(SERVER1), currentTerm(SERVER0)) | member(SERVER1, QUORUM0)))
---------------------------
(clause-type: univ)	(forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    23s  is global clause? Yes
@    24s  Learning in F[3]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    24s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    24s  F[2] /\ T /\ C+ ?
@    24s  	Ans. UNSAT
@    24s  F[3] unsat core #3 	(ucsz: 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s1, i2) = t1)
	leader(s1)
	committed(i1, t1)
(clause)
	(~(log(s1, i2) = t1) | ~committed(i1, t1) | ~leader(s1))
(relations)
	log
	committed
	leader
(cube: std)
	committed(INDEX0, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
(antecedent reduction)
@    24s  antecedent: 2 -> 2

(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
(cube eq: post)
	~(INDEX0 = INDEX1)
	committed(INDEX0, log(SERVER0, INDEX1))
	leader(SERVER0)
(qvars eq: post)
	INDEX1
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX1, INDEX0, SERVER0 . ((INDEX0 = INDEX1) | ~committed(INDEX0, log(SERVER0, INDEX1)) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s1, i2) = t1) | ~committed(i1, t1) | ~leader(s1))
(learnt sym-boosted clause)
	(forall INDEX1, INDEX0, SERVER0 . ((INDEX0 = INDEX1) | ~committed(INDEX0, log(SERVER0, INDEX1)) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
@    24s  is global clause? No
@    24s  Learning in F[3]: (forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
@    24s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    24s  F[2] /\ T /\ C+ ?
@    24s  	Ans. UNSAT
@    24s  F[3] unsat core #3 	(ucsz: 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i1) = t0)
	~member(s1, q0)
	committed(i1, t1)
(clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t1) | member(s1, q0))
(relations)
	member
	log
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    24s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    24s  is global clause? No
@    24s  Learning in F[3]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    24s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    24s  F[2] /\ T /\ C+ ?
@    24s  	Ans. UNSAT
@    24s  F[3] unsat core #4 	(ucsz: 12 -> 10 -> 9 -> 7 -> 4 -> 4)
(minimal unsat core)
	indlt(i2, i0)
	(loglen(s0) = i0)
	~succ(i2, i0)
	(loglen(s1) = i1)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~indlt(i2, i0) | succ(i2, i0))
(relations)
	loglen
	indlt
	succ
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	~succ(INDEX2, INDEX0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	indlt(INDEX2, INDEX0)
(antecedent reduction)
@    25s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	INDEX1 -> [ (loglen(SERVER1) = INDEX1), ]
	INDEX2 -> [ ~succ(INDEX2, INDEX0), indlt(INDEX2, INDEX0), ]
	INDEX0 -> [ ~succ(INDEX2, INDEX0), indlt(INDEX2, INDEX0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ (loglen(SERVER1) = V:index:e5:), ]
	INDEX2 -> [ indlt(V:index:e5:, INDEX0), ~succ(V:index:e5:, INDEX0), ]
	INDEX0 -> [ ~succ(INDEX2, V:index:e5:), indlt(INDEX2, V:index:e5:), (loglen(SERVER0) = V:index:e5:), ]
ucubes2qv #3
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX1, ]
	(indlt(V:index:e5:, INDEX0) & ~succ(V:index:e5:, INDEX0)) -> [ INDEX2, ]
	((loglen(SERVER0) = V:index:e5:) & indlt(INDEX2, V:index:e5:) & ~succ(INDEX2, V:index:e5:)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	indlt(INDEX2, loglen(SERVER0))
	~(loglen(SERVER0) = INDEX2)
	~succ(INDEX2, loglen(SERVER0))
	~(loglen(SERVER1) = INDEX2)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	SERVER1
	INDEX2
	SERVER0
(boosted clause)
	(forall SERVER1, INDEX2, SERVER0 . (~indlt(INDEX2, loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~indlt(i2, i0) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER1, INDEX2, SERVER0 . (~indlt(INDEX2, loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
@    25s  is global clause? No
@    25s  Learning in F[3]: (forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
@    25s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    25s  F[2] /\ T /\ C+ ?
@    25s  	Ans. UNSAT
@    25s  F[3] unsat core #3 	(ucsz: 5 -> 3 -> 3)
(minimal unsat core)
	leader(s0)
	(currentTerm(s0) = t2)
	committed(i2, t1)
(clause)
	(~(currentTerm(s0) = t2) | ~committed(i2, t1) | ~leader(s0))
(relations)
	currentTerm
	committed
	leader
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	committed(INDEX0, TERM0)
	leader(SERVER0)
(antecedent reduction)
@    25s  antecedent: 2 -> 2

(eq map: post)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	committed(INDEX0, TERM0)
	leader(SERVER0)
	~(TERM0 = currentTerm(SERVER0))
(qvars eq: post)
	INDEX0
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX0, TERM0, SERVER0 . (~committed(INDEX0, TERM0) | ~leader(SERVER0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~committed(i2, t1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0, SERVER0 . (~committed(INDEX0, TERM0) | ~leader(SERVER0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
@    25s  is global clause? No
@    25s  Learning in F[3]: (forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
@    25s  F[3] /\ T /\ !P+ -> UNSAT
Frames: #4
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #6
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
	F[3]: #21
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall T0 . ~committed(indzero, T0))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
@    25s  
Adding frame 4...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #12 to F[4]
@    26s  Learning in F[4]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    26s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    26s  Learning in F[4]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    26s  Learning in F[4]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    26s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@    26s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    26s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    26s  Learning in F[4]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    26s  Learning in F[4]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    26s  Learning in F[4]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    26s  Learning in F[4]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    26s  Learning in F[4]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    26s  Learning in F[4]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    26s  Learning in F[4]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    26s  Learning in F[4]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    26s  Learning in F[4]: (forall S0 . (log(S0, indzero) = termzero))
@    26s  Learning in F[4]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    26s  Learning in F[4]: (forall T0 . ~committed(indzero, T0))
@    26s  Learning in F[4]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    26s  Learning in F[4]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    26s  Learning in F[4]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    26s  Learning in F[4]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    26s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t2
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t2
	log(s1, i1) = t2
	log(s1, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    26s  F[3] /\ T /\ C+ ?
@    26s  	Ans. UNSAT
@    26s  F[4] unsat core #4 	(ucsz: 9 -> 7 -> 6 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i2)
	~leader(s1)
	committed(i2, t1)
	(loglen(s0) = i1)
(clause)
	(~(loglen(s0) = i1) | ~(loglen(s1) = i2) | ~committed(i2, t1) | leader(s1))
(relations)
	loglen
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
(antecedent reduction)
@    27s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ~leader(SERVER1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~leader(V:server:e5:), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER0, ]
	((loglen(V:server:e5:) = INDEX1) & ~leader(V:server:e5:)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(loglen(SERVER1), TERM0)
	~leader(SERVER1)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	SERVER1
	TERM0
	SERVER0
(boosted clause)
	(forall SERVER1, TERM0, SERVER0 . (~committed(loglen(SERVER1), TERM0) | leader(SERVER1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(loglen(s0) = i1) | ~(loglen(s1) = i2) | ~committed(i2, t1) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER1, TERM0, SERVER0 . (~committed(loglen(SERVER1), TERM0) | leader(SERVER1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
@    27s  is global clause? No
@    27s  Learning in F[4]: (forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
@    27s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    27s  F[3] /\ T /\ C+ ?
@    27s  	Ans. UNSAT
@    27s  F[4] unsat core #4 	(ucsz: 10 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i0)
	(log(s1, i0) = t0)
	~leader(s1)
	committed(i1, t0)
(clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i0) | ~committed(i1, t0) | leader(s1))
(relations)
	loglen
	log
	committed
	leader
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER0)
(antecedent reduction)
@    27s  antecedent: 2 -> 2

(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, log(SERVER0, loglen(SERVER0)))
	~(loglen(SERVER0) = INDEX1)
	~leader(SERVER0)
(qvars eq: post)
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, log(SERVER0, loglen(SERVER0))) | (loglen(SERVER0) = INDEX1) | leader(SERVER0)))
---------------------------
(original clause)
	(~(log(s1, i0) = t0) | ~(loglen(s1) = i0) | ~committed(i1, t0) | leader(s1))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0 . (~committed(INDEX1, log(SERVER0, loglen(SERVER0))) | (loglen(SERVER0) = INDEX1) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
@    27s  is global clause? No
@    27s  Learning in F[4]: (forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
@    27s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    27s  F[3] /\ T /\ C+ ?
@    27s  	Ans. UNSAT
@    27s  F[4] unsat core #4 	(ucsz: 11 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s0) = t0)
	(indzero = i0)
	(loglen(s1) = i0)
	committed(i2, t2)
(clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i2, t2))
(relations)
	currentTerm
	loglen
	indzero
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM1)
	(loglen(SERVER1) = INDEX0)
	(currentTerm(SERVER0) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    28s  antecedent: 6 -> 4 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM1)
	(loglen(SERVER1) = indzero)
	(currentTerm(SERVER0) = TERM0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	term:e5:
	-> ~(TERM0 = TERM1)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = indzero), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), ]
ucubes2qv #2
	(currentTerm(V:server:e5:) = TERM0) -> [ SERVER0, ]
	(loglen(V:server:e5:) = indzero) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	committed(INDEX1, TERM1)
	~(SERVER0 = SERVER1)
	(loglen(SERVER1) = indzero)
	~(currentTerm(SERVER0) = TERM1)
(qvars eq: post)
	SERVER1
	INDEX1
	TERM1
	SERVER0
(boosted clause)
	(forall SERVER1, INDEX1, TERM1, SERVER0 . (~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | ~(loglen(SERVER1) = indzero) | (currentTerm(SERVER0) = TERM1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i2, t2))
(learnt sym-boosted clause)
	(forall SERVER1, INDEX1, TERM1, SERVER0 . (~committed(INDEX1, TERM1) | (SERVER0 = SERVER1) | ~(loglen(SERVER1) = indzero) | (currentTerm(SERVER0) = TERM1)))
---------------------------
(clause-type: univ)	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@    28s  is global clause? No
@    28s  Learning in F[4]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@    28s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    28s  F[3] /\ T /\ C+ ?
@    28s  	Ans. UNSAT
@    28s  F[4] unsat core #4 	(ucsz: 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(indzero = i0)
	(loglen(s1) = i1)
	~leader(s1)
	committed(i2, t2)
(clause)
	(~(indzero = i0) | ~(loglen(s1) = i1) | ~committed(i2, t2) | leader(s1))
(relations)
	loglen
	indzero
	committed
	leader
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	committed(INDEX2, TERM0)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
	~leader(SERVER0)
(antecedent reduction)
@    28s  antecedent: 3 -> 3

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX2, TERM0)
	~leader(SERVER0)
(qvars eq)
	INDEX1
	INDEX2
	TERM0
	SERVER0
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
	-> ~(indzero = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	index:e5: -> [ indzero, INDEX1, INDEX2, ]
qv2cubes #3
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ]
	indzero -> [ ]
qv2ucubes #3
	INDEX1 -> [ (loglen(SERVER0) = V:index:e5:), ]
	INDEX2 -> [ committed(V:index:e5:, TERM0), ]
	indzero -> [ ]
ucubes2qv #3
	committed(V:index:e5:, TERM0) -> [ INDEX2, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX1, ]
	true -> [ indzero, ]
(partition) #3 index:e5: -> { INDEX2, | INDEX1, | indzero, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(indzero = INDEX2)
	~(loglen(SERVER0) = INDEX2)
	~(indzero = loglen(SERVER0))
	~leader(SERVER0)
	committed(INDEX2, TERM0)
(qvars eq: post)
	INDEX2
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX2, TERM0, SERVER0 . ((indzero = INDEX2) | (loglen(SERVER0) = INDEX2) | (indzero = loglen(SERVER0)) | leader(SERVER0) | ~committed(INDEX2, TERM0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s1) = i1) | ~committed(i2, t2) | leader(s1))
(learnt sym-boosted clause)
	(forall INDEX2, TERM0, SERVER0 . ((indzero = INDEX2) | (loglen(SERVER0) = INDEX2) | (indzero = loglen(SERVER0)) | leader(SERVER0) | ~committed(INDEX2, TERM0)))
---------------------------
(clause-type: univ)	(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
@    28s  is global clause? No
@    28s  Learning in F[4]: (forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
@    28s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    28s  F[3] /\ T /\ C+ ?
@    28s  	Ans. UNSAT
@    29s  F[4] unsat core #4 	(ucsz: 9 -> 5 -> 5 -> 4 -> 4)
(minimal unsat core)
	~leader(s0)
	(indzero = i0)
	committed(i2, t0)
	(loglen(s1) = i0)
(clause)
	(~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0) | leader(s0))
(relations)
	loglen
	indzero
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	~leader(SERVER0)
	(indzero = INDEX0)
(antecedent reduction)
@    29s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = indzero)
	~leader(SERVER0)
(qvars eq)
	INDEX1
	SERVER1
	TERM0
	SERVER0
(antecedent eq)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = indzero), ]
	SERVER0 -> [ ~leader(V:server:e5:), ]
ucubes2qv #2
	(loglen(V:server:e5:) = indzero) -> [ SERVER1, ]
	~leader(V:server:e5:) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s1) = i0) | ~committed(i2, t0) | leader(s0))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~(loglen(SERVER1) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@    29s  is global clause? No
@    29s  Learning in F[4]: (forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@    29s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    29s  F[3] /\ T /\ C+ ?
@    29s  	Ans. UNSAT
@    30s  F[4] unsat core #4 	(ucsz: 12 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i2)
	(currentTerm(s0) = t1)
	leader(s0)
	committed(i1, t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s1) = i2) | ~committed(i1, t0) | ~leader(s0))
(relations)
	currentTerm
	loglen
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX0, TERM0)
	leader(SERVER0)
(antecedent reduction)
@    30s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ leader(V:server:e5:), (currentTerm(V:server:e5:) = TERM1), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & leader(V:server:e5:)) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER1))
	committed(INDEX0, TERM0)
	leader(SERVER0)
	~(TERM0 = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM0 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s1) = i2) | ~committed(i1, t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM0 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | ~committed(INDEX0, TERM0) | ~leader(SERVER0) | (TERM0 = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
@    30s  is global clause? No
@    30s  Learning in F[4]: (forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
@    30s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    30s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    30s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    30s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
@    30s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false			--> modified
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    30s  F[1] /\ T /\ C+ ?
@    30s  	Ans. UNSAT
@    30s  F[2] unsat core #3 	(ucsz: 6 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s1) = i2)
	(termzero = t1)
	(log(s0, i2) = t2)
(clause)
	(~(log(s0, i2) = t2) | ~(loglen(s1) = i2) | ~(termzero = t1))
(relations)
	loglen
	log
	termzero
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@    30s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	SERVER1
	SERVER0
	TERM1
	INDEX0
(antecedent eq)
	term:e5:
	-> ~(termzero = TERM1)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM1), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, ]
	(log(V:server:e5:, INDEX0) = TERM1) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(termzero = log(SERVER0, loglen(SERVER1)))
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((SERVER0 = SERVER1) | (termzero = log(SERVER0, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(log(s0, i2) = t2) | ~(loglen(s1) = i2) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((SERVER0 = SERVER1) | (termzero = log(SERVER0, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
@    30s  is global clause? No
@    30s  Learning in F[2]: (forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
@    30s  F[2] /\ T /\ C+ ?
@    30s  	Ans. UNSAT
@    31s  F[3] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s1) = i2)
	(log(s0, i2) = t2)
	committed(i2, t2)
(clause)
	(~(log(s0, i2) = t2) | ~(loglen(s1) = i2) | ~committed(i2, t2))
(relations)
	loglen
	log
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX0, TERM0)
(antecedent reduction)
@    31s  antecedent: 2 -> 2

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1)))
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((SERVER0 = SERVER1) | ~committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(log(s0, i2) = t2) | ~(loglen(s1) = i2) | ~committed(i2, t2))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((SERVER0 = SERVER1) | ~committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
@    31s  is global clause? No
@    31s  Learning in F[3]: (forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
@    31s  F[3] /\ T /\ C+ ?
@    31s  	Ans. UNSAT
@    31s  F[4] unsat core #4 	(ucsz: 14 -> 10 -> 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s0) = t0)
	(loglen(s0) = i0)
	~member(s1, q1)
	committed(i2, t2)
(clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~committed(i2, t2) | member(s1, q1))
(relations)
	currentTerm
	loglen
	committed
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM1)
	(loglen(SERVER0) = INDEX0)
	(currentTerm(SERVER0) = TERM0)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@    31s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM0) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	committed(INDEX1, TERM1)
	~(loglen(SERVER0) = INDEX1)
	~(currentTerm(SERVER0) = TERM1)
	~member(SERVER1, QUORUM0)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((SERVER0 = SERVER1) | ~committed(INDEX1, TERM1) | (loglen(SERVER0) = INDEX1) | (currentTerm(SERVER0) = TERM1) | member(SERVER1, QUORUM0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(loglen(s0) = i0) | ~committed(i2, t2) | member(s1, q1))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((SERVER0 = SERVER1) | ~committed(INDEX1, TERM1) | (loglen(SERVER0) = INDEX1) | (currentTerm(SERVER0) = TERM1) | member(SERVER1, QUORUM0)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
@    31s  is global clause? No
@    31s  Learning in F[4]: (forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
@    31s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	leader(s0) = true
	leader(s1) = true			--> modified
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    32s  F[3] /\ T /\ C+ ?
@    32s  	Ans. UNSAT
@    32s  F[4] unsat core #3 	(ucsz: 7 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	committed(i1, t1)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(relations)
	loglen
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
(antecedent reduction)
@    32s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, SERVER0, ]
(partition) #1 server:e5: -> { SERVER1, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1, TERM0, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
(non-epr version)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t1))
(learnt sym-boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1))))
---------------------------
(clause-type: non-epr)	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    32s  is global clause? No
@    32s  Learning in F[4]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    32s  F[4] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[4])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    32s  F[3] /\ T /\ C+ ?
@    33s  	Ans. UNSAT
@    33s  F[4] unsat core #5 	(ucsz: 13 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i0) = t1)
	(log(s0, i0) = t0)
	(loglen(s1) = i0)
	(currentTerm(s1) = t2)
	leader(s1)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i0) | ~leader(s1))
(relations)
	currentTerm
	loglen
	log
	leader
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER1) = TERM2)
	leader(SERVER1)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@    33s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e5:), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e5:) -> [ TERM1, ]
	(currentTerm(SERVER1) = V:term:e5:) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM2), (log(SERVER1, INDEX0) = TERM1), leader(SERVER1), (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ leader(V:server:e5:), (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM1), (currentTerm(V:server:e5:) = TERM2), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	((currentTerm(V:server:e5:) = TERM2) & (log(V:server:e5:, INDEX0) = TERM1) & (loglen(V:server:e5:) = INDEX0) & leader(V:server:e5:)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM2 -> currentTerm(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	TERM1 -> log(SERVER1, loglen(SERVER1))
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1)))
	leader(SERVER1)
	~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1))) | ~leader(SERVER1) | (log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER1))) | ~leader(SERVER1) | (log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    33s  is global clause? No
@    33s  Learning in F[4]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    33s  F[4] /\ T /\ !P+ -> UNSAT
Frames: #5
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #7
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
	F[3]: #10
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
	F[4]: #20
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall T0 . ~committed(indzero, T0))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
		(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
@    34s  
Adding frame 5...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Forwarded #13 to F[5]
@    36s  Learning in F[5]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@    36s  Learning in F[5]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    36s  Learning in F[5]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    36s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@    36s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    36s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    36s  Learning in F[5]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    36s  Learning in F[5]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    36s  Learning in F[5]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  Learning in F[5]: (forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@    36s  Learning in F[5]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    36s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    36s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    36s  Learning in F[5]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    36s  Learning in F[5]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    36s  Learning in F[5]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    36s  Learning in F[5]: (forall S0 . (log(S0, indzero) = termzero))
@    36s  Learning in F[5]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    36s  Learning in F[5]: (forall T0 . ~committed(indzero, T0))
@    36s  Learning in F[5]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    36s  Learning in F[5]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    36s  Learning in F[5]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    36s  Learning in F[5]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    36s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t0			--> modified
	loglen(s0) = i1
	loglen(s1) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    36s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    36s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0			--> modified
	leader(s0) = true
	leader(s1) = false			--> modified
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    36s  F[3] /\ T /\ C+ ?
@    36s  	Ans. UNSAT
@    36s  F[4] unsat core #4 	(ucsz: 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	committed(i2, t0)
	~leader(s1)
	~succ(i2, i1)
	(loglen(s0) = i1)
(clause)
	(~(loglen(s0) = i1) | ~committed(i2, t0) | leader(s1) | succ(i2, i1))
(relations)
	leader
	loglen
	committed
	succ
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	~succ(INDEX1, INDEX0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
(antecedent reduction)
@    38s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ ~leader(SERVER1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~leader(V:server:e5:), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER0, ]
	~leader(V:server:e5:) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
	~leader(SERVER1)
(qvars eq: post)
	INDEX1
	SERVER1
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0)) | leader(SERVER1)))
---------------------------
(original clause)
	(~(loglen(s0) = i1) | ~committed(i2, t0) | leader(s1) | succ(i2, i1))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER1, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0)) | leader(SERVER1)))
---------------------------
(clause-type: univ)	(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)) | leader(S1))))
@    38s  is global clause? No
@    38s  Learning in F[4]: (forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | succ(I1, loglen(S0)) | leader(S1))))
@    38s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    38s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0			--> modified
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    38s  F[3] /\ T /\ C+ ?
@    38s  	Ans. UNSAT
@    39s  F[4] unsat core #5 	(ucsz: 16 -> 15 -> 14 -> 13 -> 12 -> 10 -> 9 -> 8 -> 7 -> 5 -> 5)
(minimal unsat core)
	committed(i2, t0)
	(loglen(s1) = i0)
	(log(s1, i0) = t2)
	~succ(i2, i1)
	(loglen(s0) = i1)
(clause)
	(~(log(s1, i0) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~committed(i2, t0) | succ(i2, i1))
(relations)
	loglen
	log
	committed
	succ
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	~succ(INDEX2, INDEX1)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX2, TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@    39s  antecedent: 7 -> 5 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ~succ(INDEX2, INDEX1), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ~succ(INDEX2, INDEX1), ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ ~succ(INDEX2, V:index:e5:), (loglen(SERVER0) = V:index:e5:), ]
	INDEX2 -> [ committed(V:index:e5:, TERM0), ~succ(V:index:e5:, INDEX1), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e5:), (log(SERVER1, V:index:e5:) = TERM1), ]
ucubes2qv #3
	((loglen(SERVER0) = V:index:e5:) & ~succ(INDEX2, V:index:e5:)) -> [ INDEX1, ]
	(committed(V:index:e5:, TERM0) & ~succ(V:index:e5:, INDEX1)) -> [ INDEX2, ]
	((log(SERVER1, V:index:e5:) = TERM1) & (loglen(SERVER1) = V:index:e5:)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX1), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX0) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER1, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	INDEX0 -> loglen(SERVER1)
	TERM1 -> log(SERVER1, loglen(SERVER1))
(cube eq: post)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(loglen(SERVER0) = INDEX2)
	~succ(INDEX2, loglen(SERVER0))
	~(loglen(SERVER1) = INDEX2)
	committed(INDEX2, TERM0)
	~(TERM0 = log(SERVER1, loglen(SERVER1)))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX2
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (TERM0 = log(SERVER1, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(log(s1, i0) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~committed(i2, t0) | succ(i2, i1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (TERM0 = log(SERVER1, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@    39s  is global clause? No
@    39s  Learning in F[4]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@    39s  F[4] /\ T /\ C+ ?
@    39s  	Ans. UNSAT
@    39s  F[5] unsat core #5 	(ucsz: 19 -> 15 -> 13 -> 11 -> 10 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i2, t0)
	(loglen(s1) = i0)
	(log(s1, i0) = t2)
	~succ(i2, i1)
	(loglen(s0) = i1)
(clause)
	(~(log(s1, i0) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~committed(i2, t0) | succ(i2, i1))
(relations)
	loglen
	log
	committed
	succ
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	~succ(INDEX2, INDEX1)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX2, TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@    40s  antecedent: 7 -> 5 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ~succ(INDEX2, INDEX1), ]
	INDEX2 -> [ committed(INDEX2, TERM0), ~succ(INDEX2, INDEX1), ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ ~succ(INDEX2, V:index:e5:), (loglen(SERVER0) = V:index:e5:), ]
	INDEX2 -> [ committed(V:index:e5:, TERM0), ~succ(V:index:e5:, INDEX1), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e5:), (log(SERVER1, V:index:e5:) = TERM1), ]
ucubes2qv #3
	((loglen(SERVER0) = V:index:e5:) & ~succ(INDEX2, V:index:e5:)) -> [ INDEX1, ]
	(committed(V:index:e5:, TERM0) & ~succ(V:index:e5:, INDEX1)) -> [ INDEX2, ]
	((log(SERVER1, V:index:e5:) = TERM1) & (loglen(SERVER1) = V:index:e5:)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX1), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX0) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER1, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	INDEX0 -> loglen(SERVER1)
	TERM1 -> log(SERVER1, loglen(SERVER1))
(cube eq: post)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(loglen(SERVER0) = INDEX2)
	~succ(INDEX2, loglen(SERVER0))
	~(loglen(SERVER1) = INDEX2)
	committed(INDEX2, TERM0)
	~(TERM0 = log(SERVER1, loglen(SERVER1)))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX2
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (TERM0 = log(SERVER1, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(log(s1, i0) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~committed(i2, t0) | succ(i2, i1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER0) = INDEX2) | succ(INDEX2, loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (TERM0 = log(SERVER1, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@    40s  is global clause? No
@    40s  Learning in F[5]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@    40s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1			--> modified
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    40s  F[4] /\ T /\ C+ ?
@    40s  	Ans. UNSAT
@    40s  F[5] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i2)
	~leader(s0)
	(currentTerm(s1) = t2)
	(log(s1, i2) = t0)
	committed(i0, t1)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i2) = t0) | ~(loglen(s1) = i2) | ~committed(i0, t1) | leader(s0))
(relations)
	currentTerm
	loglen
	log
	committed
	leader
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER1) = TERM2)
	(log(SERVER1, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX0, TERM1)
	~leader(SERVER0)
(antecedent reduction)
@    40s  antecedent: 7 -> 6 (reduced)
	removed: TERM1

qv2cubes #3
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
	TERM0 -> [ (log(SERVER1, INDEX1) = TERM0), ]
	TERM1 -> [ committed(INDEX0, TERM1), ]
qv2ucubes #3
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e5:), ]
	TERM0 -> [ (log(SERVER1, INDEX1) = V:term:e5:), ]
	TERM1 -> [ committed(INDEX0, V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, INDEX1) = V:term:e5:) -> [ TERM0, ]
	(currentTerm(SERVER1) = V:term:e5:) -> [ TERM2, ]
	committed(INDEX0, V:term:e5:) -> [ TERM1, ]
(partition) #3 term:e5: -> { TERM0, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM2), (log(SERVER1, INDEX1) = TERM0), (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), (log(V:server:e5:, INDEX1) = TERM0), (currentTerm(V:server:e5:) = TERM2), ]
	SERVER0 -> [ ~leader(V:server:e5:), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM2) & (log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER1, ]
	~leader(V:server:e5:) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM2 -> currentTerm(SERVER1)
	TERM0 -> log(SERVER1, loglen(SERVER1))
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER1))
	~leader(SERVER0)
	committed(INDEX0, TERM1)
	~(log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | leader(SERVER0) | ~committed(INDEX0, TERM1) | (log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i2) = t0) | ~(loglen(s1) = i2) | ~committed(i0, t1) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | leader(SERVER0) | ~committed(INDEX0, TERM1) | (log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
@    40s  is global clause? No
@    40s  Learning in F[5]: (forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
@    40s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    40s  F[4] /\ T /\ C+ ?
@    40s  	Ans. UNSAT
@    41s  F[5] unsat core #4 	(ucsz: 12 -> 7 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	~member(s1, q0)
	(log(s0, i1) = t1)
	committed(i1, t0)
(clause)
	(~(log(s0, i1) = t1) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(relations)
	loglen
	log
	committed
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX1) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@    41s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX1) = TERM1), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX1) = TERM1), (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX1) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, INDEX1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	committed(INDEX1, TERM0)
	~(loglen(SERVER0) = INDEX1)
	~member(SERVER1, QUORUM0)
	~(TERM0 = log(SERVER0, INDEX1))
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . ((SERVER0 = SERVER1) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | (TERM0 = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t1) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . ((SERVER0 = SERVER1) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | (TERM0 = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | (T0 = log(S0, I1)))))
@    41s  is global clause? No
@    41s  Learning in F[5]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | (T0 = log(S0, I1)))))
@    41s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	leader(s0) = true
	leader(s1) = true			--> modified
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    41s  F[4] /\ T /\ C+ ?
@    41s  	Ans. UNSAT
@    41s  F[5] unsat core #4 	(ucsz: 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(indzero = i0)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(relations)
	loglen
	indzero
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
(antecedent reduction)
@    42s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = indzero)
	(loglen(SERVER0) = indzero)
(qvars eq)
	INDEX1
	SERVER1
	TERM0
	SERVER0
(antecedent eq)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = indzero), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), ]
ucubes2qv #1
	(loglen(V:server:e5:) = indzero) -> [ SERVER1, SERVER0, ]
(partition) #1 server:e5: -> { SERVER1, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1, TERM0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
(non-epr version)
	(forall INDEX1, TERM0 . (exists SERVER0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER0 . (forall INDEX1, TERM0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(exists SERVER0 . (forall INDEX1, TERM0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
---------------------------
(clause-type: epr)	(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@    42s  is global clause? Yes
@    42s  Learning in F[5]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@    42s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    42s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    43s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    43s  F[3] /\ T /\ C+ ?
@    43s  	Ans. UNSAT
@    43s  F[4] unsat core #4 	(ucsz: 10 -> 6 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i2)
	(indzero = i0)
	~member(s1, q0)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~(loglen(s1) = i2) | ~committed(i1, t0) | member(s1, q0))
(relations)
	loglen
	indzero
	committed
	member
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX2)
	~member(SERVER0, QUORUM0)
	(indzero = INDEX0)
(antecedent reduction)
@    44s  antecedent: 3 -> 3

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX2)
	~member(SERVER0, QUORUM0)
(qvars eq)
	QUORUM0
	SERVER0
	INDEX1
	INDEX2
	TERM0
(antecedent eq)
	index:e5:
	-> ~(indzero = INDEX1)
	-> ~(indzero = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	index:e5: -> [ indzero, INDEX1, INDEX2, ]
qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = INDEX2), ]
	indzero -> [ ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = V:index:e5:), ]
	indzero -> [ ]
ucubes2qv #3
	committed(V:index:e5:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX2, ]
	true -> [ indzero, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | indzero, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(INDEX1 = loglen(SERVER0))
	~(indzero = loglen(SERVER0))
	~(indzero = INDEX1)
	~member(SERVER0, QUORUM0)
(qvars eq: post)
	INDEX1
	QUORUM0
	TERM0
	SERVER0
(boosted clause)
	(forall INDEX1, QUORUM0, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (INDEX1 = loglen(SERVER0)) | (indzero = loglen(SERVER0)) | (indzero = INDEX1) | member(SERVER0, QUORUM0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s1) = i2) | ~committed(i1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall INDEX1, QUORUM0, TERM0, SERVER0 . (~committed(INDEX1, TERM0) | (INDEX1 = loglen(SERVER0)) | (indzero = loglen(SERVER0)) | (indzero = INDEX1) | member(SERVER0, QUORUM0)))
---------------------------
(clause-type: univ)	(forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
@    44s  is global clause? No
@    44s  Learning in F[4]: (forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
@    44s  F[4] /\ T /\ C+ ?
@    44s  	Ans. UNSAT
@    44s  F[5] unsat core #5 	(ucsz: 14 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i2)
	(currentTerm(s0) = t1)
	(loglen(s0) = i0)
	~member(s1, q0)
	committed(i1, t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t0) | member(s1, q0))
(relations)
	currentTerm
	loglen
	committed
	member
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER1) = INDEX2)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@    44s  antecedent: 7 -> 5 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM0), ]
	INDEX2 -> [ (loglen(SERVER1) = V:index:e5:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e5:), ]
ucubes2qv #3
	committed(V:index:e5:, TERM0) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX2, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX2), ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), (loglen(V:server:e5:) = INDEX2), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), (currentTerm(V:server:e5:) = TERM1), ]
ucubes2qv #2
	((loglen(V:server:e5:) = INDEX2) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
	((currentTerm(V:server:e5:) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
	TERM1 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX1 = loglen(SERVER1))
	~member(SERVER1, QUORUM0)
	~(TERM0 = currentTerm(SERVER0))
	committed(INDEX1, TERM0)
	~(loglen(SERVER0) = INDEX1)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . ((INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (TERM0 = currentTerm(SERVER0)) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . ((INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (TERM0 = currentTerm(SERVER0)) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@    44s  is global clause? No
@    44s  Learning in F[5]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@    44s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    44s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    45s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    45s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
@    45s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    45s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    45s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t1			--> modified
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    45s  F[1] /\ T /\ C+ ?
@    45s  	Ans. UNSAT
@    45s  F[2] unsat core #3 	(ucsz: 6 -> 3 -> 3)
(minimal unsat core)
	~leader(s0)
	(termzero = t2)
	(log(s0, i1) = t0)
(clause)
	(~(log(s0, i1) = t0) | ~(termzero = t2) | leader(s0))
(relations)
	log
	termzero
	leader
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
	(termzero = TERM1)
(antecedent reduction)
@    45s  antecedent: 2 -> 2

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	~leader(SERVER0)
(qvars eq)
	SERVER0
	TERM0
	INDEX0
(antecedent eq)
	term:e5:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~leader(SERVER0)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (leader(SERVER0) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~(termzero = t2) | leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (leader(SERVER0) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
@    45s  is global clause? No
@    45s  Learning in F[2]: (forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
@    45s  F[2] /\ T /\ C+ ?
@    45s  	Ans. UNSAT
@    45s  F[3] unsat core #5 	(ucsz: 11 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~leader(s0)
	(loglen(s0) = i0)
	(log(s0, i1) = t0)
	(log(s1, i0) = t2)
	(loglen(s1) = i1)
(clause)
	(~(log(s0, i1) = t0) | ~(log(s1, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | leader(s0))
(relations)
	loglen
	log
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	~leader(SERVER0)
(antecedent reduction)
@    46s  antecedent: 6 -> 4 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #2
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX1) = TERM0), ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (log(V:server:e5:, INDEX0) = TERM1), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ~leader(V:server:e5:), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX0) = TERM1) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = INDEX0) & ~leader(V:server:e5:)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER1, loglen(SERVER0))
(cube eq: post)
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0)))
	~leader(SERVER0)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | leader(SERVER0) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~(log(s1, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | leader(SERVER0) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
@    46s  is global clause? No
@    46s  Learning in F[3]: (forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
@    46s  F[3] /\ T /\ C+ ?
@    46s  	Ans. UNSAT
@    46s  F[4] unsat core #4 	(ucsz: 11 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	~leader(s0)
	(loglen(s0) = i0)
	~member(s1, q0)
	committed(i1, t0)
(clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s0) | member(s1, q0))
(relations)
	loglen
	member
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER0)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@    47s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ~leader(V:server:e5:), ]
ucubes2qv #2
	((loglen(V:server:e5:) = INDEX0) & ~leader(V:server:e5:)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	~member(SERVER1, QUORUM0)
	~leader(SERVER0)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | leader(SERVER0)))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
@    47s  is global clause? No
@    47s  Learning in F[4]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
@    47s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    47s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    47s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
@    47s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    47s  F[2] /\ T /\ C+ ?
@    47s  	Ans. UNSAT
@    47s  F[3] unsat core #5 	(ucsz: 14 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t0)
	(loglen(s0) = i0)
	(log(s0, i0) = t2)
	(log(s0, i1) = t0)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i0) = t2) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1))
(relations)
	currentTerm
	loglen
	log
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
(antecedent reduction)
@    48s  antecedent: 6 -> 2 (reduced)
	removed: SERVER1
	removed: INDEX0
	removed: SERVER0
	removed: INDEX1

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX1) = TERM0), (currentTerm(SERVER0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM1), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM0) & (log(V:server:e5:, INDEX0) = TERM1) & (log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, loglen(SERVER0))
(cube eq: post)
	~(currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))
	(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | ~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i0) = t2) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | ~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
@    48s  is global clause? No
@    48s  Learning in F[3]: (forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
@    48s  F[3] /\ T /\ C+ ?
@    48s  	Ans. UNSAT
@    48s  F[4] unsat core #4 	(ucsz: 14 -> 13 -> 12 -> 11 -> 9 -> 8 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s0) = i0)
	~member(s1, q0)
	(indzero = i0)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(relations)
	loglen
	indzero
	committed
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~member(SERVER1, QUORUM0)
	(indzero = INDEX0)
(antecedent reduction)
@    49s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	~member(SERVER1, QUORUM0)
(qvars eq)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(antecedent eq)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), ]
ucubes2qv #2
	(loglen(V:server:e5:) = indzero) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | member(SERVER1, QUORUM0)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
@    49s  is global clause? No
@    49s  Learning in F[4]: (forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
@    49s  F[4] /\ T /\ C+ ?
@    49s  	Ans. UNSAT
@    49s  F[5] unsat core #5 	(ucsz: 14 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t1)
	(loglen(s0) = i0)
	~member(s1, q0)
	committed(i1, t0)
	(log(s0, i0) = t2)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(relations)
	currentTerm
	loglen
	log
	committed
	member
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	~member(SERVER1, QUORUM0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@    50s  antecedent: 7 -> 5 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #3
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), ]
	TERM0 -> [ committed(INDEX1, TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
	TERM0 -> [ committed(INDEX1, V:term:e5:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e5:), ]
ucubes2qv #3
	committed(INDEX1, V:term:e5:) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e5:) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM2, ]
(partition) #3 term:e5: -> { TERM0, | TERM1, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), (log(SERVER0, INDEX0) = TERM2), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM2), (currentTerm(V:server:e5:) = TERM1), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & (log(V:server:e5:, INDEX0) = TERM2) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM2 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~member(SERVER1, QUORUM0)
	~(TERM0 = currentTerm(SERVER0))
	committed(INDEX1, TERM0)
	~(currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))
	~(TERM0 = log(SERVER0, loglen(SERVER0)))
	~(SERVER0 = SERVER1)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (member(SERVER1, QUORUM0) | (TERM0 = currentTerm(SERVER0)) | ~committed(INDEX1, TERM0) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | (TERM0 = log(SERVER0, loglen(SERVER0))) | (SERVER0 = SERVER1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(loglen(s0) = i0) | ~committed(i1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (member(SERVER1, QUORUM0) | (TERM0 = currentTerm(SERVER0)) | ~committed(INDEX1, TERM0) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | (TERM0 = log(SERVER0, loglen(SERVER0))) | (SERVER0 = SERVER1)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
@    50s  is global clause? No
@    50s  Learning in F[5]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
@    50s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    50s  F[4] /\ T /\ C+ ?
@    50s  	Ans. UNSAT
@    50s  F[5] unsat core #4 	(ucsz: 15 -> 11 -> 9 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i0)
	(loglen(s0) = i0)
	~succ(i2, i0)
	committed(i2, t2)
(clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t2) | succ(i2, i0))
(relations)
	loglen
	committed
	succ
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	~succ(INDEX1, INDEX0)
(antecedent reduction)
@    51s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #1
	(loglen(V:server:e5:) = INDEX0) -> [ SERVER1, SERVER0, ]
(partition) #1 server:e5: -> { SERVER1, SERVER0, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
(epr reduced)
	(exists SERVER0 . (forall INDEX1, TERM0, INDEX0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX1, INDEX0))))
(non-epr version)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX1, INDEX0))))
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX1, INDEX0))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~committed(i2, t2) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall INDEX1, TERM0, INDEX0 . (exists SERVER0 . (~(loglen(SERVER0) = INDEX0) | ~committed(INDEX1, TERM0) | (INDEX0 = INDEX1) | succ(INDEX1, INDEX0))))
---------------------------
(clause-type: non-epr)	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@    51s  is global clause? No
@    51s  Learning in F[5]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@    51s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t1			--> modified
	log(s1, i1) = t0
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i1			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    51s  F[4] /\ T /\ C+ ?
@    51s  	Ans. UNSAT
@    51s  F[5] unsat core #3 	(ucsz: 13 -> 11 -> 10 -> 8 -> 6 -> 5 -> 3 -> 3)
(minimal unsat core)
	committed(i0, t1)
	(log(s0, i0) = t0)
	~member(s1, q0)
(clause)
	(~(log(s0, i0) = t0) | ~committed(i0, t1) | member(s1, q0))
(relations)
	member
	log
	committed
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    51s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~committed(i0, t1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    51s  is global clause? No
@    51s  Learning in F[5]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
@    51s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2			--> modified
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@    52s  F[4] /\ T /\ C+ ?
@    52s  	Ans. UNSAT
@    52s  F[5] unsat core #5 	(ucsz: 13 -> 10 -> 10 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i2)
	(currentTerm(s1) = t1)
	committed(i0, t2)
	~succ(i0, i2)
	~member(s0, q0)
(clause)
	(~(currentTerm(s1) = t1) | ~(loglen(s1) = i2) | ~committed(i0, t2) | member(s0, q0) | succ(i0, i2))
(relations)
	currentTerm
	member
	loglen
	committed
	succ
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	~succ(INDEX0, INDEX1)
	~member(SERVER0, QUORUM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@    52s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM0), (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ ~member(SERVER0, QUORUM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ ~member(V:server:e5:, QUORUM0), ]
ucubes2qv #2
	~member(V:server:e5:, QUORUM0) -> [ SERVER0, ]
	((currentTerm(V:server:e5:) = TERM0) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> currentTerm(SERVER1)
(cube eq: post)
	~member(SERVER0, QUORUM0)
	~succ(INDEX0, loglen(SERVER1))
	~(INDEX0 = loglen(SERVER1))
	~(SERVER0 = SERVER1)
	committed(INDEX0, TERM1)
	~(currentTerm(SERVER1) = TERM1)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . (member(SERVER0, QUORUM0) | succ(INDEX0, loglen(SERVER1)) | (INDEX0 = loglen(SERVER1)) | (SERVER0 = SERVER1) | ~committed(INDEX0, TERM1) | (currentTerm(SERVER1) = TERM1)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t1) | ~(loglen(s1) = i2) | ~committed(i0, t2) | member(s0, q0) | succ(i0, i2))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . (member(SERVER0, QUORUM0) | succ(INDEX0, loglen(SERVER1)) | (INDEX0 = loglen(SERVER1)) | (SERVER0 = SERVER1) | ~committed(INDEX0, TERM1) | (currentTerm(SERVER1) = TERM1)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@    53s  is global clause? No
@    53s  Learning in F[5]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@    53s  F[5] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t1			--> modified
	log(s1, i1) = t2
	log(s1, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@    53s  F[4] /\ T /\ C+ ?
@    53s  	Ans. UNSAT
@    53s  F[5] unsat core #4 	(ucsz: 10 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i2)
	committed(i0, t1)
	~succ(i0, i2)
	~leader(s0)
(clause)
	(~(loglen(s1) = i2) | ~committed(i0, t1) | leader(s0) | succ(i0, i2))
(relations)
	leader
	loglen
	committed
	succ
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX0, TERM0)
	~succ(INDEX0, INDEX1)
	~leader(SERVER0)
(antecedent reduction)
@    53s  antecedent: 4 -> 4

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ ~leader(V:server:e5:), ]
ucubes2qv #2
	~leader(V:server:e5:) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER1))
	committed(INDEX0, TERM0)
	~leader(SERVER0)
	~succ(INDEX0, loglen(SERVER1))
(qvars eq: post)
	SERVER1
	TERM0
	INDEX0
	SERVER0
(boosted clause)
	(forall SERVER1, TERM0, INDEX0, SERVER0 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | ~committed(INDEX0, TERM0) | leader(SERVER0) | succ(INDEX0, loglen(SERVER1))))
---------------------------
(original clause)
	(~(loglen(s1) = i2) | ~committed(i0, t1) | leader(s0) | succ(i0, i2))
(learnt sym-boosted clause)
	(forall SERVER1, TERM0, INDEX0, SERVER0 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | ~committed(INDEX0, TERM0) | leader(SERVER0) | succ(INDEX0, loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@    53s  is global clause? No
@    53s  Learning in F[5]: (forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@    53s  F[5] /\ T /\ !P+ -> UNSAT
Frames: #6
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #8
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
		(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
	F[3]: #12
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
		(forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
	F[4]: #9
		(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
		(forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
		(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
		(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
		(forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
	F[5]: #22
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(forall T0 . ~committed(indzero, T0))
		(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
		(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@    55s  
Adding frame 6...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Trying forwarding F[5]
Forwarded #17 to F[6]
@    60s  Learning in F[6]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@    60s  Learning in F[6]: (forall T0 . ~committed(indzero, T0))
@    60s  Learning in F[6]: (forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@    60s  Learning in F[6]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@    60s  Learning in F[6]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    60s  Learning in F[6]: (forall S0 . (log(S0, indzero) = termzero))
@    60s  Learning in F[6]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    60s  Learning in F[6]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    60s  Learning in F[6]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    60s  Learning in F[6]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@    60s  Learning in F[6]: (forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@    60s  Learning in F[6]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    60s  Learning in F[6]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    60s  Learning in F[6]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    60s  Learning in F[6]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@    60s  Learning in F[6]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@    60s  Learning in F[6]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@    60s  Learning in F[6]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@    60s  Learning in F[6]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@    60s  Learning in F[6]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@    60s  Learning in F[6]: (forall S0 . (log(S0, indzero) = termzero))
@    60s  Learning in F[6]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@    60s  Learning in F[6]: (forall T0 . ~committed(indzero, T0))
@    60s  Learning in F[6]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@    60s  Learning in F[6]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@    60s  Learning in F[6]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@    60s  Learning in F[6]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@    60s  Learning in F[6]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@    60s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[6])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0			--> modified
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1			--> modified
	loglen(s1) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    60s  F[5] /\ T /\ C+ ?
@    60s  	Ans. UNSAT
@    61s  F[6] unsat core #6 	(ucsz: 19 -> 15 -> 14 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~succ(i0, i1)
	(loglen(s0) = i1)
	(log(s0, i1) = t0)
	~member(s1, q0)
	(currentTerm(s0) = t2)
	committed(i0, t0)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~committed(i0, t0) | member(s1, q0) | succ(i0, i1))
(relations)
	currentTerm
	loglen
	committed
	log
	succ
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX0, TERM0)
	(currentTerm(SERVER0) = TERM1)
	~succ(INDEX0, INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
(antecedent reduction)
@    61s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX1) = TERM0), (currentTerm(V:server:e5:) = TERM1), (loglen(V:server:e5:) = INDEX1), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM1) & (log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, log(SERVER0, loglen(SERVER0)))
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0))
	~succ(INDEX0, loglen(SERVER0))
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER0))
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0 . (member(SERVER1, QUORUM0) | ~committed(INDEX0, log(SERVER0, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | succ(INDEX0, loglen(SERVER0)) | (SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~committed(i0, t0) | member(s1, q0) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0 . (member(SERVER1, QUORUM0) | ~committed(INDEX0, log(SERVER0, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER0)) | succ(INDEX0, loglen(SERVER0)) | (SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I0 . (committed(I0, log(S0, loglen(S0))) -> (member(S1, Q0) | (log(S0, loglen(S0)) = currentTerm(S0)) | succ(I0, loglen(S0)) | (S0 = S1) | (I0 = loglen(S0)))))
@    61s  is global clause? No
@    61s  Learning in F[6]: (forall Q0, S0, S1, I0 . (committed(I0, log(S0, loglen(S0))) -> (member(S1, Q0) | (log(S0, loglen(S0)) = currentTerm(S0)) | succ(I0, loglen(S0)) | (S0 = S1) | (I0 = loglen(S0)))))
@    61s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    62s  F[5] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    62s  	Ans. SAT
(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    62s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
@    62s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    62s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    62s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = false
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    62s  F[2] /\ T /\ C+ ?
@    62s  	Ans. UNSAT
@    62s  F[3] unsat core #6 	(ucsz: 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~lte(t2, t0)
	(log(s0, i1) = t0)
	(loglen(s1) = i0)
	~leader(s0)
	(log(s1, i0) = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i0) | leader(s0) | lte(t2, t0))
(relations)
	loglen
	log
	indzero
	lte
	leader
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	~leader(SERVER0)
	~lte(TERM2, TERM0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    63s  antecedent: 7 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1
	removed: INDEX0
	removed: TERM2
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~lte(TERM2, TERM0)
	(loglen(SERVER1) = indzero)
	(log(SERVER1, indzero) = TERM1)
	(log(SERVER0, INDEX1) = TERM0)
	~leader(SERVER0)
(qvars eq)
	TERM2
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	term:e5:
	-> ~(TERM0 = TERM1)
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM2 -> [ ~lte(TERM2, TERM0), ]
	TERM0 -> [ ~lte(TERM2, TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER1, indzero) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ ~lte(V:term:e5:, TERM0), ]
	TERM0 -> [ ~lte(TERM2, V:term:e5:), (log(SERVER0, INDEX1) = V:term:e5:), ]
	TERM1 -> [ (log(SERVER1, indzero) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, indzero) = V:term:e5:) -> [ TERM1, ]
	((log(SERVER0, INDEX1) = V:term:e5:) & ~lte(TERM2, V:term:e5:)) -> [ TERM0, ]
	~lte(V:term:e5:, TERM0) -> [ TERM2, ]
(partition) #3 term:e5: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = indzero), (log(SERVER1, indzero) = TERM1), ]
	SERVER0 -> [ (log(SERVER0, INDEX1) = TERM0), ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = indzero), (log(V:server:e5:, indzero) = TERM1), ]
	SERVER0 -> [ ~leader(V:server:e5:), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX1) = TERM0) & ~leader(V:server:e5:)) -> [ SERVER0, ]
	((log(V:server:e5:, indzero) = TERM1) & (loglen(V:server:e5:) = indzero)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	TERM1 -> log(SERVER1, indzero)
(cube eq: post)
	(loglen(SERVER1) = indzero)
	~lte(TERM2, log(SERVER0, INDEX1))
	~leader(SERVER0)
	~(log(SERVER0, INDEX1) = log(SERVER1, indzero))
(qvars eq: post)
	TERM2
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall TERM2, SERVER0, SERVER1, INDEX1 . (~(loglen(SERVER1) = indzero) | lte(TERM2, log(SERVER0, INDEX1)) | leader(SERVER0) | (log(SERVER0, INDEX1) = log(SERVER1, indzero))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s1) = i0) | leader(s0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall TERM2, SERVER0, SERVER1, INDEX1 . (~(loglen(SERVER1) = indzero) | lte(TERM2, log(SERVER0, INDEX1)) | leader(SERVER0) | (log(SERVER0, INDEX1) = log(SERVER1, indzero))))
---------------------------
(clause-type: univ)	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@    63s  is global clause? No
@    63s  Learning in F[3]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@    63s  F[3] /\ T /\ C+ ?
@    63s  	Ans. UNSAT
@    64s  F[4] unsat core #7 	(ucsz: 17 -> 15 -> 12 -> 11 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	~lte(t2, t0)
	(log(s0, i1) = t0)
	~leader(s0)
	(log(s1, i0) = t1)
	(indzero = i0)
	(loglen(s0) = i0)
	(loglen(s1) = i1)
(clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | leader(s0) | lte(t2, t0))
(relations)
	loglen
	log
	indzero
	lte
	leader
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	~lte(TERM2, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    64s  antecedent: 7 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1
	removed: INDEX0
	removed: TERM2
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	~lte(TERM2, TERM0)
	(log(SERVER1, indzero) = TERM1)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, INDEX1) = TERM0)
(qvars eq)
	TERM2
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	term:e5:
	-> ~(TERM0 = TERM1)
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #3
	TERM2 -> [ ~lte(TERM2, TERM0), ]
	TERM0 -> [ ~lte(TERM2, TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER1, indzero) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ ~lte(V:term:e5:, TERM0), ]
	TERM0 -> [ ~lte(TERM2, V:term:e5:), (log(SERVER0, INDEX1) = V:term:e5:), ]
	TERM1 -> [ (log(SERVER1, indzero) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, indzero) = V:term:e5:) -> [ TERM1, ]
	((log(SERVER0, INDEX1) = V:term:e5:) & ~lte(TERM2, V:term:e5:)) -> [ TERM0, ]
	~lte(V:term:e5:, TERM0) -> [ TERM2, ]
(partition) #3 term:e5: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), (log(SERVER1, indzero) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ~leader(SERVER0), (log(SERVER0, INDEX1) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (log(V:server:e5:, indzero) = TERM1), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), ~leader(V:server:e5:), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((log(V:server:e5:, indzero) = TERM1) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = indzero) & ~leader(V:server:e5:)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	TERM1 -> log(SERVER1, indzero)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, indzero))
	(loglen(SERVER0) = indzero)
	~leader(SERVER0)
	~lte(TERM2, log(SERVER0, loglen(SERVER1)))
(qvars eq: post)
	TERM2
	SERVER0
	SERVER1
(boosted clause)
	(forall TERM2, SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = log(SERVER1, indzero)) | ~(loglen(SERVER0) = indzero) | leader(SERVER0) | lte(TERM2, log(SERVER0, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | leader(s0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall TERM2, SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = log(SERVER1, indzero)) | ~(loglen(SERVER0) = indzero) | leader(SERVER0) | lte(TERM2, log(SERVER0, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@    64s  is global clause? No
@    64s  Learning in F[4]: (forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@    64s  F[4] /\ T /\ C+ ?
@    64s  	Ans. UNSAT
@    65s  F[5] unsat core #6 	(ucsz: 14 -> 13 -> 12 -> 10 -> 9 -> 7 -> 6 -> 6)
(minimal unsat core)
	~lte(t2, t0)
	(loglen(s0) = i0)
	~member(s1, q0)
	~leader(s0)
	(indzero = i0)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s0) | lte(t2, t0) | member(s1, q0))
(relations)
	loglen
	indzero
	lte
	member
	committed
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER0)
	~lte(TERM1, TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    65s  antecedent: 6 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: TERM0
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	~member(SERVER1, QUORUM0)
	~lte(TERM1, TERM0)
	~leader(SERVER0)
(qvars eq)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ~leader(SERVER0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), ~leader(V:server:e5:), ]
ucubes2qv #2
	((loglen(V:server:e5:) = indzero) & ~leader(V:server:e5:)) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0, TERM1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0) | lte(TERM1, TERM0) | member(SERVER1, QUORUM0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i1, t0) | leader(s0) | lte(t2, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0, TERM1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | leader(SERVER0) | lte(TERM1, TERM0) | member(SERVER1, QUORUM0)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
@    65s  is global clause? No
@    65s  Learning in F[5]: (forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
@    65s  F[5] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    65s  	Ans. SAT
(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    65s  F[4] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e6 with value True
	inputs:
actionName ext:commitEntry
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
@    65s  	Ans. SAT
(cube in F[4])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    65s  F[3] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
@    65s  	Ans. SAT
(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    65s  F[2] /\ T /\ C+ ?
@    65s  	Ans. UNSAT
@    66s  F[3] unsat core #6 	(ucsz: 16 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~lte(t2, t0)
	(currentTerm(s1) = t0)
	(log(s1, i1) = t0)
	(loglen(s1) = i0)
	(log(s1, i0) = t1)
	leader(s1)
(clause)
	(~(currentTerm(s1) = t0) | ~(log(s1, i0) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i0) | ~leader(s1) | lte(t2, t0))
(relations)
	currentTerm
	loglen
	log
	lte
	leader
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	~lte(TERM2, TERM0)
	leader(SERVER0)
(antecedent reduction)
@    66s  antecedent: 5 -> 2 (reduced)
	removed: INDEX0
	removed: TERM2
	removed: INDEX1

qv2cubes #3
	TERM2 -> [ ~lte(TERM2, TERM0), ]
	TERM0 -> [ ~lte(TERM2, TERM0), (currentTerm(SERVER0) = TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ ~lte(V:term:e5:, TERM0), ]
	TERM0 -> [ ~lte(TERM2, V:term:e5:), (log(SERVER0, INDEX1) = V:term:e5:), (currentTerm(SERVER0) = V:term:e5:), ]
	TERM1 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM1, ]
	((currentTerm(SERVER0) = V:term:e5:) & (log(SERVER0, INDEX1) = V:term:e5:) & ~lte(TERM2, V:term:e5:)) -> [ TERM0, ]
	~lte(V:term:e5:, TERM0) -> [ TERM2, ]
(partition) #3 term:e5: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, loglen(SERVER0))
(cube eq: post)
	~lte(TERM2, currentTerm(SERVER0))
	(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	~(currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0)))
	leader(SERVER0)
(qvars eq: post)
	TERM2
	SERVER0
	INDEX1
(boosted clause)
	(forall TERM2, SERVER0, INDEX1 . (lte(TERM2, currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t0) | ~(log(s1, i0) = t1) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i0) | ~leader(s1) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall TERM2, SERVER0, INDEX1 . (lte(TERM2, currentTerm(SERVER0)) | ~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | (currentTerm(SERVER0) = log(SERVER0, loglen(SERVER0))) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@    66s  is global clause? No
@    66s  Learning in F[3]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@    66s  F[3] /\ T /\ C+ ?
@    66s  	Ans. UNSAT
@    67s  F[4] unsat core #6 	(ucsz: 20 -> 19 -> 17 -> 16 -> 13 -> 12 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~lte(t2, t0)
	(currentTerm(s0) = t0)
	(log(s0, i1) = t0)
	leader(s0)
	(indzero = i0)
	(loglen(s0) = i0)
(clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~leader(s0) | lte(t2, t0))
(relations)
	currentTerm
	indzero
	log
	lte
	loglen
	leader
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	~lte(TERM1, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
	(indzero = INDEX0)
(antecedent reduction)
@    67s  antecedent: 4 -> 0 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: TERM0
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER0) = TERM0)
(qvars eq)
	INDEX1
	SERVER0
	TERM0
	TERM1
(antecedent eq)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	(loglen(SERVER0) = indzero)
	leader(SERVER0)
	~lte(TERM1, currentTerm(SERVER0))
(qvars eq: post)
	INDEX1
	TERM1
	SERVER0
(boosted clause)
	(forall INDEX1, TERM1, SERVER0 . (~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~(loglen(SERVER0) = indzero) | ~leader(SERVER0) | lte(TERM1, currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~leader(s0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall INDEX1, TERM1, SERVER0 . (~(log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~(loglen(SERVER0) = indzero) | ~leader(SERVER0) | lte(TERM1, currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@    67s  is global clause? No
@    67s  Learning in F[4]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@    67s  F[4] /\ T /\ C+ ?
@    67s  	Ans. UNSAT
@    68s  F[5] unsat core #7 	(ucsz: 15 -> 14 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	~lte(t2, t0)
	(currentTerm(s0) = t0)
	(log(s0, i1) = t0)
	leader(s0)
	(indzero = i0)
	(loglen(s0) = i0)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~leader(s0) | lte(t2, t0))
(relations)
	currentTerm
	indzero
	log
	lte
	loglen
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	~lte(TERM1, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	leader(SERVER0)
	(indzero = INDEX0)
(antecedent reduction)
@    68s  antecedent: 6 -> 0 (reduced)
	removed: SERVER1
	removed: INDEX0
	removed: SERVER0
	removed: INDEX1
	removed: TERM0
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(currentTerm(SERVER0) = TERM0)
	~lte(TERM1, TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = indzero)
	leader(SERVER0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), leader(SERVER0), (currentTerm(SERVER0) = TERM0), (log(SERVER0, INDEX1) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = indzero), leader(V:server:e5:), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((currentTerm(V:server:e5:) = TERM0) & (log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = indzero) & leader(V:server:e5:)) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> currentTerm(SERVER0)
(cube eq: post)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0))
	~lte(TERM1, currentTerm(SERVER0))
	leader(SERVER0)
(qvars eq: post)
	SERVER1
	TERM1
	SERVER0
(boosted clause)
	(forall SERVER1, TERM1, SERVER0 . (~(loglen(SERVER0) = indzero) | ~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0)) | lte(TERM1, currentTerm(SERVER0)) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~leader(s0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall SERVER1, TERM1, SERVER0 . (~(loglen(SERVER0) = indzero) | ~(log(SERVER0, loglen(SERVER1)) = currentTerm(SERVER0)) | lte(TERM1, currentTerm(SERVER0)) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S1, T1, S0 . (((loglen(S0) = indzero) & (log(S0, loglen(S1)) = currentTerm(S0)) & leader(S0)) -> lte(T1, currentTerm(S0))))
@    68s  is global clause? No
@    68s  Learning in F[5]: (forall S1, T1, S0 . (((loglen(S0) = indzero) & (log(S0, loglen(S1)) = currentTerm(S0)) & leader(S0)) -> lte(T1, currentTerm(S0))))
@    68s  F[5] /\ T /\ C+ ?
@    68s  	Ans. UNSAT
@    70s  F[6] unsat core #7 	(ucsz: 22 -> 18 -> 17 -> 16 -> 15 -> 14 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	~lte(t2, t0)
	committed(i1, t0)
	(loglen(s0) = i0)
	leader(s0)
	(indzero = i0)
	(log(s0, i1) = t0)
	(loglen(s1) = i1)
(clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i1, t0) | ~leader(s0) | lte(t2, t0))
(relations)
	indzero
	committed
	lte
	loglen
	log
	leader
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~lte(TERM1, TERM0)
	leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(log(SERVER0, INDEX1) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@    72s  antecedent: 6 -> 0 (reduced)
	removed: SERVER1
	removed: INDEX0
	removed: SERVER0
	removed: INDEX1
	removed: TERM0
	removed: TERM1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	~lte(TERM1, TERM0)
	leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, INDEX1) = TERM0)
(qvars eq)
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), leader(SERVER0), (log(SERVER0, INDEX1) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), leader(V:server:e5:), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = indzero) & leader(V:server:e5:)) -> [ SERVER0, ]
	(loglen(V:server:e5:) = INDEX1) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER1))
(cube eq: post)
	~lte(TERM1, log(SERVER0, loglen(SERVER1)))
	(loglen(SERVER0) = indzero)
	committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1)))
	leader(SERVER0)
(qvars eq: post)
	SERVER1
	TERM1
	SERVER0
(boosted clause)
	(forall SERVER1, TERM1, SERVER0 . (lte(TERM1, log(SERVER0, loglen(SERVER1))) | ~(loglen(SERVER0) = indzero) | ~committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1))) | ~leader(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i1, t0) | ~leader(s0) | lte(t2, t0))
(learnt sym-boosted clause)
	(forall SERVER1, TERM1, SERVER0 . (lte(TERM1, log(SERVER0, loglen(SERVER1))) | ~(loglen(SERVER0) = indzero) | ~committed(loglen(SERVER1), log(SERVER0, loglen(SERVER1))) | ~leader(SERVER0)))
---------------------------
(clause-type: univ)	(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
@    72s  is global clause? No
@    72s  Learning in F[6]: (forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
@    72s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t1

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t1

@    72s  F[5] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@    72s  	Ans. SAT
(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t1

@    72s  F[4] /\ T /\ C+ ?
@    72s  	Ans. UNSAT
@    73s  F[5] unsat core #5 	(ucsz: 14 -> 10 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~member(s1, q1)
	(loglen(s0) = i0)
	committed(i2, t0)
	(log(s1, i2) = t1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | member(s1, q1))
(relations)
	loglen
	log
	indzero
	committed
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX1) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~member(SERVER1, QUORUM0)
	(indzero = INDEX0)
(antecedent reduction)
@    74s  antecedent: 6 -> 4 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(log(SERVER1, INDEX1) = TERM1)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = indzero)
	~member(SERVER1, QUORUM0)
(qvars eq)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
	TERM1
(antecedent eq)
	term:e5:
	-> ~(TERM0 = TERM1)
	server:e5:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
qv2ucubes #2
	SERVER1 -> [ (log(V:server:e5:, INDEX1) = TERM1), ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e5:) = indzero), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX1) = TERM1) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
	(loglen(V:server:e5:) = indzero) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX1)
(cube eq: post)
	committed(INDEX1, TERM0)
	~(SERVER0 = SERVER1)
	(loglen(SERVER0) = indzero)
	~member(SERVER1, QUORUM0)
	~(TERM0 = log(SERVER1, INDEX1))
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM0
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | ~(loglen(SERVER0) = indzero) | member(SERVER1, QUORUM0) | (TERM0 = log(SERVER1, INDEX1))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | member(s1, q1))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM0 . (~committed(INDEX1, TERM0) | (SERVER0 = SERVER1) | ~(loglen(SERVER0) = indzero) | member(SERVER1, QUORUM0) | (TERM0 = log(SERVER1, INDEX1))))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
@    74s  is global clause? No
@    74s  Learning in F[5]: (forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
@    74s  F[5] /\ T /\ C+ ?
@    74s  	Ans. UNSAT
@    75s  F[6] unsat core #5 	(ucsz: 21 -> 17 -> 14 -> 13 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s0) = i0)
	committed(i2, t0)
	(log(s1, i2) = t1)
	(currentTerm(s0) = t2)
	(loglen(s1) = i1)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i2, t0))
(relations)
	currentTerm
	loglen
	log
	committed
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	(log(SERVER1, INDEX2) = TERM1)
	(currentTerm(SERVER0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX2, TERM0)
(antecedent reduction)
@    76s  antecedent: 8 -> 6 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	INDEX1 -> [ (loglen(SERVER1) = INDEX1), ]
	INDEX2 -> [ (log(SERVER1, INDEX2) = TERM1), committed(INDEX2, TERM0), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ (loglen(SERVER1) = V:index:e5:), ]
	INDEX2 -> [ committed(V:index:e5:, TERM0), (log(SERVER1, V:index:e5:) = TERM1), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e5:), ]
ucubes2qv #3
	((log(SERVER1, V:index:e5:) = TERM1) & committed(V:index:e5:, TERM0)) -> [ INDEX2, ]
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX1, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX2, | INDEX1, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	TERM2 -> [ (currentTerm(SERVER0) = TERM2), ]
	TERM0 -> [ committed(INDEX2, TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX2) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ (currentTerm(SERVER0) = V:term:e5:), ]
	TERM0 -> [ committed(INDEX2, V:term:e5:), ]
	TERM1 -> [ (log(SERVER1, INDEX2) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, INDEX2) = V:term:e5:) -> [ TERM1, ]
	committed(INDEX2, V:term:e5:) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e5:) -> [ TERM2, ]
(partition) #3 term:e5: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), (log(SERVER1, INDEX2) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #2
	SERVER1 -> [ (log(V:server:e5:, INDEX2) = TERM1), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e5:) = INDEX0), (currentTerm(V:server:e5:) = TERM2), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX2) = TERM1) & (loglen(V:server:e5:) = INDEX1)) -> [ SERVER1, ]
	((currentTerm(V:server:e5:) = TERM2) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM2 -> currentTerm(SERVER0)
	TERM1 -> log(SERVER1, INDEX2)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(TERM0 = currentTerm(SERVER0))
	~(loglen(SERVER0) = loglen(SERVER1))
	~(loglen(SERVER0) = INDEX2)
	~(TERM0 = log(SERVER1, INDEX2))
	~(loglen(SERVER1) = INDEX2)
	committed(INDEX2, TERM0)
	~(log(SERVER1, INDEX2) = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX2
	TERM0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((TERM0 = currentTerm(SERVER0)) | (loglen(SERVER0) = loglen(SERVER1)) | (loglen(SERVER0) = INDEX2) | (TERM0 = log(SERVER1, INDEX2)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (log(SERVER1, INDEX2) = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i2, t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX2, TERM0 . ((TERM0 = currentTerm(SERVER0)) | (loglen(SERVER0) = loglen(SERVER1)) | (loglen(SERVER0) = INDEX2) | (TERM0 = log(SERVER1, INDEX2)) | (loglen(SERVER1) = INDEX2) | ~committed(INDEX2, TERM0) | (log(SERVER1, INDEX2) = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
@    76s  is global clause? No
@    76s  Learning in F[6]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
@    76s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e6 with value True
	inputs:
actionName ext:getEntries
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
		V__fml:j:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t2			--> modified
	log(s1, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    76s  F[5] /\ T /\ C+ ?
@    76s  	Ans. UNSAT
@    77s  F[6] unsat core #6 	(ucsz: 19 -> 14 -> 13 -> 12 -> 11 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i2)
	committed(i1, t2)
	(log(s0, i1) = t0)
	(loglen(s1) = i0)
	(log(s1, i0) = t1)
	~member(s0, q0)
(clause)
	(~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | member(s0, q0))
(relations)
	loglen
	log
	committed
	member
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER1, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX2)
	~member(SERVER0, QUORUM0)
	(loglen(SERVER1) = INDEX0)
	committed(INDEX1, TERM2)
	(log(SERVER0, INDEX1) = TERM0)
(antecedent reduction)
@    78s  antecedent: 8 -> 6 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM2), (log(SERVER0, INDEX1) = TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = INDEX2), ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM2), (log(SERVER0, V:index:e5:) = TERM0), ]
	INDEX2 -> [ (loglen(SERVER0) = V:index:e5:), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e5:), (log(SERVER1, V:index:e5:) = TERM1), ]
ucubes2qv #3
	((log(SERVER1, V:index:e5:) = TERM1) & (loglen(SERVER1) = V:index:e5:)) -> [ INDEX0, ]
	(loglen(SERVER0) = V:index:e5:) -> [ INDEX2, ]
	((log(SERVER0, V:index:e5:) = TERM0) & committed(V:index:e5:, TERM2)) -> [ INDEX1, ]
(partition) #3 index:e5: -> { INDEX0, | INDEX2, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	TERM2 -> [ committed(INDEX1, TERM2), ]
	TERM0 -> [ (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #3
	TERM2 -> [ committed(INDEX1, V:term:e5:), ]
	TERM0 -> [ (log(SERVER0, INDEX1) = V:term:e5:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e5:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e5:) -> [ TERM1, ]
	committed(INDEX1, V:term:e5:) -> [ TERM2, ]
	(log(SERVER0, INDEX1) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), (loglen(SERVER1) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX2), (log(SERVER0, INDEX1) = TERM0), ~member(SERVER0, QUORUM0), ]
qv2ucubes #2
	SERVER1 -> [ (loglen(V:server:e5:) = INDEX0), (log(V:server:e5:, INDEX0) = TERM1), ]
	SERVER0 -> [ ~member(V:server:e5:, QUORUM0), (loglen(V:server:e5:) = INDEX2), (log(V:server:e5:, INDEX1) = TERM0), ]
ucubes2qv #2
	((log(V:server:e5:, INDEX0) = TERM1) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX1) = TERM0) & (loglen(V:server:e5:) = INDEX2) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER1)
	TERM1 -> log(SERVER1, loglen(SERVER1))
(cube eq: post)
	~(loglen(SERVER1) = INDEX1)
	~(INDEX1 = loglen(SERVER0))
	~(loglen(SERVER1) = loglen(SERVER0))
	~(log(SERVER1, loglen(SERVER1)) = TERM2)
	~(log(SERVER0, INDEX1) = TERM2)
	~member(SERVER0, QUORUM0)
	committed(INDEX1, TERM2)
	~(log(SERVER0, INDEX1) = log(SERVER1, loglen(SERVER1)))
(qvars eq: post)
	TERM2
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX1 . ((loglen(SERVER1) = INDEX1) | (INDEX1 = loglen(SERVER0)) | (loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER1)) = TERM2) | (log(SERVER0, INDEX1) = TERM2) | member(SERVER0, QUORUM0) | ~committed(INDEX1, TERM2) | (log(SERVER0, INDEX1) = log(SERVER1, loglen(SERVER1)))))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i2) | ~(loglen(s1) = i0) | ~committed(i1, t2) | member(s0, q0))
(learnt sym-boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX1 . ((loglen(SERVER1) = INDEX1) | (INDEX1 = loglen(SERVER0)) | (loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER1)) = TERM2) | (log(SERVER0, INDEX1) = TERM2) | member(SERVER0, QUORUM0) | ~committed(INDEX1, TERM2) | (log(SERVER0, INDEX1) = log(SERVER1, loglen(SERVER1)))))
---------------------------
(clause-type: univ)	(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
@    78s  is global clause? No
@    78s  Learning in F[6]: (forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
@    78s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t0
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t2
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@    78s  F[5] /\ T /\ C+ ?
@    78s  	Ans. UNSAT
@    79s  F[6] unsat core #8 	(ucsz: 23 -> 21 -> 14 -> 13 -> 11 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	(indzero = i1)
	indlt(i0, i2)
	committed(i2, t2)
	(currentTerm(s0) = t0)
	(loglen(s0) = i0)
	(currentTerm(s1) = t2)
	member(s0, q0)
	member(s0, q1)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i1) | ~(loglen(s0) = i0) | ~committed(i2, t2) | ~indlt(i0, i2) | ~member(s0, q0) | ~member(s0, q1))
(relations)
	currentTerm
	loglen
	indzero
	committed
	member
	indlt
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(currentTerm(SERVER0) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX1)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	indlt(INDEX0, INDEX2)
	committed(INDEX2, TERM1)
(antecedent reduction)
@    81s  antecedent: 9 -> 6 (reduced)
	removed: SERVER0
	removed: SERVER1
	removed: INDEX2

(eq map)
	INDEX1 -> indzero
(cube eq)
	(currentTerm(SERVER0) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	(loglen(SERVER0) = INDEX0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	indlt(INDEX0, INDEX2)
	committed(INDEX2, TERM1)
(qvars eq)
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
	INDEX0
	INDEX2
	TERM0
	TERM1
(antecedent eq)
	quorum:e5:
	-> ~(QUORUM0 = QUORUM1)
	index:e5:
	-> ~(INDEX0 = indzero)
	term:e5:
	-> ~(TERM0 = TERM1)
(fullsorts)
	quorum:e5: -> [ QUORUM0, QUORUM1, ]
	index:e5: -> [ INDEX0, indzero, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
qv2cubes #2
	QUORUM0 -> [ member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER0, V:quorum:e5:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e5:), ]
ucubes2qv #1
	member(SERVER0, V:quorum:e5:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e5: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
qv2cubes #3
	INDEX2 -> [ indlt(INDEX0, INDEX2), committed(INDEX2, TERM1), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), indlt(INDEX0, INDEX2), ]
qv2ucubes #3
	INDEX2 -> [ indlt(INDEX0, V:index:e5:), committed(V:index:e5:, TERM1), ]
	indzero -> [ ]
	INDEX0 -> [ indlt(V:index:e5:, INDEX2), (loglen(SERVER0) = V:index:e5:), ]
ucubes2qv #3
	true -> [ indzero, ]
	(committed(V:index:e5:, TERM1) & indlt(INDEX0, V:index:e5:)) -> [ INDEX2, ]
	((loglen(SERVER0) = V:index:e5:) & indlt(V:index:e5:, INDEX2)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { indzero, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (currentTerm(SERVER1) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM0), member(SERVER0, QUORUM0), ]
qv2ucubes #2
	SERVER1 -> [ (currentTerm(V:server:e5:) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e5:) = TERM0), (loglen(V:server:e5:) = INDEX0), member(V:server:e5:, QUORUM0), ]
ucubes2qv #2
	(currentTerm(V:server:e5:) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e5:) = TERM0) & (loglen(V:server:e5:) = INDEX0) & member(V:server:e5:, QUORUM0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX2, TERM0, TERM1 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX2, TERM1) | ~indlt(INDEX0, INDEX2) | ~member(SERVER0, QUORUM0) | (INDEX0 = indzero) | (TERM0 = TERM1))))
(non-epr version)
	(forall SERVER0, SERVER1, INDEX0, INDEX2, TERM0, TERM1 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX2, TERM1) | ~indlt(INDEX0, INDEX2) | ~member(SERVER0, QUORUM0) | (INDEX0 = indzero) | (TERM0 = TERM1))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX2, TERM0, TERM1 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX2, TERM1) | ~indlt(INDEX0, INDEX2) | ~member(SERVER0, QUORUM0) | (INDEX0 = indzero) | (TERM0 = TERM1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s1) = t2) | ~(indzero = i1) | ~(loglen(s0) = i0) | ~committed(i2, t2) | ~indlt(i0, i2) | ~member(s0, q0) | ~member(s0, q1))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER0, SERVER1, INDEX0, INDEX2, TERM0, TERM1 . (~(currentTerm(SERVER0) = TERM0) | ~(currentTerm(SERVER1) = TERM1) | ~(loglen(SERVER0) = INDEX0) | ~committed(INDEX2, TERM1) | ~indlt(INDEX0, INDEX2) | ~member(SERVER0, QUORUM0) | (INDEX0 = indzero) | (TERM0 = TERM1))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
@   134s  is global clause? No
@   134s  Learning in F[6]: (exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
@   134s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   135s  F[5] /\ T /\ C+ ?
@   135s  	Ans. UNSAT
@   135s  F[6] unsat core #4 	(ucsz: 13 -> 9 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i2)
	(log(s0, i1) = t0)
	~member(s1, q1)
	committed(i1, t1)
(clause)
	(~(log(s0, i1) = t0) | ~(loglen(s1) = i2) | ~committed(i1, t1) | member(s1, q1))
(relations)
	loglen
	log
	committed
	member
(fullsorts)
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER1) = INDEX1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@   135s  antecedent: 6 -> 6

qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), (loglen(V:server:e5:) = INDEX1), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	((loglen(V:server:e5:) = INDEX1) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER1))
	~(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~(loglen(s1) = i2) | ~committed(i1, t1) | member(s1, q1))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | (log(S0, I0) = T1) | member(S1, Q0))))
@   135s  is global clause? No
@   135s  Learning in F[6]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | (log(S0, I0) = T1) | member(S1, Q0))))
@   135s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e6 with value True
	inputs:
actionName ext:clientRequest
		V__fml:nextInd:e1:e4 -> i0
		V__fml:e1:e4 -> s0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	loglen(s0) = i1
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t2			--> modified
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   136s  F[5] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
@   136s  	Ans. SAT
(cube in F[5])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   136s  F[4] /\ T /\ C+ ?
@   136s  	Ans. UNSAT
@   136s  F[5] unsat core #5 	(ucsz: 13 -> 11 -> 10 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i2)
	committed(i1, t2)
	(loglen(s0) = i0)
	~member(s1, q0)
	(log(s0, i0) = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2) | member(s1, q0))
(relations)
	loglen
	log
	committed
	member
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM1)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER1) = INDEX2)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@   137s  antecedent: 7 -> 5 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM1), ]
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM1), ]
	INDEX2 -> [ (loglen(SERVER1) = V:index:e5:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e5:), (log(SERVER0, V:index:e5:) = TERM0), ]
ucubes2qv #3
	committed(V:index:e5:, TERM1) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX2, ]
	((log(SERVER0, V:index:e5:) = TERM0) & (loglen(SERVER0) = V:index:e5:)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX2), ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), (loglen(V:server:e5:) = INDEX2), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	((loglen(V:server:e5:) = INDEX2) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX0) = TERM0) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = TERM1)
	~(INDEX1 = loglen(SERVER1))
	~member(SERVER1, QUORUM0)
	~(loglen(SERVER0) = INDEX1)
	committed(INDEX1, TERM1)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM1
(boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((log(SERVER0, loglen(SERVER0)) = TERM1) | (INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (loglen(SERVER0) = INDEX1) | ~committed(INDEX1, TERM1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2) | member(s1, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((log(SERVER0, loglen(SERVER0)) = TERM1) | (INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (loglen(SERVER0) = INDEX1) | ~committed(INDEX1, TERM1) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((log(S0, loglen(S0)) = T1) | (I1 = loglen(S1)) | member(S1, Q0) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@   137s  is global clause? No
@   138s  Learning in F[5]: (forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((log(S0, loglen(S0)) = T1) | (I1 = loglen(S1)) | member(S1, Q0) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@   138s  F[5] /\ T /\ C+ ?
@   138s  	Ans. UNSAT
@   138s  F[6] unsat core #6 	(ucsz: 19 -> 14 -> 13 -> 11 -> 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	committed(i1, t2)
	(loglen(s1) = i2)
	~lte(t1, t2)
	~member(s1, q0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2) | lte(t1, t2) | member(s1, q0))
(relations)
	loglen
	log
	committed
	lte
	member
(fullsorts)
	index:e5: -> [ INDEX0, INDEX1, INDEX2, ]
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER1) = INDEX2)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM2)
	~lte(TERM1, TERM2)
(antecedent reduction)
@   139s  antecedent: 8 -> 5 (reduced)
	removed: SERVER1
	removed: SERVER0
	removed: TERM1

qv2cubes #3
	INDEX1 -> [ committed(INDEX1, TERM2), ]
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #3
	INDEX1 -> [ committed(V:index:e5:, TERM2), ]
	INDEX2 -> [ (loglen(SERVER1) = V:index:e5:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e5:), (log(SERVER0, V:index:e5:) = TERM0), ]
ucubes2qv #3
	committed(V:index:e5:, TERM2) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e5:) -> [ INDEX2, ]
	((log(SERVER0, V:index:e5:) = TERM0) & (loglen(SERVER0) = V:index:e5:)) -> [ INDEX0, ]
(partition) #3 index:e5: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	TERM2 -> [ committed(INDEX1, TERM2), ~lte(TERM1, TERM2), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM1, TERM2), ]
qv2ucubes #3
	TERM2 -> [ committed(INDEX1, V:term:e5:), ~lte(TERM1, V:term:e5:), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
	TERM1 -> [ ~lte(V:term:e5:, TERM2), ]
ucubes2qv #3
	~lte(V:term:e5:, TERM2) -> [ TERM1, ]
	(committed(INDEX1, V:term:e5:) & ~lte(TERM1, V:term:e5:)) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ (loglen(SERVER1) = INDEX2), ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), (loglen(V:server:e5:) = INDEX2), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), (loglen(V:server:e5:) = INDEX0), ]
ucubes2qv #2
	((loglen(V:server:e5:) = INDEX2) & ~member(V:server:e5:, QUORUM0)) -> [ SERVER1, ]
	((log(V:server:e5:, INDEX0) = TERM0) & (loglen(V:server:e5:) = INDEX0)) -> [ SERVER0, ]
(partition) #2 server:e5: -> { SERVER1, | SERVER0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX1 = loglen(SERVER1))
	~member(SERVER1, QUORUM0)
	~(log(SERVER0, loglen(SERVER0)) = TERM2)
	~(loglen(SERVER0) = INDEX1)
	committed(INDEX1, TERM2)
	~lte(TERM1, TERM2)
	~(loglen(SERVER0) = loglen(SERVER1))
(qvars eq: post)
	TERM2
	QUORUM0
	SERVER0
	SERVER1
	INDEX1
	TERM1
(boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (log(SERVER0, loglen(SERVER0)) = TERM2) | (loglen(SERVER0) = INDEX1) | ~committed(INDEX1, TERM2) | lte(TERM1, TERM2) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2) | lte(t1, t2) | member(s1, q0))
(learnt sym-boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX1, TERM1 . ((INDEX1 = loglen(SERVER1)) | member(SERVER1, QUORUM0) | (log(SERVER0, loglen(SERVER0)) = TERM2) | (loglen(SERVER0) = INDEX1) | ~committed(INDEX1, TERM2) | lte(TERM1, TERM2) | (loglen(SERVER0) = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
@   139s  is global clause? No
@   139s  Learning in F[6]: (forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
@   139s  F[6] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e6 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:q:e1:e4 -> q0
		V__fml:e1:e4 -> s0
		V__fml:newterm:e1:e4 -> t0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	leader(s0) = true
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[6])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1
	leader(s0) = false			--> modified
	leader(s1) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   139s  F[5] /\ T /\ C+ ?
@   139s  	Ans. UNSAT
@   140s  F[6] unsat core #4 	(ucsz: 17 -> 13 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i1) = t0)
	~member(s1, q0)
	~lte(t2, t1)
	committed(i1, t1)
(clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t1) | lte(t2, t1) | member(s1, q0))
(relations)
	member
	log
	committed
	lte
(fullsorts)
	term:e5: -> [ TERM0, TERM1, TERM2, ]
	server:e5: -> [ SERVER0, SERVER1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~lte(TERM2, TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@   141s  antecedent: 5 -> 4 (reduced)
	removed: TERM2

qv2cubes #3
	TERM2 -> [ ~lte(TERM2, TERM1), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM2, TERM1), committed(INDEX0, TERM1), ]
qv2ucubes #3
	TERM2 -> [ ~lte(V:term:e5:, TERM1), ]
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e5:), ]
	TERM1 -> [ ~lte(TERM2, V:term:e5:), committed(INDEX0, V:term:e5:), ]
ucubes2qv #3
	(committed(INDEX0, V:term:e5:) & ~lte(TERM2, V:term:e5:)) -> [ TERM1, ]
	~lte(V:term:e5:, TERM1) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e5:) -> [ TERM0, ]
(partition) #3 term:e5: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	SERVER1 -> [ ~member(SERVER1, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
qv2ucubes #2
	SERVER1 -> [ ~member(V:server:e5:, QUORUM0), ]
	SERVER0 -> [ (log(V:server:e5:, INDEX0) = TERM0), ]
ucubes2qv #2
	(log(V:server:e5:, INDEX0) = TERM0) -> [ SERVER0, ]
	~member(V:server:e5:, QUORUM0) -> [ SERVER1, ]
(partition) #2 server:e5: -> { SERVER0, | SERVER1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~lte(TERM2, TERM1)
	~(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	TERM2
	QUORUM0
	SERVER0
	SERVER1
	INDEX0
	TERM1
(boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | lte(TERM2, TERM1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t1) | lte(t2, t1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall TERM2, QUORUM0, SERVER0, SERVER1, INDEX0, TERM1 . ((SERVER0 = SERVER1) | lte(TERM2, TERM1) | (log(SERVER0, INDEX0) = TERM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   141s  is global clause? No
@   141s  Learning in F[6]: (forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   141s  F[6] /\ T /\ !P+ -> UNSAT
Frames: #7
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #8
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
		(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
	F[3]: #14
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
		(forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
	F[4]: #11
		(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
		(forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
		(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
		(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
		(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
		(forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
	F[5]: #9
		(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
		(forall S1, T1, S0 . (((loglen(S0) = indzero) & (log(S0, loglen(S1)) = currentTerm(S0)) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((log(S0, loglen(S0)) = T1) | (I1 = loglen(S1)) | member(S1, Q0) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
		(forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
	F[6]: #25
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(forall T0 . ~committed(indzero, T0))
		(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(forall Q0, S0, S1, I0 . (committed(I0, log(S0, loglen(S0))) -> (member(S1, Q0) | (log(S0, loglen(S0)) = currentTerm(S0)) | succ(I0, loglen(S0)) | (S0 = S1) | (I0 = loglen(S0)))))
		(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | (log(S0, I0) = T1) | member(S1, Q0))))
		(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@   143s  
Adding frame 7...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Forwarded #2 to F[4]
@   147s  Learning in F[4]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@   147s  Learning in F[4]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
Trying forwarding F[4]
Forwarded #4 to F[5]
@   149s  Learning in F[5]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@   149s  Learning in F[5]: (forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@   149s  Learning in F[5]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@   149s  Learning in F[5]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
Trying forwarding F[5]
Forwarded #9 to F[6]
@   151s  Learning in F[6]: (forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
@   151s  Learning in F[6]: (forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@   151s  Learning in F[6]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@   151s  Learning in F[6]: (forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
@   151s  Learning in F[6]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@   151s  Learning in F[6]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@   151s  Learning in F[6]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   151s  Learning in F[6]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
@   151s  Learning in F[6]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
Trying forwarding F[6]
Forwarded #32 to F[7]
@   164s  Learning in F[7]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@   164s  Learning in F[7]: (forall T0 . ~committed(indzero, T0))
@   164s  Learning in F[7]: (forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   164s  Learning in F[7]: (forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@   164s  Learning in F[7]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@   164s  Learning in F[7]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@   164s  Learning in F[7]: (forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
@   164s  Learning in F[7]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
@   164s  Learning in F[7]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@   164s  Learning in F[7]: (forall S0 . (log(S0, indzero) = termzero))
@   164s  Learning in F[7]: (forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
@   164s  Learning in F[7]: (forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
@   164s  Learning in F[7]: (forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@   164s  Learning in F[7]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   164s  Learning in F[7]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   164s  Learning in F[7]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   164s  Learning in F[7]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@   164s  Learning in F[7]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@   164s  Learning in F[7]: (exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
@   164s  Learning in F[7]: (forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@   164s  Learning in F[7]: (forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
@   164s  Learning in F[7]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@   164s  Learning in F[7]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   164s  Learning in F[7]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@   164s  Learning in F[7]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@   164s  Learning in F[7]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@   164s  Learning in F[7]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@   164s  Learning in F[7]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@   164s  Learning in F[7]: (forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
@   164s  Learning in F[7]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
@   164s  Learning in F[7]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@   164s  Learning in F[7]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   164s  Learning in F[7]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@   164s  Learning in F[7]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@   164s  Learning in F[7]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@   164s  Learning in F[7]: (forall S0 . (log(S0, indzero) = termzero))
@   164s  Learning in F[7]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   164s  Learning in F[7]: (forall T0 . ~committed(indzero, T0))
@   164s  Learning in F[7]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   164s  Learning in F[7]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@   164s  Learning in F[7]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   164s  Learning in F[7]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@   164s  Learning in F[7]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   164s  F[7] /\ T /\ !P+ -> UNSAT
Frames: #8
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #8
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
		(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
	F[3]: #12
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
		(forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
	F[4]: #9
		(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
		(forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
		(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
		(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
		(forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
	F[5]: #3
		(forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((log(S0, loglen(S0)) = T1) | (I1 = loglen(S1)) | member(S1, Q0) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
	F[6]: #1
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | (log(S0, I0) = T1) | member(S1, Q0))))
	F[7]: #32
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(forall T0 . ~committed(indzero, T0))
		(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
		(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
		(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
		(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
		(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
		(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   165s  
Adding frame 8...
Trying forwarding F[1]
Trying forwarding F[2]
Trying forwarding F[3]
Trying forwarding F[4]
Trying forwarding F[5]
Trying forwarding F[6]
Trying forwarding F[7]
Forwarded #32 to F[8]
@   191s  Learning in F[8]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@   191s  Learning in F[8]: (forall T0 . ~committed(indzero, T0))
@   191s  Learning in F[8]: (forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
@   191s  Learning in F[8]: (forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   191s  Learning in F[8]: (forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
@   191s  Learning in F[8]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@   191s  Learning in F[8]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@   191s  Learning in F[8]: (forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
@   191s  Learning in F[8]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
@   191s  Learning in F[8]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@   191s  Learning in F[8]: (forall S0 . (log(S0, indzero) = termzero))
@   191s  Learning in F[8]: (forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
@   191s  Learning in F[8]: (forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
@   191s  Learning in F[8]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   191s  Learning in F[8]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   191s  Learning in F[8]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   191s  Learning in F[8]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@   191s  Learning in F[8]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
@   191s  Learning in F[8]: (exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
@   191s  Learning in F[8]: (forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@   191s  Learning in F[8]: (forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
@   191s  Learning in F[8]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@   191s  Learning in F[8]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   191s  Learning in F[8]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@   191s  Learning in F[8]: (forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
@   191s  Learning in F[8]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@   191s  Learning in F[8]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@   191s  Learning in F[8]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
@   191s  Learning in F[8]: (forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
@   191s  Learning in F[8]: (forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
@   191s  Learning in F[8]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@   191s  Learning in F[8]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   191s  Learning in F[8]: (forall S1, Q0, S0 . (lte(currentTerm(S1), currentTerm(S0)) | member(S1, Q0)))
@   191s  Learning in F[8]: (exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
@   191s  Learning in F[8]: (exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
@   191s  Learning in F[8]: (forall S0 . (log(S0, indzero) = termzero))
@   191s  Learning in F[8]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   191s  Learning in F[8]: (forall T0 . ~committed(indzero, T0))
@   191s  Learning in F[8]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   191s  Learning in F[8]: (exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
@   191s  Learning in F[8]: (forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
@   191s  Learning in F[8]: (exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
@   191s  Learning in F[8]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   191s  F[8] /\ T /\ !P+ -> UNSAT
Frames: #9
	F[0]: #1
		((forall S6 . ~leader(S6)) & (forall S6 . (currentTerm(S6) = termzero)) & (forall S6 . (loglen(S6) = indzero)) & (forall S6, I6 . (log(S6, I6) = termzero)) & (forall I6_1, T6 . ~committed(I6_1, T6)))
	F[1]: #3
		(forall S0 . (loglen(S0) = indzero))
		(forall I0, S0 . (log(S0, I0) = termzero))
		(forall S1, S0 . ((currentTerm(S0) = currentTerm(S1)) | (termzero = currentTerm(S1)) | (currentTerm(S0) = termzero)))
	F[2]: #8
		(forall I0, S0 . (leader(S0) | (log(S0, I0) = termzero)))
		(exists S0 . (forall I1 . ((loglen(S0) = I1) -> (indzero = I1))))
		(forall S1, S0 . ((S0 = S1) | (termzero = log(S0, loglen(S1)))))
		(forall S1, S0 . (leader(S1) -> ((currentTerm(S0) = currentTerm(S1)) | (indzero = loglen(S0)))))
		(forall I0, S0 . ((leader(S0) & (currentTerm(S0) = log(S0, I0))) -> (I0 = loglen(S0))))
		(forall S0 . (succ(indzero, loglen(S0)) | (indzero = loglen(S0))))
		(forall T0, I0 . ~committed(I0, T0))
		(forall S0 . ((currentTerm(S0) = log(S0, indzero)) -> (indzero = loglen(S0))))
	F[3]: #12
		(forall I1, S1, T0, S0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | leader(S1))))
		(forall S1, I2, S0 . (indlt(I2, loglen(S0)) -> ((loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = loglen(S1)))))
		(forall S0, S1 . ((loglen(S0) = loglen(S1)) -> ((currentTerm(S1) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall I0, T0, S0 . ((committed(I0, T0) & leader(S0)) -> (T0 = currentTerm(S0))))
		(forall S1, S0 . (committed(loglen(S1), log(S0, loglen(S1))) -> (S0 = S1)))
		(forall S0, S1 . ((log(S0, loglen(S1)) = log(S1, loglen(S0))) | leader(S0) | (loglen(S0) = loglen(S1))))
		(forall I1, T0, I0 . (exists S0 . ((loglen(S0) = I0) -> ~committed(I1, T0))))
		(forall I1, T0 . (committed(I1, T0) -> succ(indzero, I1)))
		(forall S1, S0 . (leader(S0) -> ((currentTerm(S0) = currentTerm(S1)) | succ(indzero, loglen(S1)) | (loglen(S1) = indzero))))
		(forall S0, S1 . ((log(S0, loglen(S1)) = currentTerm(S0)) -> (currentTerm(S0) = log(S0, loglen(S0)))))
		(forall I1, I0, S0 . ((committed(I0, log(S0, I1)) & leader(S0)) -> (I0 = I1)))
		(forall S0, S1, I1, T0 . (committed(I1, T0) -> ((loglen(S1) = I1) | (loglen(S1) = loglen(S0)) | (I1 = loglen(S0)))))
	F[4]: #9
		(forall I1, S0 . (committed(I1, log(S0, loglen(S0))) -> ((loglen(S0) = I1) | leader(S0))))
		(forall Q0, S0, S1, I1, T0 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | member(S1, Q0))))
		(forall S1, T0, S0 . (committed(loglen(S1), T0) -> (leader(S1) | (loglen(S0) = loglen(S1)))))
		(forall I2, T0, S0 . (committed(I2, T0) -> ((indzero = I2) | (loglen(S0) = I2) | (indzero = loglen(S0)) | leader(S0))))
		(forall S0, S1, I0, T0 . ((committed(I0, T0) & leader(S0)) -> ((S0 = S1) | (I0 = loglen(S1)) | (T0 = currentTerm(S0)))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> (I0 = I1))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((S0 = S1) | (loglen(S0) = I1) | (currentTerm(S0) = T1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((S0 = S1) | (loglen(S0) = I1) | member(S1, Q0) | leader(S0))))
		(forall I1, Q0, T0, S0 . (committed(I1, T0) -> ((I1 = loglen(S0)) | (indzero = loglen(S0)) | (indzero = I1) | member(S0, Q0))))
	F[5]: #3
		(forall S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | (log(S1, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T1 . (committed(I1, T1) -> ((log(S0, loglen(S0)) = T1) | (I1 = loglen(S1)) | member(S1, Q0) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
	F[6]: #1
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | (I0 = loglen(S1)) | (log(S0, I0) = T1) | member(S1, Q0))))
	F[7]: #0
	F[8]: #32
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(forall T0 . ~committed(indzero, T0))
		(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
		(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
		(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
		(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
		(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
		(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
		(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
		(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
		(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
		(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
		(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
		(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   192s  
Adding frame 9...
@   192s  F[7] converged!
Explored 10 frames
@   192s  -------------------------------------------------
### Invariant: #33
invariant [other21]	(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
invariant [other11]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [global8]	(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
invariant [other20]	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
invariant [other1]	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
invariant [other17]	(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
invariant [other7]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
invariant [other14]	(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
invariant [other19]	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
invariant [global5]	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
invariant [global9]	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [global4]	(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
invariant [other10]	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
invariant [other5]	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
invariant [other22]	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
invariant [other15]	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
invariant [other18]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
invariant [global3]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global7]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
invariant [other4]	(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
invariant [other8]	(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
invariant [other12]	(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
invariant [other3]	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [other13]	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
invariant [other2]	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
invariant [prop1]	(forall I6, T6, S6 . ((committed(I6, T6) & leader(S6) & (lte(T6, currentTerm(S6)) & ~(T6 = currentTerm(S6)))) -> (log(S6, I6) = T6)))
invariant [global6]	(forall T0 . ~committed(indzero, T0))
invariant [global5_1]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other9]	(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
invariant [global11]	(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
invariant [other16]	(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
invariant [other6]	(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other21 -> UNSAT
	#2 other11 -> UNSAT
	#3 global8 -> UNSAT
	#4 other20 -> UNSAT
	#5 other1 -> UNSAT
	#6 other17 -> UNSAT
	#7 other7 -> UNSAT
	#8 other14 -> UNSAT
	#9 other19 -> UNSAT
	#10 global9 -> UNSAT
	#11 other5 -> UNSAT
	#12 global7 -> UNSAT
	#13 global4 -> UNSAT
	#14 other22 -> UNSAT
	#15 other15 -> UNSAT
	#16 other18 -> UNSAT
	#17 other2 -> UNSAT
	#18 global3 -> UNSAT
	#19 global4_1 -> UNSAT
	#20 other10 -> UNSAT
	#21 other4 -> UNSAT
	#22 other8 -> UNSAT
	#23 other12 -> UNSAT
	#24 other3 -> UNSAT
	#25 other13 -> UNSAT
	#26 global5 -> UNSAT
	#27 prop1  (property) -> UNSAT
	#28 global6 -> UNSAT
	#29 global5_1 -> UNSAT
	#30 other9 -> UNSAT
	#31 global11 -> UNSAT
	#32 other16 -> UNSAT
	#33 other6 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other21 -> UNSAT
	#2 other11 -> UNSAT
	#3 global8 -> UNSAT
	#4 other20 -> UNSAT
	#5 other1 -> UNSAT
	#6 other17 -> UNSAT
	#7 other7 -> UNSAT
	#8 other14 -> UNSAT
	#9 other19 -> UNSAT
	#10 global9 -> UNSAT
	#11 other5 -> UNSAT
	#12 global7 -> UNSAT
	#13 global4 -> UNSAT
	#14 other22 -> UNSAT
	#15 other15 -> UNSAT
	#16 other18 -> UNSAT
	#17 other2 -> UNSAT
	#18 global3 -> UNSAT
	#19 global4_1 -> UNSAT
	#20 other10 -> UNSAT
	#21 other4 -> UNSAT
	#22 other8 -> UNSAT
	#23 other12 -> UNSAT
	#24 other3 -> UNSAT
	#25 other13 -> UNSAT
	#26 global5 -> UNSAT
	#27 prop1  (property) -> UNSAT
	#28 global6 -> UNSAT
	#29 global5_1 -> UNSAT
	#30 other9 -> UNSAT
	#31 global11 -> UNSAT
	#32 other16 -> UNSAT
	#33 other6 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e5: -> [`index:e5:0`, `index:e5:1`, `index:e5:2`]
	term -> term:e5: -> [`term:e5:0`, `term:e5:1`, `term:e5:2`]
	quorum -> quorum:e5: -> [`quorum:e5:0`, `quorum:e5:1`]
	server -> server:e5: -> [`server:e5:0`, `server:e5:1`]

Invariant is a proof certificate
@   207s  -------------------------------------------------
--> The system is safe!
raw invariant [prop1] (cost: 3, 3F, 0E) 	(forall I:e6, T:e6, X:e6 . ((__committed:e6(I:e6, T:e6) & __leader:e6(X:e6) & (...(..., ...) & ~...)) -> (__log:e6(X:e6, I:e6) = T:e6)))
raw invariant [other21] (cost: 6, 6F, 0E) 	~(exists Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1, Q:term:e5:0, Q:term:e5:1 . ((...(...) = indzero:e6) & __committed:e6(Q:index:e5:1, Q:term:e5:0) & ~(... = ...) & ~...(...) & ~...(..., ...) & ~...(..., ...)))
raw invariant [other11] (cost: 2, 2F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1 . (~(... = ...) & (...(...) = ...(..., ...)) & __leader:e6(Q:server:e6:0)))
raw invariant [global8] (cost: 4, 3F, 1E) 	~(forall Q:quorum:e5:0 . (exists Q:server:e5:1, Q:term:e5:1, Q:server:e5:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [other20] (cost: 5, 5F, 0E) 	~(exists Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1, Q:term:e5:0 . (~(... = ...) & ~...(..., ...) & ~(... = ...) & __committed:e6(Q:index:e5:1, Q:term:e5:0) & ~(... = ...) & ~(... = ...)))
raw invariant [other1] (cost: 4, 4F, 0E) 	~(exists Q:server:e5:1, Q:index:e5:1, Q:term:e5:1, Q:server:e5:0 . (__committed:e6(Q:index:e5:1, Q:term:e5:1) & ~(... = ...) & (...(...) = indzero:e6) & ~(... = ...)))
raw invariant [other17] (cost: 3, 3F, 0E) 	~(exists Q:term:e5:2, Q:server:e5:0, Q:index:e5:1 . (~...(..., ...) & (...(..., ...) = ...(...)) & ~(... = ...) & __leader:e6(Q:server:e5:0)))
raw invariant [other7] (cost: 4, 4F, 0E) 	~(exists Q:server:e5:0, Q:server:e5:1, Q:index:e5:2, Q:term:e5:0 . (~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & __committed:e6(Q:index:e5:2, Q:term:e5:0) & ~(... = ...)))
raw invariant [other14] (cost: 6, 6F, 0E) 	~(exists Q:term:e5:2, Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1, Q:term:e5:1 . (~(... = ...) & ~...(..., ...) & ~(... = ...) & ~(... = ...) & __committed:e6(Q:index:e5:1, Q:term:e5:2) & ~...(..., ...) & ~(... = ...)))
raw invariant [other19] (cost: 2, 2F, 0E) 	~(exists Q:server:e5:0, Q:server:e5:1 . (~(... = ...) & ~(... = ...) & __leader:e6(Q:server:e5:1) & ~(... = ...)))
raw invariant [global5] (cost: 2, 1F, 1E) 	~(forall Q:quorum:e5:0 . (exists Q:server:e5:0 . (...(...) & ~...)))
raw invariant [global9] (cost: 5, 4F, 1E) 	~(forall Q:quorum:e5:0 . (exists Q:server:e5:1, Q:term:e5:0, Q:term:e5:1, Q:server:e5:0 . ((... = ...) & (... = ...) & ...(..., ...) & ~...)))
raw invariant [global4] (cost: 3, 2F, 1E) 	~(forall Q:quorum:e5:0 . (exists Q:term:e5:1, Q:server:e5:0 . ((... = ...) & ~... & ~...)))
raw invariant [other10] (cost: 5, 5F, 0E) 	~(exists Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:0, Q:term:e5:1 . (~...(..., ...) & ~...(..., ...) & ~(... = ...) & ~(... = ...) & __committed:e6(Q:index:e5:0, Q:term:e5:1) & ~(... = ...)))
raw invariant [other5] (cost: 103, 3F, 1E) 	~(exists Q:index:e5:1, Q:term:e5:0, Q:index:e5:0 . (forall Q:server:e5:0 . ((... = ...) & ...(..., ...) & ~... & ~...)))
raw invariant [other22] (cost: 5, 5F, 0E) 	~(exists Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1, Q:term:e5:0 . (~...(..., ...) & ~(... = ...) & __committed:e6(Q:index:e5:1, Q:term:e5:0) & ~(... = ...) & ~(... = ...) & ~(... = ...)))
raw invariant [other15] (cost: 3, 3F, 0E) 	~(exists Q:index:e5:1, Q:term:e5:1, Q:server:e5:0 . ((...(..., ...) = ...(...)) & (...(...) = indzero:e6) & __leader:e6(Q:server:e5:0) & ~...(..., ...)))
raw invariant [other18] (cost: 4, 4F, 0E) 	~(exists Q:server:e5:0, Q:server:e5:1, Q:index:e5:2, Q:term:e5:0 . (~(... = ...) & ~(... = ...) & ~...(..., ...) & ~(... = ...) & __committed:e6(Q:index:e5:2, Q:term:e5:0) & ~(... = ...)))
raw invariant [global3] (cost: 1, 1F, 0E) 	~(exists Q:server:e5:0 . ~(...(..., ...) = termzero:e6))
raw invariant [global4_1] (cost: 1, 1F, 0E) 	~(exists Q:server:e6:0 . (__leader:e6(Q:server:e6:0) & (...(...) = termzero:e6)))
raw invariant [global7] (cost: 2, 2F, 0E) 	~(exists Q:term:e5:0, Q:index:e5:0 . (~...(..., ...) & __committed:e6(Q:index:e5:0, Q:term:e5:0)))
raw invariant [other4] (cost: 4, 4F, 0E) 	~(exists Q:index:e5:1, Q:server:e5:1, Q:term:e5:0, Q:server:e5:0 . ((...(...) = indzero:e6) & __committed:e6(Q:index:e5:1, Q:term:e5:0) & ~(... = ...) & ~...(...)))
raw invariant [other8] (cost: 3, 3F, 0E) 	~(exists Q:server:e5:1, Q:term:e5:1, Q:server:e5:0 . (~...(..., ...) & (...(...) = indzero:e6) & __committed:e6(...(...), ...(..., ...)) & __leader:e6(Q:server:e5:0)))
raw invariant [other12] (cost: 7, 6F, 1E) 	~(forall Q:quorum:e5:0 . (exists Q:server:e5:0, Q:server:e5:1, Q:index:e5:0, Q:index:e5:2, Q:term:e5:0, Q:term:e5:1 . ((... = ...) & (... = ...) & (... = ...) & ...(..., ...) & ...(..., ...) & ...(..., ...) & ~... & ~...)))
raw invariant [other3] (cost: 6, 6F, 0E) 	~(exists Q:term:e5:2, Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:0, Q:term:e5:1 . (~(... = ...) & ~...(..., ...) & ~(... = ...) & ~...(..., ...) & __committed:e6(Q:index:e5:0, Q:term:e5:1)))
raw invariant [other13] (cost: 4, 4F, 0E) 	~(exists Q:server:e5:1, Q:term:e5:0, Q:index:e5:0, Q:server:e5:0 . (~(... = ...) & ~(... = ...) & __committed:e6(Q:index:e5:0, Q:term:e5:0) & ~...(...) & ~...(..., ...)))
raw invariant [other2] (cost: 4, 4F, 0E) 	~(exists Q:term:e5:2, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1 . ((...(...) = indzero:e6) & ~...(..., ...) & ~...(...) & ~(... = ...)))
raw invariant [global6] (cost: 1, 1F, 0E) 	~(exists Q:term:e5:0 . __committed:e6(indzero:e6, Q:term:e5:0))
raw invariant [global5_1] (cost: 2, 2F, 0E) 	~(exists Q:server:e6:0, Q:server:e6:1 . (~(... = ...) & __leader:e6(Q:server:e6:1) & indlt:e6(...(...), ...(...))))
raw invariant [other9] (cost: 3, 3F, 0E) 	~(exists Q:term:e5:2, Q:server:e5:0, Q:server:e5:1 . (~(... = ...) & (...(...) = indzero:e6) & ~...(...) & ~...(..., ...)))
raw invariant [global11] (cost: 3, 2F, 1E) 	~(forall Q:server:e5:0 . (exists Q:index:e5:1, Q:term:e5:0 . ((... = ...) & ...(..., ...))))
raw invariant [other16] (cost: 5, 5F, 0E) 	~(exists Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1, Q:term:e5:0 . (__committed:e6(Q:index:e5:1, Q:term:e5:0) & ~(... = ...) & (...(...) = indzero:e6) & ~...(..., ...) & ~(... = ...)))
raw invariant [other6] (cost: 5, 5F, 0E) 	~(exists Q:term:e5:2, Q:quorum:e5:0, Q:server:e5:0, Q:server:e5:1, Q:index:e5:1 . (~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~(... = ...) & ~...(..., ...) & __committed:e6(Q:index:e5:1, Q:term:e5:2) & ~(... = ...)))
@   207s  Minimizing certificate of size 33
@   207s  	other5	(cost: 103) -> add
@   217s  	other12	(cost: 7) -> remove
@   221s  	other21	(cost: 6) -> remove
@   225s  	other14	(cost: 6) -> remove
@   228s  	other3	(cost: 6) -> add
@   230s  	other20	(cost: 5) -> remove
@   233s  	global9	(cost: 5) -> add
@   235s  	other10	(cost: 5) -> add
@   237s  	other22	(cost: 5) -> remove
@   239s  	other16	(cost: 5) -> remove
@   242s  	other6	(cost: 5) -> remove
@   245s  	global8	(cost: 4) -> remove
@   248s  	other1	(cost: 4) -> add
@   252s  	other7	(cost: 4) -> remove
@   254s  	other18	(cost: 4) -> add
@   257s  	other4	(cost: 4) -> remove
@   262s  	other13	(cost: 4) -> add
@   263s  	other2	(cost: 4) -> add
@   266s  	prop1	(cost: 3) -> property
@   266s  	other17	(cost: 3) -> remove
@   268s  	global4	(cost: 3) -> remove
@   272s  	other15	(cost: 3) -> add
@   273s  	other8	(cost: 3) -> remove
@   275s  	other9	(cost: 3) -> remove
@   279s  	global11	(cost: 3) -> remove
@   283s  	other11	(cost: 2) -> add
@   285s  	other19	(cost: 2) -> add
@   287s  	global5	(cost: 2) -> remove
@   289s  	global7	(cost: 2) -> remove
@   292s  	global5_1	(cost: 2) -> add
@   294s  	global3	(cost: 1) -> add
@   295s  	global4_1	(cost: 1) -> add
@   295s  	global6	(cost: 1) -> add
	Minimized certificate: 33 -> 16
@   297s  -------------------------------------------------
### Proof certificate (required): #16
invariant [other5]	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
invariant [other3]	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global9]	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other10]	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
invariant [other1]	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
invariant [other18]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
invariant [other13]	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
invariant [other2]	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
invariant [prop1]	(forall I6, T6, S6 . ((committed(I6, T6) & leader(S6) & (lte(T6, currentTerm(S6)) & ~(T6 = currentTerm(S6)))) -> (log(S6, I6) = T6)))
invariant [other15]	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
invariant [other11]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [other19]	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
invariant [global5_1]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [global3]	(forall S0 . (log(S0, indzero) = termzero))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [global6]	(forall T0 . ~committed(indzero, T0))
###

### Optional invariants: #17
invariant [other12_optional]	(exists Q0 . (forall S0, S1, I0, I2, T0, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & (loglen(S0) = I0) & committed(I2, T1) & indlt(I0, I2) & member(S0, Q0)) -> ((I0 = indzero) | (T0 = T1)))))
invariant [other21_optional]	(forall Q0, S0, S1, I1, T0, T1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0) | lte(T1, T0) | member(S1, Q0))))
invariant [other14_optional]	(forall T2, Q0, S0, S1, I1, T1 . (committed(I1, T2) -> ((I1 = loglen(S1)) | member(S1, Q0) | (log(S0, loglen(S0)) = T2) | (loglen(S0) = I1) | lte(T1, T2) | (loglen(S0) = loglen(S1)))))
invariant [other20_optional]	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> ((I1 = loglen(S1)) | member(S1, Q0) | (T0 = currentTerm(S0)) | (loglen(S0) = I1) | (loglen(S0) = loglen(S1)))))
invariant [other22_optional]	(forall Q0, S0, S1, I1, T0 . (committed(I1, T0) -> (member(S1, Q0) | (T0 = currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))) | (T0 = log(S0, loglen(S0))) | (S0 = S1))))
invariant [other16_optional]	(forall Q0, S0, S1, I1, T0 . ((committed(I1, T0) & (loglen(S0) = indzero)) -> ((S0 = S1) | member(S1, Q0) | (T0 = log(S1, I1)))))
invariant [other6_optional]	(forall T2, Q0, S0, S1, I1 . (committed(I1, T2) -> ((loglen(S1) = I1) | (I1 = loglen(S0)) | (loglen(S1) = loglen(S0)) | (log(S1, loglen(S1)) = T2) | (log(S0, I1) = T2) | member(S0, Q0) | (log(S0, I1) = log(S1, loglen(S1))))))
invariant [global8_optional]	(exists Q0 . (forall S1, T1, S0 . (((currentTerm(S0) = termzero) & (currentTerm(S1) = T1) & member(S0, Q0)) -> (termzero = T1))))
invariant [other7_optional]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((T0 = currentTerm(S0)) | (loglen(S0) = loglen(S1)) | (loglen(S0) = I2) | (T0 = log(S1, I2)) | (loglen(S1) = I2) | (log(S1, I2) = currentTerm(S0)))))
invariant [other4_optional]	(forall I1, S1, T0, S0 . (((loglen(S1) = indzero) & committed(I1, T0)) -> ((S0 = S1) | leader(S0))))
invariant [other17_optional]	(forall T2, S0, I1 . (((log(S0, I1) = currentTerm(S0)) & leader(S0)) -> (lte(T2, currentTerm(S0)) | (currentTerm(S0) = log(S0, loglen(S0))))))
invariant [global4_optional]	(exists Q0 . (forall T1, S0 . ((currentTerm(S0) = T1) -> ((termzero = T1) | member(S0, Q0)))))
invariant [other8_optional]	(forall S1, T1, S0 . (((loglen(S0) = indzero) & committed(loglen(S1), log(S0, loglen(S1))) & leader(S0)) -> lte(T1, log(S0, loglen(S1)))))
invariant [other9_optional]	(forall T2, S0, S1 . ((loglen(S0) = indzero) -> ((log(S0, loglen(S1)) = log(S1, indzero)) | leader(S0) | lte(T2, log(S0, loglen(S1))))))
invariant [global11_optional]	(exists S0 . (forall I1, T0 . ((loglen(S0) = indzero) -> ~committed(I1, T0))))
invariant [global5_optional]	(exists Q0 . (forall S0 . (leader(S0) -> member(S0, Q0))))
invariant [global7_optional]	(forall T0, I0 . (committed(I0, T0) -> indlte(I0, I0)))
###

	random:	0
	scalls:	2938
	scalls-finite:	2916
	scalls-infinite:	22
	scalls-finite-full:	2916
	cti:	106
	cubes:	109
	subsumed-calls:	3717
	subsumed-subset:	0
	subsumed-varintersect-c:	3598
	subsumed-varintersect-e:	0
	subsumed-query-sat:	111
	subsumed-query-unsat:	8
	subsumed-eq:	246
	unsat-core:	203
	sz-unsat-core-avg:	7.00
	sz-unsat-min-avg:	3.66
	sz-cube-avg:	56.70
	antecedent-reduction-sum:	119
	antecedent-total-sum:	434
	antecedent-reduction-avg:	0.27
	antecedent-calls:	97
	antecedent-calls-reduced:	46
	antecedent-scalls:	528
	time-q-max-finite-ms:	53645
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	5
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	3
	time-cti-bad-unsat:	5
	time-cti-sat:	2
	time-cti-unsat:	25
	time-forward:	59
	time-antecedent:	28
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	16
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	92
	time-qf:	0
	time-sum:	232
@   297s  -------------------------------------------------
@   297s  -------------------------------------------------
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   297s  (finite convergence checks)
@   297s  (performing finite convergence checks for quorum)
(enumsort) index <-> index:e7:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e7:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e7:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e7:
	[ SERVER0, SERVER1, ] <-> [ s0, s1, ]
	dep_height[t0] = 0
	dep_height[t1] = 1
	dep_height[t2] = 2
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[s0] = 300
	dep_height[s1] = 301
(use_wires: False)
@   297s  -------------------------------------------------
### Invariant: #16
invariant [other15]	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
invariant [global9]	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other2]	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
invariant [prop1]	(forall I7, T7, S7 . ((committed(I7, T7) & leader(S7) & (lte(T7, currentTerm(S7)) & ~(T7 = currentTerm(S7)))) -> (log(S7, I7) = T7)))
invariant [other11]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
invariant [other18]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
invariant [other5]	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
invariant [global6]	(forall T0 . ~committed(indzero, T0))
invariant [other1]	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
invariant [global3]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other13]	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other3]	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global5_1]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other10]	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
invariant [other19]	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other15 -> UNSAT
	#2 global9 -> UNSAT
	#3 other2 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other10 -> UNSAT
	#6 other18 -> UNSAT
	#7 other5 -> UNSAT
	#8 global6 -> UNSAT
	#9 other1 -> UNSAT
	#10 global3 -> UNSAT
	#11 other13 -> UNSAT
	#12 global5_1 -> UNSAT
	#13 other3 -> UNSAT
	#14 global4_1 -> UNSAT
	#15 other11 -> UNSAT
	#16 other19 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other15 -> UNSAT
	#2 global9 -> UNSAT
	#3 other2 -> UNSAT
	#4 prop1  (property) -> UNSAT
	#5 other10 -> UNSAT
	#6 other18 -> UNSAT
	#7 other5 -> UNSAT
	#8 global6 -> UNSAT
	#9 other1 -> UNSAT
	#10 global3 -> UNSAT
	#11 other13 -> UNSAT
	#12 global5_1 -> UNSAT
	#13 other3 -> UNSAT
	#14 global4_1 -> UNSAT
	#15 other11 -> UNSAT
	#16 other19 -> UNSAT
	Inv_all /\ T /\ !Inv+: passed

Finite sorts: #4
	index -> index:e7: -> [`index:e7:0`, `index:e7:1`, `index:e7:2`]
	term -> term:e7: -> [`term:e7:0`, `term:e7:1`, `term:e7:2`]
	quorum -> quorum:e7: -> [`quorum:e7:0`, `quorum:e7:1`, `quorum:e7:2`]
	server -> server:e7: -> [`server:e7:0`, `server:e7:1`]

Invariant is a proof certificate
@   300s  -------------------------------------------------
@   300s  (performing finite convergence checks for server)
(enumsort) index <-> index:e8:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e8:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e8:
	[ QUORUM0, QUORUM1, QUORUM2, ] <-> [ q0, q1, q2, ]
(enumsort) server <-> server:e8:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[s0] = 0
	dep_height[s1] = 1
	dep_height[s2] = 2
	dep_height[i0] = 100
	dep_height[i1] = 101
	dep_height[i2] = 102
	dep_height[q0] = 200
	dep_height[q1] = 201
	dep_height[q2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
@   300s  -------------------------------------------------
### Invariant: #16
invariant [other13]	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
invariant [other15]	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
invariant [other1]	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
invariant [other2]	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
invariant [global5_1]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other19]	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
invariant [other3]	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [global6]	(forall T0 . ~committed(indzero, T0))
invariant [other5]	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
invariant [global3]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other10]	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other18]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
invariant [global9]	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [prop1]	(forall I8, T8, S8 . ((committed(I8, T8) & leader(S8) & (lte(T8, currentTerm(S8)) & ~(T8 = currentTerm(S8)))) -> (log(S8, I8) = T8)))
invariant [other11]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
###


Inv_all /\ !P -> UNSAT
Inv_all /\ T /\ !P+ -> UNSAT
Checking Init /\ !Inv:
	#1 other15 -> UNSAT
	#2 other1 -> UNSAT
	#3 other2 -> UNSAT
	#4 global5_1 -> UNSAT
	#5 other19 -> UNSAT
	#6 other3 -> UNSAT
	#7 global6 -> UNSAT
	#8 other5 -> UNSAT
	#9 global3 -> UNSAT
	#10 other10 -> UNSAT
	#11 global4_1 -> UNSAT
	#12 other18 -> UNSAT
	#13 other13 -> UNSAT
	#14 global9 -> UNSAT
	#15 prop1  (property) -> UNSAT
	#16 other11 -> UNSAT
	Init /\ !Inv: passed
Checking Inv_all /\ T /\ !Inv+:
	#1 other15 -> UNSAT
	#2 other1 -> SAT
	#3 other2 -> SAT
	#4 global5_1 -> SAT
	#5 other19 -> SAT
	#6 other3 -> SAT
	#7 global6 -> UNSAT
	#8 other5 -> UNSAT
	#9 global3 -> UNSAT
	#10 other10 -> SAT
	#11 global4_1 -> UNSAT
	#12 other18 -> SAT
	#13 other13 -> SAT
	#14 global9 -> UNSAT
	#15 prop1  (property) -> UNSAT
	#16 other11 -> SAT
	Inv_all /\ T /\ !Inv+: 9 failed

Finite sorts: #4
	index -> index:e8: -> [`index:e8:0`, `index:e8:1`, `index:e8:2`]
	term -> term:e8: -> [`term:e8:0`, `term:e8:1`, `term:e8:2`]
	quorum -> quorum:e8: -> [`quorum:e8:0`, `quorum:e8:1`, `quorum:e8:2`]
	server -> server:e8: -> [`server:e8:0`, `server:e8:1`, `server:e8:2`]

Invariant is not a proof certificate
@   308s  -------------------------------------------------
@   308s  (extended |server| to 3)
@   308s  (finite convergence checks failed for server)
(enumsort) index <-> index:e9:
	[ INDEX0, INDEX1, INDEX2, ] <-> [ i0, i1, i2, ]
(enumsort) term <-> term:e9:
	[ TERM0, TERM1, TERM2, ] <-> [ t0, t1, t2, ]
(enumsort) quorum <-> quorum:e9:
	[ QUORUM0, QUORUM1, ] <-> [ q0, q1, ]
(enumsort) server <-> server:e9:
	[ SERVER0, SERVER1, SERVER2, ] <-> [ s0, s1, s2, ]
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[s2] = 102
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)
sort: index <-> unbounded
sort: term <-> unbounded
sort: quorum <-> unbounded
sort: server <-> unbounded
(use_wires: False)
@   308s  -------------------------------------------------
### Checking reusability of clauses: #15
invariant [other19]	(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
invariant [global5_1]	(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
invariant [other18]	(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
invariant [other5]	(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
invariant [other3]	(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
invariant [other2]	(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
invariant [global6]	(forall T0 . ~committed(indzero, T0))
invariant [global4_1]	(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
invariant [other15]	(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
invariant [global3]	(forall S0 . (log(S0, indzero) = termzero))
invariant [other10]	(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
invariant [global9]	(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
invariant [other1]	(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
invariant [other13]	(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
invariant [other11]	(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
###

Checking Init /\ !Inv:
	#1 other19 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other18 -> UNSAT
	#4 other5 -> UNSAT
	#5 other3 -> UNSAT
	#6 other2 -> UNSAT
	#7 global6 -> UNSAT
	#8 global4_1 -> UNSAT
	#9 other15 -> UNSAT
	#10 global3 -> UNSAT
	#11 other10 -> UNSAT
	#12 global9 -> UNSAT
	#13 other1 -> UNSAT
	#14 other13 -> UNSAT
	#15 other11 -> UNSAT
	Init /\ !Inv: passed
Checking Init /\ T /\ !Inv+:
	#1 other19 -> UNSAT
	#2 global5_1 -> UNSAT
	#3 other18 -> UNSAT
	#4 other5 -> UNSAT
	#5 other3 -> UNSAT
	#6 other2 -> UNSAT
	#7 global6 -> UNSAT
	#8 global4_1 -> UNSAT
	#9 other15 -> UNSAT
	#10 global3 -> UNSAT
	#11 other10 -> UNSAT
	#12 global9 -> UNSAT
	#13 other1 -> UNSAT
	#14 other13 -> UNSAT
	#15 other11 -> UNSAT
	Init /\ T /\ !Inv+: passed

Finite sorts: #0

Reusable: 15 -> 15 (0 + 0 failed)
All clauses reusable
@   308s  -------------------------------------------------
	random:	0
	scalls:	3036
	scalls-finite:	2984
	scalls-infinite:	52
	scalls-finite-full:	2984
	cti:	106
	cubes:	109
	subsumed-calls:	3717
	subsumed-subset:	0
	subsumed-varintersect-c:	3598
	subsumed-varintersect-e:	0
	subsumed-query-sat:	111
	subsumed-query-unsat:	8
	subsumed-eq:	246
	unsat-core:	203
	sz-unsat-core-avg:	7.00
	sz-unsat-min-avg:	3.66
	sz-cube-avg:	56.70
	antecedent-reduction-sum:	119
	antecedent-total-sum:	434
	antecedent-reduction-avg:	0.27
	antecedent-calls:	97
	antecedent-calls-reduced:	46
	antecedent-scalls:	528
	time-q-max-finite-ms:	53645
	time-q-max-finite-core-ms:	0
	time-q-max-infinite-ms:	28
	time-q-max-infinite-core-ms:	0
	time-cti-bad-sat:	3
	time-cti-bad-unsat:	5
	time-cti-sat:	2
	time-cti-unsat:	25
	time-forward:	59
	time-antecedent:	28
	time-subsume:	2
	time-subsume-query:	2
	time-inv-check-finite:	26
	time-inv-check-infinite:	0
	time-inv-reuse:	0
	time-minimize:	92
	time-qf:	0
	time-sum:	242
@   308s  -------------------------------------------------
@   308s  -------------------------------------------------
@   308s  (incremental SymIC3)
	dep_height[q0] = 0
	dep_height[q1] = 1
	dep_height[s0] = 100
	dep_height[s1] = 101
	dep_height[s2] = 102
	dep_height[i0] = 200
	dep_height[i1] = 201
	dep_height[i2] = 202
	dep_height[t0] = 300
	dep_height[t1] = 301
	dep_height[t2] = 302
(use_wires: False)

Checking property...

@   308s  Storing init values:
@   308s  Init -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(one of the initial states)
	(currentTerm(s0) = t0)
	(currentTerm(s1) = t0)
	(currentTerm(s2) = t0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(log(s0, i2) = t0)
	(log(s1, i0) = t0)
	(log(s1, i1) = t0)
	(log(s1, i2) = t0)
	(log(s2, i0) = t0)
	(log(s2, i1) = t0)
	(log(s2, i2) = t0)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(loglen(s2) = i0)
	(indzero = i0)
	(termzero = t0)
	indlt(i0, i1)
	indlt(i0, i2)
	indlt(i1, i2)
	indlte(i0, i1)
	indlte(i0, i2)
	indlte(i1, i2)
	lte(t0, t0)
	lte(t0, t1)
	lte(t0, t2)
	lte(t1, t1)
	lte(t1, t2)
	lte(t2, t2)
	member(s1, q0)
	member(s1, q1)
	~committed(i0, t0)
	~committed(i0, t1)
	~committed(i0, t2)
	~committed(i1, t0)
	~committed(i1, t1)
	~committed(i1, t2)
	~committed(i2, t0)
	~committed(i2, t1)
	~committed(i2, t2)
	~leader(s0)
	~leader(s1)
	~leader(s2)
	~indlt(i0, i0)
	~indlt(i1, i0)
	~indlt(i1, i1)
	~indlt(i2, i0)
	~indlt(i2, i1)
	~indlt(i2, i2)
	~indlte(i0, i0)
	~indlte(i1, i0)
	~indlte(i1, i1)
	~indlte(i2, i0)
	~indlte(i2, i1)
	~indlte(i2, i2)
	~lte(t1, t0)
	~lte(t2, t0)
	~lte(t2, t1)
	~member(s0, q0)
	~member(s0, q1)
	~member(s2, q0)
	~member(s2, q1)
	~succ(i0, i0)
	~succ(i0, i1)
	~succ(i0, i2)
	~succ(i1, i0)
	~succ(i1, i1)
	~succ(i1, i2)
	~succ(i2, i0)
	~succ(i2, i1)
	~succ(i2, i2)

@   308s  F[0] /\ !P -> UNSAT
@   308s  F[0] /\ T /\ !P+ -> UNSAT
Frames: #1
	F[0]: #1
		((forall S10 . ~leader(S10)) & (forall S10 . (currentTerm(S10) = termzero)) & (forall S10 . (loglen(S10) = indzero)) & (forall S10, I10_1 . (log(S10, I10_1) = termzero)) & (forall I10, T10 . ~committed(I10, T10)))
@   308s  
Adding frame 1...
@   308s  Is F[0] -> other18? -> UNSAT
@   308s  Is other18 inductive? -> SAT
@   308s  Is F[0] /\ T -> other18+? -> UNSAT
@   308s  Learning in F[1]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@   308s  Is F[0] -> other3? -> UNSAT
@   308s  Is other3 inductive? -> SAT
@   308s  Is F[0] /\ T -> other3+? -> UNSAT
@   308s  Learning in F[1]: (forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   308s  Is F[0] -> other15? -> UNSAT
@   308s  Is other15 inductive? -> SAT
@   308s  Is F[0] /\ T -> other15+? -> UNSAT
@   308s  Learning in F[1]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@   308s  Is F[0] -> global5_1? -> UNSAT
@   308s  Is global5_1 inductive? -> SAT
@   308s  Is F[0] /\ T -> global5_1+? -> UNSAT
@   308s  Learning in F[1]: (forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   308s  Is F[0] -> other19? -> UNSAT
@   308s  Is other19 inductive? -> SAT
@   308s  Is F[0] /\ T -> other19+? -> UNSAT
@   308s  Learning in F[1]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@   308s  Is F[0] -> other2? -> UNSAT
@   308s  Is other2 inductive? -> SAT
@   308s  Is F[0] /\ T -> other2+? -> UNSAT
@   308s  Learning in F[1]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   308s  Is F[0] -> global6? -> UNSAT
@   308s  Is global6 inductive? -> UNSAT
@   308s  Is F[0] -> other5? -> UNSAT
@   308s  Is other5 inductive? -> SAT
@   308s  Is F[0] /\ T -> other5+? -> UNSAT
@   308s  Learning in F[1]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@   308s  Is F[0] -> global3? -> UNSAT
@   308s  Is global3 inductive? -> UNSAT
@   308s  Is F[0] -> other13? -> UNSAT
@   308s  Is other13 inductive? -> SAT
@   308s  Is F[0] /\ T -> other13+? -> UNSAT
@   308s  Learning in F[1]: (forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
@   308s  Is F[0] -> other10? -> UNSAT
@   308s  Is other10 inductive? -> SAT
@   308s  Is F[0] /\ T -> other10+? -> UNSAT
@   308s  Learning in F[1]: (forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
@   308s  Is F[0] -> global4_1? -> UNSAT
@   308s  Is global4_1 inductive? -> UNSAT
@   308s  Is F[0] -> global9? -> UNSAT
@   309s  Is global9 inductive? -> UNSAT
@   309s  Is F[0] -> other1? -> UNSAT
@   309s  Is other1 inductive? -> SAT
@   309s  Is F[0] /\ T -> other1+? -> UNSAT
@   309s  Learning in F[1]: (forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
@   309s  Is F[0] -> other11? -> UNSAT
@   309s  Is other11 inductive? -> SAT
@   309s  Is F[0] /\ T -> other11+? -> UNSAT
@   309s  Learning in F[1]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
Seeded 15 (global: 4, init: 11) helpers out of 15
@   309s  Learning in F[1]: (forall S0 . (log(S0, indzero) = termzero))
@   309s  Learning in F[1]: (forall T0 . ~committed(indzero, T0))
@   309s  Learning in F[1]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   309s  Learning in F[1]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   309s  F[1] /\ T /\ !P+ -> UNSAT
Frames: #2
	F[0]: #1
		((forall S10 . ~leader(S10)) & (forall S10 . (currentTerm(S10) = termzero)) & (forall S10 . (loglen(S10) = indzero)) & (forall S10, I10_1 . (log(S10, I10_1) = termzero)) & (forall I10, T10 . ~committed(I10, T10)))
	F[1]: #15
		(forall S0 . (log(S0, indzero) = termzero))
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(forall S1, I1, T1, S0 . ((committed(I1, T1) & (loglen(S1) = indzero)) -> ((S0 = S1) | (currentTerm(S0) = T1))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
		(forall T0 . ~committed(indzero, T0))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
@   310s  
Adding frame 2...
Trying forwarding F[1]
Forwarded #6 to F[2]
@   311s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   311s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@   311s  Learning in F[2]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   311s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   311s  Learning in F[2]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@   311s  Learning in F[2]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@   311s  Learning in F[2]: (forall S0 . (log(S0, indzero) = termzero))
@   311s  Learning in F[2]: (forall T0 . ~committed(indzero, T0))
@   311s  Learning in F[2]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@   311s  Learning in F[2]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@   311s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@   311s  F[1] /\ T /\ C+ ?
@   312s  	Ans. UNSAT
@   312s  F[2] unsat core #8 	(ucsz: 14 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s2) = i0)
	(currentTerm(s0) = t0)
	(currentTerm(s2) = t0)
	leader(s0)
	(log(s0, i0) = t1)
	leader(s2)
	(log(s1, i0) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s2) = t0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | ~leader(s0) | ~leader(s2))
(relations)
	loglen
	log
	leader
	currentTerm
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	leader(SERVER2)
	leader(SERVER0)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	(currentTerm(SERVER2) = TERM0)
	(currentTerm(SERVER0) = TERM0)
(antecedent reduction)
@   312s  antecedent: 5 -> 5

qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX0), (currentTerm(SERVER2) = TERM0), leader(SERVER2), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM1), (loglen(SERVER0) = INDEX0), (currentTerm(SERVER0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ (currentTerm(V:server:e9:) = TERM0), leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), ]
	SERVER0 -> [ (log(V:server:e9:, INDEX0) = TERM1), (currentTerm(V:server:e9:) = TERM0), leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = TERM0), ]
ucubes2qv #3
	((currentTerm(V:server:e9:) = TERM0) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER2, ]
	((currentTerm(V:server:e9:) = TERM0) & (log(V:server:e9:, INDEX0) = TERM1) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER0, ]
	(log(V:server:e9:, INDEX0) = TERM0) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER0, loglen(SERVER2))
	TERM0 -> log(SERVER1, loglen(SERVER2))
	INDEX0 -> loglen(SERVER2)
(cube eq: post)
	~(log(SERVER1, loglen(SERVER2)) = log(SERVER0, loglen(SERVER2)))
	(loglen(SERVER0) = loglen(SERVER2))
	~(SERVER0 = SERVER2)
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER2)))
	~(SERVER1 = SERVER2)
	leader(SERVER2)
	leader(SERVER0)
	~(SERVER0 = SERVER1)
	(currentTerm(SERVER2) = log(SERVER1, loglen(SERVER2)))
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER2)) = log(SERVER0, loglen(SERVER2))) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER2))) | (SERVER1 = SERVER2) | ~leader(SERVER2) | ~leader(SERVER0) | (SERVER0 = SERVER1) | ~(currentTerm(SERVER2) = log(SERVER1, loglen(SERVER2)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(currentTerm(s2) = t0) | ~(log(s0, i0) = t1) | ~(log(s1, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | ~leader(s0) | ~leader(s2))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . ((log(SERVER1, loglen(SERVER2)) = log(SERVER0, loglen(SERVER2))) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER2))) | (SERVER1 = SERVER2) | ~leader(SERVER2) | ~leader(SERVER0) | (SERVER0 = SERVER1) | ~(currentTerm(SERVER2) = log(SERVER1, loglen(SERVER2)))))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . (((loglen(S0) = loglen(S2)) & (currentTerm(S0) = log(S1, loglen(S2))) & leader(S2) & leader(S0) & (currentTerm(S2) = log(S1, loglen(S2)))) -> ((log(S1, loglen(S2)) = log(S0, loglen(S2))) | (S0 = S2) | (S1 = S2) | (S0 = S1))))
@   312s  is global clause? No
@   312s  Learning in F[2]: (forall S2, S0, S1 . (((loglen(S0) = loglen(S2)) & (currentTerm(S0) = log(S1, loglen(S2))) & leader(S2) & leader(S0) & (currentTerm(S2) = log(S1, loglen(S2)))) -> ((log(S1, loglen(S2)) = log(S0, loglen(S2))) | (S0 = S2) | (S1 = S2) | (S0 = S1))))
@   312s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   312s  F[1] /\ T /\ C+ ?
@   312s  	Ans. UNSAT
@   313s  F[2] unsat core #8 	(ucsz: 13 -> 12 -> 9 -> 8 -> 8)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	leader(s0)
	leader(s1)
	(currentTerm(s0) = t1)
	(currentTerm(s1) = t2)
	(log(s0, i0) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~leader(s0) | ~leader(s1))
(relations)
	loglen
	log
	leader
	currentTerm
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	leader(SERVER1)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER1) = TERM2)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@   313s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), (log(SERVER1, INDEX0) = TERM1), ]
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e9:), (currentTerm(SERVER0) = V:term:e9:), ]
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e9:), ]
ucubes2qv #3
	((currentTerm(SERVER0) = V:term:e9:) & (log(SERVER1, INDEX0) = V:term:e9:)) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
	(currentTerm(SERVER1) = V:term:e9:) -> [ TERM2, ]
(partition) #3 term:e9: -> { TERM1, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	TERM2 -> currentTerm(SERVER1)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER1))
	~(log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1))
	(loglen(SERVER1) = loglen(SERVER0))
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0)))
	leader(SERVER0)
	leader(SERVER1)
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER1)) | (log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1)) | ~(loglen(SERVER1) = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER0) | ~leader(SERVER1) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER0)) = currentTerm(SERVER1)) | (log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1)) | ~(loglen(SERVER1) = loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER0) | ~leader(SERVER1) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S0, S1 . (((loglen(S1) = loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0))) & leader(S0) & leader(S1)) -> ((log(S0, loglen(S0)) = currentTerm(S1)) | (log(S1, loglen(S0)) = currentTerm(S1)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@   313s  is global clause? No
@   313s  Learning in F[2]: (forall S0, S1 . (((loglen(S1) = loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0))) & leader(S0) & leader(S1)) -> ((log(S0, loglen(S0)) = currentTerm(S1)) | (log(S1, loglen(S0)) = currentTerm(S1)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@   313s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   313s  F[1] /\ T /\ C+ ?
@   313s  	Ans. UNSAT
@   313s  F[2] unsat core #8 	(ucsz: 19 -> 12 -> 12 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	(log(s2, i2) = t0)
	(loglen(s0) = i0)
	(log(s0, i0) = t0)
	leader(s2)
	(loglen(s2) = i2)
	indlt(i0, i2)
	(currentTerm(s2) = t1)
	(log(s2, i0) = t2)
(clause)
	(~(currentTerm(s2) = t1) | ~(log(s0, i0) = t0) | ~(log(s2, i0) = t2) | ~(log(s2, i2) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~indlt(i0, i2) | ~leader(s2))
(relations)
	loglen
	currentTerm
	log
	leader
	indlt
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	indlt(INDEX0, INDEX1)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(log(SERVER1, INDEX0) = TERM2)
	(currentTerm(SERVER1) = TERM1)
	leader(SERVER1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@   314s  antecedent: 7 -> 3 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), (log(SERVER1, INDEX1) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER1) = TERM1), ]
	TERM2 -> [ (log(SERVER1, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER1, INDEX1) = V:term:e9:), (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ (currentTerm(SERVER1) = V:term:e9:), ]
	TERM2 -> [ (log(SERVER1, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e9:) -> [ TERM2, ]
	((log(SERVER0, INDEX0) = V:term:e9:) & (log(SERVER1, INDEX1) = V:term:e9:)) -> [ TERM0, ]
	(currentTerm(SERVER1) = V:term:e9:) -> [ TERM1, ]
(partition) #3 term:e9: -> { TERM2, | TERM0, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER1)
	TERM0 -> log(SERVER1, loglen(SERVER1))
	INDEX0 -> loglen(SERVER0)
	TERM2 -> log(SERVER1, loglen(SERVER0))
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER1)))
	leader(SERVER1)
	~(log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1))
	indlt(loglen(SERVER0), loglen(SERVER1))
	~(log(SERVER1, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0)))
	~(currentTerm(SERVER1) = log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER1))) | ~leader(SERVER1) | (log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | ~indlt(loglen(SERVER0), loglen(SERVER1)) | (log(SERVER1, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | (currentTerm(SERVER1) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s2) = t1) | ~(log(s0, i0) = t0) | ~(log(s2, i0) = t2) | ~(log(s2, i2) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~indlt(i0, i2) | ~leader(s2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER1))) | ~leader(SERVER1) | (log(SERVER1, loglen(SERVER1)) = currentTerm(SERVER1)) | ~indlt(loglen(SERVER0), loglen(SERVER1)) | (log(SERVER1, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | (currentTerm(SERVER1) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S0, S1 . (((log(S0, loglen(S0)) = log(S1, loglen(S1))) & leader(S1) & indlt(loglen(S0), loglen(S1))) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S1, loglen(S1)) = log(S1, loglen(S0))) | (currentTerm(S1) = log(S1, loglen(S0))))))
@   314s  is global clause? No
@   314s  Learning in F[2]: (forall S0, S1 . (((log(S0, loglen(S0)) = log(S1, loglen(S1))) & leader(S1) & indlt(loglen(S0), loglen(S1))) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S1, loglen(S1)) = log(S1, loglen(S0))) | (currentTerm(S1) = log(S1, loglen(S0))))))
@   314s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   314s  F[1] /\ T /\ C+ ?
@   314s  	Ans. UNSAT
@   314s  F[2] unsat core #7 	(ucsz: 20 -> 14 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	(log(s2, i1) = t0)
	(loglen(s2) = i1)
	~succ(i1, i0)
	(loglen(s0) = i0)
	(indzero = i1)
	leader(s0)
	(log(s0, i0) = t0)
(clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i1) | ~leader(s0) | succ(i1, i0))
(relations)
	loglen
	indzero
	log
	leader
	succ
(cube: std)
	~succ(INDEX1, INDEX0)
	(indzero = INDEX1)
	leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@   314s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX1 -> indzero
(cube eq)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
	~succ(indzero, INDEX0)
	(loglen(SERVER1) = indzero)
	(log(SERVER1, indzero) = TERM0)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	index:e9:
	-> ~(INDEX0 = indzero)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~succ(indzero, loglen(SERVER0))
	(log(SERVER1, indzero) = log(SERVER0, loglen(SERVER0)))
	~(loglen(SERVER0) = indzero)
	(loglen(SERVER1) = indzero)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | succ(indzero, loglen(SERVER0)) | ~(log(SERVER1, indzero) = log(SERVER0, loglen(SERVER0))) | (loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i1) | ~leader(s0) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | succ(indzero, loglen(SERVER0)) | ~(log(SERVER1, indzero) = log(SERVER0, loglen(SERVER0))) | (loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((leader(S0) & (log(S1, indzero) = log(S0, loglen(S0))) & (loglen(S1) = indzero)) -> (succ(indzero, loglen(S0)) | (loglen(S0) = indzero))))
@   314s  is global clause? No
@   314s  Learning in F[2]: (forall S0, S1 . ((leader(S0) & (log(S1, indzero) = log(S0, loglen(S0))) & (loglen(S1) = indzero)) -> (succ(indzero, loglen(S0)) | (loglen(S0) = indzero))))
@   314s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   315s  F[1] /\ T /\ C+ ?
@   315s  	Ans. UNSAT
@   315s  F[2] unsat core #8 	(ucsz: 16 -> 14 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	(log(s1, i2) = t1)
	(loglen(s0) = i0)
	~leader(s1)
	leader(s0)
	~lte(t2, t1)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t0)
	(log(s2, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i2) = t1) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | leader(s1) | lte(t2, t1))
(relations)
	loglen
	currentTerm
	lte
	leader
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	~lte(TERM2, TERM1)
	(log(SERVER2, INDEX0) = TERM1)
	(log(SERVER1, INDEX1) = TERM1)
	leader(SERVER0)
	~leader(SERVER1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@   315s  antecedent: 8 -> 4 (reduced)
	removed: INDEX1
	removed: INDEX0
	removed: TERM2
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM2, TERM1), (log(SERVER2, INDEX0) = TERM1), (log(SERVER1, INDEX1) = TERM1), (currentTerm(SERVER0) = TERM1), ]
	TERM2 -> [ ~lte(TERM2, TERM1), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ ~lte(TERM2, V:term:e9:), (log(SERVER2, INDEX0) = V:term:e9:), (log(SERVER1, INDEX1) = V:term:e9:), (currentTerm(SERVER0) = V:term:e9:), ]
	TERM2 -> [ ~lte(V:term:e9:, TERM1), ]
ucubes2qv #3
	~lte(V:term:e9:, TERM1) -> [ TERM2, ]
	((currentTerm(SERVER0) = V:term:e9:) & (log(SERVER1, INDEX1) = V:term:e9:) & (log(SERVER2, INDEX0) = V:term:e9:) & ~lte(TERM2, V:term:e9:)) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { TERM2, | TERM1, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM1), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM0), (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ~leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM1), leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX1) = TERM1), ~leader(V:server:e9:), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM1) -> [ SERVER2, ]
	((currentTerm(V:server:e9:) = TERM1) & (log(V:server:e9:, INDEX0) = TERM0) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER0, ]
	((log(V:server:e9:, INDEX1) = TERM1) & ~leader(V:server:e9:)) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM0 -> log(SERVER0, loglen(SERVER0))
	TERM1 -> log(SERVER2, loglen(SERVER0))
(cube eq: post)
	~lte(TERM2, log(SERVER2, loglen(SERVER0)))
	(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0)))
	(currentTerm(SERVER0) = log(SERVER2, loglen(SERVER0)))
	~(SERVER1 = SERVER2)
	leader(SERVER0)
	~leader(SERVER1)
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))
(qvars eq: post)
	SERVER2
	INDEX1
	TERM2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, TERM2, SERVER0, SERVER1 . (lte(TERM2, log(SERVER2, loglen(SERVER0))) | ~(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER2, loglen(SERVER0))) | (SERVER1 = SERVER2) | ~leader(SERVER0) | leader(SERVER1) | (log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i2) = t1) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | leader(s1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, TERM2, SERVER0, SERVER1 . (lte(TERM2, log(SERVER2, loglen(SERVER0))) | ~(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER2, loglen(SERVER0))) | (SERVER1 = SERVER2) | ~leader(SERVER0) | leader(SERVER1) | (log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S2, I1, T2, S0, S1 . (((log(S1, I1) = log(S2, loglen(S0))) & (currentTerm(S0) = log(S2, loglen(S0))) & leader(S0)) -> (lte(T2, log(S2, loglen(S0))) | (S1 = S2) | leader(S1) | (log(S0, loglen(S0)) = log(S2, loglen(S0))))))
@   315s  is global clause? No
@   315s  Learning in F[2]: (forall S2, I1, T2, S0, S1 . (((log(S1, I1) = log(S2, loglen(S0))) & (currentTerm(S0) = log(S2, loglen(S0))) & leader(S0)) -> (lte(T2, log(S2, loglen(S0))) | (S1 = S2) | leader(S1) | (log(S0, loglen(S0)) = log(S2, loglen(S0))))))
@   315s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   315s  F[1] /\ T /\ C+ ?
@   315s  	Ans. UNSAT
@   316s  F[2] unsat core #8 	(ucsz: 14 -> 13 -> 10 -> 8 -> 8)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	leader(s0)
	leader(s1)
	(termzero = t0)
	(currentTerm(s1) = t2)
	(log(s0, i0) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~leader(s0) | ~leader(s1))
(relations)
	loglen
	log
	termzero
	leader
	currentTerm
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	leader(SERVER1)
	(termzero = TERM0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER1) = TERM2)
(antecedent reduction)
@   316s  antecedent: 5 -> 3 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = termzero)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	leader(SERVER1)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
	(currentTerm(SERVER1) = TERM2)
(qvars eq)
	INDEX0
	TERM1
	TERM2
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e9: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
	termzero -> [ (log(SERVER0, INDEX0) = termzero), ]
	TERM2 -> [ (currentTerm(SERVER1) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e9:), ]
	termzero -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM2 -> [ (currentTerm(SERVER1) = V:term:e9:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e9:) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ termzero, ]
	(currentTerm(SERVER1) = V:term:e9:) -> [ TERM2, ]
(partition) #3 term:e9: -> { TERM1, | termzero, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	TERM2 -> currentTerm(SERVER1)
(cube eq: post)
	~(log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1))
	(loglen(SERVER1) = loglen(SERVER0))
	leader(SERVER0)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(termzero = log(SERVER1, loglen(SERVER0)))
	leader(SERVER1)
	~(termzero = currentTerm(SERVER1))
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1)) | ~(loglen(SERVER1) = loglen(SERVER0)) | ~leader(SERVER0) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (termzero = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER1) | (termzero = currentTerm(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0) | ~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((log(SERVER1, loglen(SERVER0)) = currentTerm(SERVER1)) | ~(loglen(SERVER1) = loglen(SERVER0)) | ~leader(SERVER0) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (termzero = log(SERVER1, loglen(SERVER0))) | ~leader(SERVER1) | (termzero = currentTerm(SERVER1))))
---------------------------
(clause-type: univ)	(forall S1, S0 . (((loglen(S1) = loglen(S0)) & leader(S0) & (log(S0, loglen(S0)) = termzero) & leader(S1)) -> ((log(S1, loglen(S0)) = currentTerm(S1)) | (termzero = log(S1, loglen(S0))) | (termzero = currentTerm(S1)))))
@   316s  is global clause? No
@   316s  Learning in F[2]: (forall S1, S0 . (((loglen(S1) = loglen(S0)) & leader(S0) & (log(S0, loglen(S0)) = termzero) & leader(S1)) -> ((log(S1, loglen(S0)) = currentTerm(S1)) | (termzero = log(S1, loglen(S0))) | (termzero = currentTerm(S1)))))
@   316s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   316s  F[1] /\ T /\ C+ ?
@   316s  	Ans. UNSAT
@   317s  F[2] unsat core #7 	(ucsz: 17 -> 15 -> 12 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	indlt(i2, i0)
	(loglen(s0) = i0)
	leader(s0)
	(loglen(s2) = i2)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~indlt(i2, i0) | ~leader(s0))
(relations)
	loglen
	currentTerm
	log
	leader
	indlt
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	indlt(INDEX1, INDEX0)
	(loglen(SERVER2) = INDEX1)
	(log(SERVER1, INDEX0) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@   317s  antecedent: 7 -> 4 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: SERVER0

qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX1), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM0), (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM1), leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM1) -> [ SERVER1, ]
	((currentTerm(V:server:e9:) = TERM1) & (log(V:server:e9:, INDEX0) = TERM0) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER0, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER2, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER0, | SERVER2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	INDEX1 -> loglen(SERVER2)
(cube eq: post)
	leader(SERVER0)
	indlt(loglen(SERVER2), loglen(SERVER0))
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0)))
	~(SERVER1 = SERVER2)
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~leader(SERVER0) | ~indlt(loglen(SERVER2), loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (SERVER1 = SERVER2) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~indlt(i2, i0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~leader(SERVER0) | ~indlt(loglen(SERVER2), loglen(SERVER0)) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (SERVER1 = SERVER2) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . ((leader(S0) & indlt(loglen(S2), loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0)))) -> ((S1 = S2) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@   317s  is global clause? No
@   317s  Learning in F[2]: (forall S2, S0, S1 . ((leader(S0) & indlt(loglen(S2), loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0)))) -> ((S1 = S2) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
@   317s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   317s  F[1] /\ T /\ C+ ?
@   317s  	Ans. UNSAT
@   318s  F[2] unsat core #5 	(ucsz: 13 -> 11 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(indzero = i0)
	(currentTerm(s2) = t1)
	~leader(s1)
	(loglen(s0) = i0)
	committed(i2, t0)
(clause)
	(~(currentTerm(s2) = t1) | ~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i2, t0) | leader(s1))
(relations)
	loglen
	indzero
	committed
	leader
	currentTerm
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
	(currentTerm(SERVER2) = TERM1)
	~leader(SERVER1)
(antecedent reduction)
@   321s  antecedent: 7 -> 5 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	~leader(SERVER1)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
	(currentTerm(SERVER2) = TERM1)
(qvars eq)
	SERVER2
	INDEX1
	TERM0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (currentTerm(SERVER2) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ (currentTerm(V:server:e9:) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e9:) = indzero), ]
	SERVER1 -> [ ~leader(V:server:e9:), ]
ucubes2qv #3
	(currentTerm(V:server:e9:) = TERM1) -> [ SERVER2, ]
	~leader(V:server:e9:) -> [ SERVER1, ]
	(loglen(V:server:e9:) = indzero) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER1, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER2)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(TERM0 = currentTerm(SERVER2))
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~leader(SERVER1)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
(qvars eq: post)
	SERVER2
	INDEX1
	TERM0
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, TERM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (TERM0 = currentTerm(SERVER2)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | leader(SERVER1) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))
---------------------------
(original clause)
	(~(currentTerm(s2) = t1) | ~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i2, t0) | leader(s1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, TERM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (TERM0 = currentTerm(SERVER2)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | leader(SERVER1) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0)))
---------------------------
(clause-type: univ)	(forall S2, I1, T0, S0, S1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | (T0 = currentTerm(S2)) | (S0 = S2) | (S1 = S2) | leader(S1))))
@   321s  is global clause? No
@   321s  Learning in F[2]: (forall S2, I1, T0, S0, S1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> ((S0 = S1) | (T0 = currentTerm(S2)) | (S0 = S2) | (S1 = S2) | leader(S1))))
@   321s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   321s  F[1] /\ T /\ C+ ?
@   321s  	Ans. UNSAT
@   322s  F[2] unsat core #6 	(ucsz: 11 -> 10 -> 7 -> 6 -> 6)
(minimal unsat core)
	~member(s1, q0)
	member(s0, q0)
	member(s0, q1)
	~lte(t1, t0)
	committed(i1, t0)
	(log(s0, i1) = t1)
(clause)
	(~(log(s0, i1) = t1) | ~committed(i1, t0) | ~member(s0, q0) | ~member(s0, q1) | lte(t1, t0) | member(s1, q0))
(relations)
	member
	committed
	lte
	log
(fullsorts)
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	~member(SERVER1, QUORUM0)
	~lte(TERM1, TERM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	committed(INDEX0, TERM0)
(antecedent reduction)
@   323s  antecedent: 6 -> 2 (reduced)
	removed: TERM0
	removed: TERM1
	removed: SERVER0
	removed: SERVER1

qv2cubes #2
	QUORUM0 -> [ ~member(SERVER1, QUORUM0), member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER1, V:quorum:e9:), member(SERVER0, V:quorum:e9:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e9:), ]
ucubes2qv #2
	member(SERVER0, V:quorum:e9:) -> [ QUORUM1, ]
	(member(SERVER0, V:quorum:e9:) & ~member(SERVER1, V:quorum:e9:)) -> [ QUORUM0, ]
(partition) #2 quorum:e9: -> { QUORUM1, | QUORUM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~lte(log(SERVER0, INDEX0), TERM0)
	~(QUORUM0 = QUORUM1)
	~member(SERVER1, QUORUM0)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
	committed(INDEX0, TERM0)
(qvars eq: post)
	INDEX0
	TERM0
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, TERM0, QUORUM0, QUORUM1, SERVER0, SERVER1 . (lte(log(SERVER0, INDEX0), TERM0) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0) | ~committed(INDEX0, TERM0)))
---------------------------
(original clause)
	(~(log(s0, i1) = t1) | ~committed(i1, t0) | ~member(s0, q0) | ~member(s0, q1) | lte(t1, t0) | member(s1, q0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0, QUORUM0, QUORUM1, SERVER0, SERVER1 . (lte(log(SERVER0, INDEX0), TERM0) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0) | ~committed(INDEX0, TERM0)))
---------------------------
(clause-type: univ)	(forall I0, T0, Q0, Q1, S0, S1 . ((member(S0, Q1) & member(S0, Q0) & committed(I0, T0)) -> (lte(log(S0, I0), T0) | (Q0 = Q1) | member(S1, Q0))))
@   323s  is global clause? No
@   323s  Learning in F[2]: (forall I0, T0, Q0, Q1, S0, S1 . ((member(S0, Q1) & member(S0, Q0) & committed(I0, T0)) -> (lte(log(S0, I0), T0) | (Q0 = Q1) | member(S1, Q0))))
@   323s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   323s  F[1] /\ T /\ C+ ?
@   323s  	Ans. UNSAT
@   324s  F[2] unsat core #5 	(ucsz: 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	~lte(t2, t1)
	committed(i2, t1)
	~member(s1, q0)
	(log(s0, i2) = t0)
	~indlte(i2, i2)
(clause)
	(~(log(s0, i2) = t0) | ~committed(i2, t1) | indlte(i2, i2) | lte(t2, t1) | member(s1, q0))
(relations)
	member
	indlte
	committed
	lte
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	~lte(TERM2, TERM1)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
(antecedent reduction)
@   325s  antecedent: 5 -> 4 (reduced)
	removed: TERM2

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM2, TERM1), committed(INDEX0, TERM1), ]
	TERM2 -> [ ~lte(TERM2, TERM1), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ ~lte(TERM2, V:term:e9:), committed(INDEX0, V:term:e9:), ]
	TERM2 -> [ ~lte(V:term:e9:, TERM1), ]
ucubes2qv #3
	~lte(V:term:e9:, TERM1) -> [ TERM2, ]
	(committed(INDEX0, V:term:e9:) & ~lte(TERM2, V:term:e9:)) -> [ TERM1, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { TERM2, | TERM1, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~lte(TERM2, TERM1)
	~(SERVER0 = SERVER1)
	~indlte(INDEX0, INDEX0)
	committed(INDEX0, TERM1)
	~member(SERVER1, QUORUM0)
	~(log(SERVER0, INDEX0) = TERM1)
(qvars eq: post)
	INDEX0
	TERM1
	TERM2
	QUORUM0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, TERM1, TERM2, QUORUM0, SERVER0, SERVER1 . (lte(TERM2, TERM1) | (SERVER0 = SERVER1) | indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM1) | member(SERVER1, QUORUM0) | (log(SERVER0, INDEX0) = TERM1)))
---------------------------
(original clause)
	(~(log(s0, i2) = t0) | ~committed(i2, t1) | indlte(i2, i2) | lte(t2, t1) | member(s1, q0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM1, TERM2, QUORUM0, SERVER0, SERVER1 . (lte(TERM2, TERM1) | (SERVER0 = SERVER1) | indlte(INDEX0, INDEX0) | ~committed(INDEX0, TERM1) | member(SERVER1, QUORUM0) | (log(SERVER0, INDEX0) = TERM1)))
---------------------------
(clause-type: univ)	(forall I0, T1, T2, Q0, S0, S1 . (committed(I0, T1) -> (lte(T2, T1) | (S0 = S1) | indlte(I0, I0) | member(S1, Q0) | (log(S0, I0) = T1))))
@   325s  is global clause? No
@   325s  Learning in F[2]: (forall I0, T1, T2, Q0, S0, S1 . (committed(I0, T1) -> (lte(T2, T1) | (S0 = S1) | indlte(I0, I0) | member(S1, Q0) | (log(S0, I0) = T1))))
@   325s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   325s  F[1] /\ T /\ C+ ?
@   325s  	Ans. UNSAT
@   325s  F[2] unsat core #7 	(ucsz: 25 -> 17 -> 11 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	(log(s2, i0) = t0)
	~succ(i1, i0)
	(loglen(s0) = i0)
	~succ(i2, i0)
	leader(s0)
	(log(s0, i0) = t2)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(log(s2, i0) = t0) | ~(loglen(s0) = i0) | ~leader(s0) | succ(i1, i0) | succ(i2, i0))
(relations)
	loglen
	succ
	log
	leader
	currentTerm
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	~succ(INDEX1, INDEX0)
	(log(SERVER0, INDEX0) = TERM2)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
	~succ(INDEX2, INDEX0)
(antecedent reduction)
@   326s  antecedent: 8 -> 6 (reduced)
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER1, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER1, INDEX0) = V:term:e9:), ]
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e9:), ]
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	(log(SERVER1, INDEX0) = V:term:e9:) -> [ TERM0, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM2, ]
	(currentTerm(SERVER0) = V:term:e9:) -> [ TERM1, ]
(partition) #3 term:e9: -> { TERM0, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ ~succ(INDEX2, INDEX0), ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ~succ(INDEX1, INDEX0), (log(SERVER0, INDEX0) = TERM2), ~succ(INDEX2, INDEX0), ]
	INDEX1 -> [ ~succ(INDEX1, INDEX0), ]
qv2ucubes #3
	INDEX2 -> [ ~succ(V:index:e9:, INDEX0), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER1, V:index:e9:) = TERM0), ~succ(INDEX1, V:index:e9:), ~succ(INDEX2, V:index:e9:), (log(SERVER0, V:index:e9:) = TERM2), ]
	INDEX1 -> [ ~succ(V:index:e9:, INDEX0), ]
ucubes2qv #2
	~succ(V:index:e9:, INDEX0) -> [ INDEX2, INDEX1, ]
	((log(SERVER0, V:index:e9:) = TERM2) & (log(SERVER1, V:index:e9:) = TERM0) & (loglen(SERVER0) = V:index:e9:) & ~succ(INDEX1, V:index:e9:) & ~succ(INDEX2, V:index:e9:)) -> [ INDEX0, ]
(partition) #2 index:e9: -> { INDEX2, INDEX1, | INDEX0, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	INDEX0:
		(log(SERVER0, INDEX0) = TERM2)
		(loglen(SERVER0) = INDEX0)
		~succ(INDEX1, INDEX0)
		(log(SERVER1, INDEX0) = TERM0)
		~succ(INDEX2, INDEX0)
ucmulti:
	~succ(INDEX1, INDEX0)
	(epr check: forward)	allowed(arc: index -> index)? False
	(epr check: reverse)	allowed(arc: index -> index)? False
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: server -> index)? True
(epr reduced)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0, TERM2 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX0) = TERM2) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1) | (TERM0 = TERM2) | (TERM1 = TERM2))))))
(non-epr version)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (forall TERM1, TERM0, INDEX0, TERM2 . (exists INDEX1 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX0) = TERM2) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1) | (TERM0 = TERM2) | (TERM1 = TERM2))))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0, TERM2 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX0) = TERM2) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1) | (TERM0 = TERM2) | (TERM1 = TERM2))))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(log(s2, i0) = t0) | ~(loglen(s0) = i0) | ~leader(s0) | succ(i1, i0) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0, TERM2 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX0) = TERM2) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1) | (TERM0 = TERM2) | (TERM1 = TERM2))))))
---------------------------
(clause-type: epr)	(forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0, T2 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T1) & (log(S0, I0) = T2) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> ((T0 = T1) | (T0 = T2) | (T1 = T2)))))))
@   326s  is global clause? No
@   326s  Learning in F[2]: (forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0, T2 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T1) & (log(S0, I0) = T2) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> ((T0 = T1) | (T0 = T2) | (T1 = T2)))))))
@   326s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   326s  F[1] /\ T /\ C+ ?
@   326s  	Ans. UNSAT
@   328s  F[2] unsat core #6 	(ucsz: 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	~succ(i1, i0)
	leader(s0)
	(termzero = t0)
	committed(i1, t0)
	(log(s0, i0) = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | ~leader(s0) | succ(i1, i0))
(relations)
	loglen
	termzero
	leader
	committed
	succ
	log
(cube: std)
	~succ(INDEX1, INDEX0)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
(antecedent reduction)
@   328s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	committed(INDEX1, termzero)
	(loglen(SERVER0) = INDEX0)
	~succ(INDEX1, INDEX0)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	INDEX0
	SERVER0
	INDEX1
(antecedent eq)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	committed(INDEX1, termzero)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(loglen(SERVER0) = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~leader(SERVER0) | ~committed(INDEX1, termzero) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0) | ~leader(s0) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~leader(SERVER0) | ~committed(INDEX1, termzero) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I1 . ((leader(S0) & committed(I1, termzero) & (log(S0, loglen(S0)) = termzero)) -> ((loglen(S0) = I1) | succ(I1, loglen(S0)))))
@   328s  is global clause? No
@   328s  Learning in F[2]: (forall S0, I1 . ((leader(S0) & committed(I1, termzero) & (log(S0, loglen(S0)) = termzero)) -> ((loglen(S0) = I1) | succ(I1, loglen(S0)))))
@   328s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   328s  F[1] /\ T /\ C+ ?
@   328s  	Ans. UNSAT
@   329s  F[2] unsat core #7 	(ucsz: 18 -> 11 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	(loglen(s0) = i1)
	(loglen(s1) = i0)
	(loglen(s2) = i0)
	leader(s0)
	(indzero = i0)
	(currentTerm(s0) = t1)
	(log(s0, i1) = t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~(loglen(s2) = i0) | ~leader(s0))
(relations)
	loglen
	indzero
	log
	leader
	currentTerm
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER0) = INDEX1)
	(loglen(SERVER1) = INDEX0)
	(currentTerm(SERVER0) = TERM1)
	(indzero = INDEX0)
(antecedent reduction)
@   329s  antecedent: 7 -> 6 (reduced)
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER2) = indzero)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX1)
	(loglen(SERVER1) = indzero)
	(currentTerm(SERVER0) = TERM1)
(qvars eq)
	SERVER2
	INDEX1
	TERM0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	server:e9:
	-> ~(SERVER1 = SERVER2)
	index:e9:
	-> ~(indzero = INDEX1)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = indzero), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX1) = TERM0), (loglen(SERVER0) = INDEX1), (currentTerm(SERVER0) = TERM1), ]
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = indzero), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM1), leader(V:server:e9:), (log(V:server:e9:, INDEX1) = TERM0), (loglen(V:server:e9:) = INDEX1), ]
	SERVER1 -> [ (loglen(V:server:e9:) = indzero), ]
ucubes2qv #2
	((currentTerm(V:server:e9:) = TERM1) & (log(V:server:e9:, INDEX1) = TERM0) & (loglen(V:server:e9:) = INDEX1) & leader(V:server:e9:)) -> [ SERVER0, ]
	(loglen(V:server:e9:) = indzero) -> [ SERVER2, SERVER1, ]
(partition) #2 server:e9: -> { SERVER0, | SERVER2, SERVER1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		leader(SERVER0)
		(currentTerm(SERVER0) = TERM1)
		(loglen(SERVER0) = INDEX1)
		(log(SERVER0, INDEX1) = TERM0)
ucmulti:
	(loglen(SERVER1) = indzero)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
(epr reduced)
	(exists SERVER1 . (forall SERVER0, TERM0, TERM1, INDEX1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = indzero)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX1) = TERM0) | ~(loglen(SERVER0) = INDEX1) | ~leader(SERVER0) | (TERM0 = TERM1) | (indzero = INDEX1))))
(non-epr version)
	(forall SERVER0, TERM0, TERM1, INDEX1 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = indzero)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX1) = TERM0) | ~(loglen(SERVER0) = INDEX1) | ~leader(SERVER0) | (TERM0 = TERM1) | (indzero = INDEX1))))
	Both verions not allowed!
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall SERVER0, TERM0, TERM1, INDEX1 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = indzero)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX1) = TERM0) | ~(loglen(SERVER0) = INDEX1) | ~leader(SERVER0) | (TERM0 = TERM1) | (indzero = INDEX1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(indzero = i0) | ~(log(s0, i1) = t0) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~(loglen(s2) = i0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, TERM0, TERM1, INDEX1 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = indzero)) | ~(currentTerm(SERVER0) = TERM1) | ~(log(SERVER0, INDEX1) = TERM0) | ~(loglen(SERVER0) = INDEX1) | ~leader(SERVER0) | (TERM0 = TERM1) | (indzero = INDEX1))))
---------------------------
(clause-type: non-epr)	(forall S0, T0, T1, I1 . (exists S1 . ((((S0 = S1) | (loglen(S1) = indzero)) & (currentTerm(S0) = T1) & (log(S0, I1) = T0) & (loglen(S0) = I1) & leader(S0)) -> ((T0 = T1) | (indzero = I1)))))
@   330s  is global clause? Yes
@   330s  Learning in F[2]: (forall S0, T0, T1, I1 . (exists S1 . ((((S0 = S1) | (loglen(S1) = indzero)) & (currentTerm(S0) = T1) & (log(S0, I1) = T0) & (loglen(S0) = I1) & leader(S0)) -> ((T0 = T1) | (indzero = I1)))))
@   330s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t2			--> modified
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1			--> modified
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   330s  F[1] /\ T /\ C+ ?
@   330s  	Ans. UNSAT
@   337s  F[2] unsat core #5 	(ucsz: 19 -> 13 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t1)
	indlt(i1, i0)
	~lte(t1, t2)
	(loglen(s0) = i1)
	committed(i0, t2)
(clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i1) | ~committed(i0, t2) | ~indlt(i1, i0) | lte(t1, t2))
(relations)
	loglen
	currentTerm
	lte
	indlt
	committed
(cube: std)
	(loglen(SERVER0) = INDEX1)
	(currentTerm(SERVER0) = TERM0)
	indlt(INDEX1, INDEX0)
	committed(INDEX0, TERM1)
	~lte(TERM0, TERM1)
(antecedent reduction)
@   373s  antecedent: 4 -> 0 (reduced)
	removed: TERM0
	removed: TERM1
	removed: INDEX0
	removed: INDEX1

(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~lte(currentTerm(SERVER0), TERM1)
	indlt(loglen(SERVER0), INDEX0)
	committed(INDEX0, TERM1)
(qvars eq: post)
	TERM1
	SERVER0
	INDEX0
(boosted clause)
	(forall TERM1, SERVER0, INDEX0 . (lte(currentTerm(SERVER0), TERM1) | ~indlt(loglen(SERVER0), INDEX0) | ~committed(INDEX0, TERM1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i1) | ~committed(i0, t2) | ~indlt(i1, i0) | lte(t1, t2))
(learnt sym-boosted clause)
	(forall TERM1, SERVER0, INDEX0 . (lte(currentTerm(SERVER0), TERM1) | ~indlt(loglen(SERVER0), INDEX0) | ~committed(INDEX0, TERM1)))
---------------------------
(clause-type: univ)	(forall T1, S0, I0 . ((indlt(loglen(S0), I0) & committed(I0, T1)) -> lte(currentTerm(S0), T1)))
@   373s  is global clause? No
@   373s  Learning in F[2]: (forall T1, S0, I0 . ((indlt(loglen(S0), I0) & committed(I0, T1)) -> lte(currentTerm(S0), T1)))
@   373s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	currentTerm(s2) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   374s  F[1] /\ T /\ C+ ?
@   374s  	Ans. UNSAT
@   374s  F[2] unsat core #5 	(ucsz: 15 -> 13 -> 11 -> 10 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s0, i2) = t1)
	~succ(i2, i0)
	(loglen(s0) = i0)
	(termzero = t0)
	committed(i2, t0)
(clause)
	(~(log(s0, i2) = t1) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i2, t0) | succ(i2, i0))
(relations)
	loglen
	termzero
	committed
	succ
	log
(cube: std)
	committed(INDEX1, TERM0)
	~succ(INDEX1, INDEX0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX1) = TERM1)
(antecedent reduction)
@   376s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, termzero)
	(loglen(SERVER0) = INDEX0)
	~succ(INDEX1, INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	INDEX1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	committed(INDEX1, termzero)
	~succ(INDEX1, loglen(SERVER0))
	~(loglen(SERVER0) = INDEX1)
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~committed(INDEX1, termzero) | succ(INDEX1, loglen(SERVER0)) | (loglen(SERVER0) = INDEX1) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i2) = t1) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i2, t0) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~committed(INDEX1, termzero) | succ(INDEX1, loglen(SERVER0)) | (loglen(SERVER0) = INDEX1) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, I1 . (committed(I1, termzero) -> (succ(I1, loglen(S0)) | (loglen(S0) = I1) | (termzero = log(S0, I1)))))
@   376s  is global clause? No
@   376s  Learning in F[2]: (forall S0, I1 . (committed(I1, termzero) -> (succ(I1, loglen(S0)) | (loglen(S0) = I1) | (termzero = log(S0, I1)))))
@   376s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@   377s  F[1] /\ T /\ C+ ?
@   377s  	Ans. UNSAT
@   379s  F[2] unsat core #6 	(ucsz: 16 -> 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i1)
	~leader(s1)
	(indzero = i1)
	~member(s2, q0)
	committed(i0, t0)
	~lte(t2, t0)
(clause)
	(~(indzero = i1) | ~(loglen(s0) = i1) | ~committed(i0, t0) | leader(s1) | lte(t2, t0) | member(s2, q0))
(relations)
	lte
	loglen
	leader
	indzero
	member
	committed
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(indzero = INDEX1)
	~leader(SERVER1)
	~member(SERVER2, QUORUM0)
	(loglen(SERVER0) = INDEX1)
	~lte(TERM1, TERM0)
	committed(INDEX0, TERM0)
(antecedent reduction)
@   384s  antecedent: 7 -> 3 (reduced)
	removed: INDEX0
	removed: INDEX1
	removed: TERM0
	removed: TERM1

(eq map)
	INDEX1 -> indzero
(cube eq)
	~lte(TERM1, TERM0)
	(loglen(SERVER0) = indzero)
	~leader(SERVER1)
	committed(INDEX0, TERM0)
	~member(SERVER2, QUORUM0)
(qvars eq)
	SERVER2
	INDEX0
	TERM0
	TERM1
	QUORUM0
	SERVER0
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ ~member(SERVER2, QUORUM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ ~member(V:server:e9:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e9:) = indzero), ]
	SERVER1 -> [ ~leader(V:server:e9:), ]
ucubes2qv #3
	~member(V:server:e9:, QUORUM0) -> [ SERVER2, ]
	~leader(V:server:e9:) -> [ SERVER1, ]
	(loglen(V:server:e9:) = indzero) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER1, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(boosted clause)
	(forall SERVER2, INDEX0, TERM0, TERM1, QUORUM0, SERVER0, SERVER1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX0, TERM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | leader(SERVER1) | lte(TERM1, TERM0) | member(SERVER2, QUORUM0)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(loglen(s0) = i1) | ~committed(i0, t0) | leader(s1) | lte(t2, t0) | member(s2, q0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX0, TERM0, TERM1, QUORUM0, SERVER0, SERVER1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX0, TERM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | leader(SERVER1) | lte(TERM1, TERM0) | member(SERVER2, QUORUM0)))
---------------------------
(clause-type: univ)	(forall S2, I0, T0, T1, Q0, S0, S1 . (((loglen(S0) = indzero) & committed(I0, T0)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | leader(S1) | lte(T1, T0) | member(S2, Q0))))
@   384s  is global clause? No
@   384s  Learning in F[2]: (forall S2, I0, T0, T1, Q0, S0, S1 . (((loglen(S0) = indzero) & committed(I0, T0)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | leader(S1) | lte(T1, T0) | member(S2, Q0))))
@   384s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2			--> modified
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true			--> modified
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   384s  F[1] /\ T /\ C+ ?
@   384s  	Ans. UNSAT
@   385s  F[2] unsat core #6 	(ucsz: 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~lte(t1, t2)
	member(s0, q0)
	member(s0, q1)
	committed(i1, t2)
	~member(s2, q0)
	(log(s0, i1) = t0)
(clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t1, t2) | member(s2, q0))
(relations)
	member
	committed
	lte
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	~member(SERVER1, QUORUM0)
	~lte(TERM1, TERM2)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX0, TERM2)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(antecedent reduction)
@   388s  antecedent: 7 -> 4 (reduced)
	removed: SERVER1
	removed: TERM1
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM1, TERM2), ]
	TERM2 -> [ ~lte(TERM1, TERM2), committed(INDEX0, TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ ~lte(V:term:e9:, TERM2), ]
	TERM2 -> [ committed(INDEX0, V:term:e9:), ~lte(TERM1, V:term:e9:), ]
ucubes2qv #3
	(committed(INDEX0, V:term:e9:) & ~lte(TERM1, V:term:e9:)) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
	~lte(V:term:e9:, TERM2) -> [ TERM1, ]
(partition) #3 term:e9: -> { TERM2, | TERM0, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	QUORUM0 -> [ ~member(SERVER1, QUORUM0), member(SERVER0, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ ~member(SERVER1, V:quorum:e9:), member(SERVER0, V:quorum:e9:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e9:), ]
ucubes2qv #2
	member(SERVER0, V:quorum:e9:) -> [ QUORUM1, ]
	(member(SERVER0, V:quorum:e9:) & ~member(SERVER1, V:quorum:e9:)) -> [ QUORUM0, ]
(partition) #2 quorum:e9: -> { QUORUM1, | QUORUM0, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
(cube eq: post)
	~lte(TERM1, TERM2)
	~(log(SERVER0, INDEX0) = TERM2)
	~(QUORUM0 = QUORUM1)
	~member(SERVER1, QUORUM0)
	committed(INDEX0, TERM2)
	member(SERVER0, QUORUM1)
	member(SERVER0, QUORUM0)
(qvars eq: post)
	INDEX0
	TERM1
	TERM2
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, TERM1, TERM2, QUORUM0, QUORUM1, SERVER0, SERVER1 . (lte(TERM1, TERM2) | (log(SERVER0, INDEX0) = TERM2) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM2) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0)))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~committed(i1, t2) | ~member(s0, q0) | ~member(s0, q1) | lte(t1, t2) | member(s2, q0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM1, TERM2, QUORUM0, QUORUM1, SERVER0, SERVER1 . (lte(TERM1, TERM2) | (log(SERVER0, INDEX0) = TERM2) | (QUORUM0 = QUORUM1) | member(SERVER1, QUORUM0) | ~committed(INDEX0, TERM2) | ~member(SERVER0, QUORUM1) | ~member(SERVER0, QUORUM0)))
---------------------------
(clause-type: univ)	(forall I0, T1, T2, Q0, Q1, S0, S1 . ((committed(I0, T2) & member(S0, Q1) & member(S0, Q0)) -> (lte(T1, T2) | (log(S0, I0) = T2) | (Q0 = Q1) | member(S1, Q0))))
@   388s  is global clause? No
@   388s  Learning in F[2]: (forall I0, T1, T2, Q0, Q1, S0, S1 . ((committed(I0, T2) & member(S0, Q1) & member(S0, Q0)) -> (lte(T1, T2) | (log(S0, I0) = T2) | (Q0 = Q1) | member(S1, Q0))))
@   388s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = true			--> modified
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   389s  F[1] /\ T /\ C+ ?
@   389s  	Ans. UNSAT
@   390s  F[2] unsat core #6 	(ucsz: 15 -> 13 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	~member(s1, q1)
	(currentTerm(s0) = t0)
	(loglen(s2) = i2)
	committed(i1, t2)
	(log(s1, i1) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~committed(i1, t2) | member(s1, q1))
(relations)
	loglen
	currentTerm
	log
	member
	committed
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	~member(SERVER1, QUORUM0)
	committed(INDEX1, TERM1)
	(loglen(SERVER2) = INDEX2)
(antecedent reduction)
@   395s  antecedent: 8 -> 8

qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX2), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ ~member(SERVER1, QUORUM0), (log(SERVER1, INDEX1) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX2), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM0), (loglen(V:server:e9:) = INDEX0), ]
	SERVER1 -> [ ~member(V:server:e9:, QUORUM0), (log(V:server:e9:, INDEX1) = TERM0), ]
ucubes2qv #3
	((log(V:server:e9:, INDEX1) = TERM0) & ~member(V:server:e9:, QUORUM0)) -> [ SERVER1, ]
	(loglen(V:server:e9:) = INDEX2) -> [ SERVER2, ]
	((currentTerm(V:server:e9:) = TERM0) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER2, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ (loglen(SERVER2) = INDEX2), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM1), (log(SERVER1, INDEX1) = TERM0), ]
qv2ucubes #3
	INDEX2 -> [ (loglen(SERVER2) = V:index:e9:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), ]
	INDEX1 -> [ committed(V:index:e9:, TERM1), (log(SERVER1, V:index:e9:) = TERM0), ]
ucubes2qv #3
	(loglen(SERVER0) = V:index:e9:) -> [ INDEX0, ]
	(loglen(SERVER2) = V:index:e9:) -> [ INDEX2, ]
	((log(SERVER1, V:index:e9:) = TERM0) & committed(V:index:e9:, TERM1)) -> [ INDEX1, ]
(partition) #3 index:e9: -> { INDEX0, | INDEX2, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER2)
	TERM0 -> log(SERVER1, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~(loglen(SERVER0) = loglen(SERVER2))
	~(log(SERVER1, INDEX1) = TERM1)
	~(INDEX1 = loglen(SERVER2))
	(currentTerm(SERVER0) = log(SERVER1, INDEX1))
	~(loglen(SERVER0) = INDEX1)
	~member(SERVER1, QUORUM0)
	committed(INDEX1, TERM1)
(qvars eq: post)
	SERVER2
	INDEX1
	TERM1
	QUORUM0
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, TERM1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (loglen(SERVER0) = loglen(SERVER2)) | (log(SERVER1, INDEX1) = TERM1) | (INDEX1 = loglen(SERVER2)) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX1)) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | ~committed(INDEX1, TERM1)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~committed(i1, t2) | member(s1, q1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, TERM1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (loglen(SERVER0) = loglen(SERVER2)) | (log(SERVER1, INDEX1) = TERM1) | (INDEX1 = loglen(SERVER2)) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX1)) | (loglen(SERVER0) = INDEX1) | member(SERVER1, QUORUM0) | ~committed(INDEX1, TERM1)))
---------------------------
(clause-type: univ)	(forall S2, I1, T1, Q0, S0, S1 . (((currentTerm(S0) = log(S1, I1)) & committed(I1, T1)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (loglen(S0) = loglen(S2)) | (log(S1, I1) = T1) | (I1 = loglen(S2)) | (loglen(S0) = I1) | member(S1, Q0))))
@   395s  is global clause? No
@   395s  Learning in F[2]: (forall S2, I1, T1, Q0, S0, S1 . (((currentTerm(S0) = log(S1, I1)) & committed(I1, T1)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (loglen(S0) = loglen(S2)) | (log(S1, I1) = T1) | (I1 = loglen(S2)) | (loglen(S0) = I1) | member(S1, Q0))))
@   395s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   396s  F[1] /\ T /\ C+ ?
@   396s  	Ans. UNSAT
@   396s  F[2] unsat core #7 	(ucsz: 14 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	~succ(i1, i0)
	(loglen(s0) = i0)
	~succ(i2, i0)
	leader(s0)
	(log(s0, i0) = t2)
	(currentTerm(s0) = t1)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | succ(i1, i0) | succ(i2, i0))
(relations)
	loglen
	succ
	log
	leader
	currentTerm
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	~succ(INDEX1, INDEX0)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	(currentTerm(SERVER0) = TERM0)
	~succ(INDEX2, INDEX0)
(antecedent reduction)
@   397s  antecedent: 7 -> 5 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX2 -> [ ~succ(INDEX2, INDEX0), ]
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM1), (loglen(SERVER0) = INDEX0), ~succ(INDEX1, INDEX0), (log(SERVER1, INDEX0) = TERM0), ~succ(INDEX2, INDEX0), ]
	INDEX1 -> [ ~succ(INDEX1, INDEX0), ]
qv2ucubes #3
	INDEX2 -> [ ~succ(V:index:e9:, INDEX0), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER0, V:index:e9:) = TERM1), (log(SERVER1, V:index:e9:) = TERM0), ~succ(INDEX1, V:index:e9:), ~succ(INDEX2, V:index:e9:), ]
	INDEX1 -> [ ~succ(V:index:e9:, INDEX0), ]
ucubes2qv #2
	((log(SERVER0, V:index:e9:) = TERM1) & (log(SERVER1, V:index:e9:) = TERM0) & (loglen(SERVER0) = V:index:e9:) & ~succ(INDEX1, V:index:e9:) & ~succ(INDEX2, V:index:e9:)) -> [ INDEX0, ]
	~succ(V:index:e9:, INDEX0) -> [ INDEX2, INDEX1, ]
(partition) #2 index:e9: -> { INDEX0, | INDEX2, INDEX1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	INDEX0:
		(log(SERVER0, INDEX0) = TERM1)
		(loglen(SERVER0) = INDEX0)
		~succ(INDEX1, INDEX0)
		(log(SERVER1, INDEX0) = TERM0)
		~succ(INDEX2, INDEX0)
ucmulti:
	~succ(INDEX1, INDEX0)
	(epr check: forward)	allowed(arc: index -> index)? False
	(epr check: reverse)	allowed(arc: index -> index)? False
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: server -> index)? True
(epr reduced)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER0, INDEX0) = TERM1) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1))))))
(non-epr version)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (forall TERM1, TERM0, INDEX0 . (exists INDEX1 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER0, INDEX0) = TERM1) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1))))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER0, INDEX0) = TERM1) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1))))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t2) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0) | succ(i1, i0) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (exists INDEX1 . (forall TERM1, TERM0, INDEX0 . ((~(INDEX0 = INDEX1) & succ(INDEX1, INDEX0)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER0, INDEX0) = TERM1) | ~(log(SERVER1, INDEX0) = TERM0) | ~(loglen(SERVER0) = INDEX0) | (TERM0 = TERM1))))))
---------------------------
(clause-type: epr)	(forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T0) & (log(S0, I0) = T1) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> (T0 = T1))))))
@   397s  is global clause? No
@   397s  Learning in F[2]: (forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T0) & (log(S0, I0) = T1) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> (T0 = T1))))))
@   397s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   401s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e10 with value True
	inputs:
actionName ext:getEntries
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:j:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
@   401s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2			--> modified
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   401s  F[0] /\ T /\ C+ ?
@   401s  	Ans. UNSAT
@   401s  F[1] unsat core #2 	(ucsz: 3 -> 2 -> 2)
(minimal unsat core)
	(termzero = t0)
	(log(s2, i0) = t1)
(clause)
	(~(log(s2, i0) = t1) | ~(termzero = t0))
(relations)
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(termzero = TERM0)
(antecedent reduction)
@   401s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(termzero = log(SERVER0, INDEX0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(original clause)
	(~(log(s2, i0) = t1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (termzero = log(SERVER0, INDEX0)))
---------------------------
(clause-type: univ)	(forall S0, I0 . (termzero = log(S0, I0)))
@   401s  is global clause? No
@   401s  Learning in F[1]: (forall S0, I0 . (termzero = log(S0, I0)))
@   401s  F[1] /\ T /\ C+ ?
@   401s  	Ans. UNSAT
@   401s  F[2] unsat core #4 	(ucsz: 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	leader(s0)
	(loglen(s0) = i0)
	(log(s2, i0) = t1)
	(termzero = t0)
(clause)
	(~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~leader(s0))
(relations)
	loglen
	log
	leader
	termzero
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@   402s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	SERVER1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~(termzero = log(SERVER1, loglen(SERVER0)))
	~(SERVER0 = SERVER1)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (termzero = log(SERVER1, loglen(SERVER0))) | (SERVER0 = SERVER1)))
---------------------------
(original clause)
	(~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (termzero = log(SERVER1, loglen(SERVER0))) | (SERVER0 = SERVER1)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (leader(S0) -> ((termzero = log(S1, loglen(S0))) | (S0 = S1))))
@   402s  is global clause? No
@   402s  Learning in F[2]: (forall S0, S1 . (leader(S0) -> ((termzero = log(S1, loglen(S0))) | (S0 = S1))))
@   402s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	currentTerm(s2) = t1			--> modified
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   403s  F[1] /\ T /\ C+ ?
@   403s  	Ans. UNSAT
@   403s  F[2] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	(log(s0, i1) = t2)
	(loglen(s0) = i0)
	(termzero = t0)
(clause)
	(~(log(s0, i1) = t2) | ~(loglen(s0) = i0) | ~(termzero = t0))
(relations)
	loglen
	log
	termzero
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX1) = TERM1)
(antecedent reduction)
@   403s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	INDEX1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER0, INDEX1)
(cube eq: post)
	~(loglen(SERVER0) = INDEX1)
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . ((loglen(SERVER0) = INDEX1) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t2) | ~(loglen(s0) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . ((loglen(SERVER0) = INDEX1) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, I1 . ((loglen(S0) = I1) | (termzero = log(S0, I1))))
@   403s  is global clause? No
@   403s  Learning in F[2]: (forall S0, I1 . ((loglen(S0) = I1) | (termzero = log(S0, I1))))
@   403s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false			--> modified
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   404s  F[1] /\ T /\ C+ ?
@   404s  	Ans. UNSAT
@   404s  F[2] unsat core #3 	(ucsz: 3 -> 3)
(minimal unsat core)
	(currentTerm(s0) = t1)
	(log(s0, i1) = t2)
	(termzero = t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(relations)
	currentTerm
	termzero
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(currentTerm(SERVER0) = TERM1)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM2)
(antecedent reduction)
@   404s  antecedent: 3 -> 3

(eq map)
	TERM0 -> termzero
(cube eq)
	(currentTerm(SERVER0) = TERM1)
	(log(SERVER0, INDEX0) = TERM2)
(qvars eq)
	SERVER0
	TERM1
	TERM2
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e9: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (currentTerm(SERVER0) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM2, ]
	(currentTerm(SERVER0) = V:term:e9:) -> [ TERM1, ]
(partition) #3 term:e9: -> { termzero, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER0)
	TERM2 -> log(SERVER0, INDEX0)
(cube eq: post)
	~(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~(termzero = log(SERVER0, INDEX0))
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . ((currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . ((currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0 . ((currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0))))
@   404s  is global clause? No
@   404s  Learning in F[2]: (forall S0, I0 . ((currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0))))
@   404s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[2])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	currentTerm(s2) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = true			--> modified
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@   406s  F[1] /\ T /\ C+ ?
@   406s  	Ans. UNSAT
@   407s  F[2] unsat core #5 	(ucsz: 15 -> 11 -> 11 -> 9 -> 8 -> 7 -> 5 -> 5)
(minimal unsat core)
	committed(i0, t0)
	(loglen(s2) = i1)
	~succ(i0, i1)
	~leader(s0)
	(termzero = t1)
(clause)
	(~(loglen(s2) = i1) | ~(termzero = t1) | ~committed(i0, t0) | leader(s0) | succ(i0, i1))
(relations)
	loglen
	leader
	termzero
	succ
	committed
(cube: std)
	(termzero = TERM1)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX0, TERM0)
	~leader(SERVER0)
	~succ(INDEX0, INDEX1)
(antecedent reduction)
@   409s  antecedent: 6 -> 6

(eq map)
	TERM1 -> termzero
(cube eq)
	(loglen(SERVER1) = INDEX1)
	committed(INDEX0, TERM0)
	~leader(SERVER0)
	~succ(INDEX0, INDEX1)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(INDEX0 = loglen(SERVER1))
	~succ(INDEX0, loglen(SERVER1))
	~leader(SERVER0)
	committed(INDEX0, TERM0)
	~(TERM0 = termzero)
(qvars eq: post)
	SERVER0
	TERM0
	INDEX0
	SERVER1
(boosted clause)
	(forall SERVER0, TERM0, INDEX0, SERVER1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | succ(INDEX0, loglen(SERVER1)) | leader(SERVER0) | ~committed(INDEX0, TERM0) | (TERM0 = termzero)))
---------------------------
(original clause)
	(~(loglen(s2) = i1) | ~(termzero = t1) | ~committed(i0, t0) | leader(s0) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER0, TERM0, INDEX0, SERVER1 . ((SERVER0 = SERVER1) | (INDEX0 = loglen(SERVER1)) | succ(INDEX0, loglen(SERVER1)) | leader(SERVER0) | ~committed(INDEX0, TERM0) | (TERM0 = termzero)))
---------------------------
(clause-type: univ)	(forall S0, T0, I0, S1 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | succ(I0, loglen(S1)) | leader(S0) | (T0 = termzero))))
@   409s  is global clause? No
@   409s  Learning in F[2]: (forall S0, T0, I0, S1 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | succ(I0, loglen(S1)) | leader(S0) | (T0 = termzero))))
@   409s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2			--> modified
	currentTerm(s2) = t2			--> modified
	leader(s0) = true
	leader(s1) = true			--> modified
	leader(s2) = true			--> modified
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@   412s  F[1] /\ T /\ C+ ?
@   412s  	Ans. UNSAT
@   414s  F[2] unsat core #4 	(ucsz: 21 -> 13 -> 12 -> 9 -> 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	leader(s0)
	committed(i2, t2)
	(loglen(s0) = i1)
	~succ(i2, i1)
(clause)
	(~(loglen(s0) = i1) | ~committed(i2, t2) | ~leader(s0) | succ(i2, i1))
(relations)
	loglen
	committed
	leader
	succ
(cube: std)
	leader(SERVER0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~succ(INDEX1, INDEX0)
(antecedent reduction)
@   417s  antecedent: 2 -> 2

(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	committed(INDEX1, TERM0)
	~(loglen(SERVER0) = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
(qvars eq: post)
	SERVER0
	TERM0
	INDEX1
(boosted clause)
	(forall SERVER0, TERM0, INDEX1 . (~leader(SERVER0) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i1) | ~committed(i2, t2) | ~leader(s0) | succ(i2, i1))
(learnt sym-boosted clause)
	(forall SERVER0, TERM0, INDEX1 . (~leader(SERVER0) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, T0, I1 . ((leader(S0) & committed(I1, T0)) -> ((loglen(S0) = I1) | succ(I1, loglen(S0)))))
@   417s  is global clause? No
@   417s  Learning in F[2]: (forall S0, T0, I1 . ((leader(S0) & committed(I1, T0)) -> ((loglen(S0) = I1) | succ(I1, loglen(S0)))))
@   417s  F[2] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[2])
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0			--> modified
	currentTerm(s2) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = true			--> modified
	leader(s2) = true			--> modified
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@   419s  F[1] /\ T /\ C+ ?
@   419s  	Ans. UNSAT
@   421s  F[2] unsat core #3 	(ucsz: 18 -> 14 -> 13 -> 11 -> 10 -> 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 3)
(minimal unsat core)
	(indzero = i2)
	committed(i0, t0)
	(loglen(s0) = i2)
(clause)
	(~(indzero = i2) | ~(loglen(s0) = i2) | ~committed(i0, t0))
(relations)
	loglen
	indzero
	committed
(cube: std)
	(loglen(SERVER0) = INDEX1)
	committed(INDEX0, TERM0)
	(indzero = INDEX1)
(antecedent reduction)
@   422s  antecedent: 2 -> 0 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER0) = indzero)
	committed(INDEX0, TERM0)
(qvars eq)
	INDEX0
	TERM0
	SERVER0
(antecedent eq)
(boosted clause)
	(forall INDEX0, TERM0, SERVER0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX0, TERM0)))
---------------------------
(original clause)
	(~(indzero = i2) | ~(loglen(s0) = i2) | ~committed(i0, t0))
(learnt sym-boosted clause)
	(forall INDEX0, TERM0, SERVER0 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX0, TERM0)))
---------------------------
(clause-type: univ)	(forall I0, T0, S0 . ((loglen(S0) = indzero) -> ~committed(I0, T0)))
@   422s  is global clause? No
@   422s  Learning in F[2]: (forall I0, T0, S0 . ((loglen(S0) = indzero) -> ~committed(I0, T0)))
@   422s  F[2] /\ T /\ !P+ -> UNSAT
Frames: #3
	F[0]: #1
		((forall S10 . ~leader(S10)) & (forall S10 . (currentTerm(S10) = termzero)) & (forall S10 . (loglen(S10) = indzero)) & (forall S10, I10_1 . (log(S10, I10_1) = termzero)) & (forall I10, T10 . ~committed(I10, T10)))
	F[1]: #9
		(forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
		(forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
		(forall S1, T0, I0, S0 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | leader(S0) | succ(I0, loglen(S1)))))
		(forall Q0, S0, S1, I0, T1 . (committed(I0, T1) -> (member(S0, Q0) | succ(I0, loglen(S1)) | (I0 = loglen(S1)) | (S0 = S1) | (currentTerm(S1) = T1))))
		(forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
		(forall S0, I0 . (termzero = log(S0, I0)))
		(forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
		(forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
		(forall S0, S1 . ((leader(S1) & indlt(loglen(S0), loglen(S1))) -> (log(S1, loglen(S1)) = currentTerm(S1))))
	F[2]: #25
		(forall S0, S1 . (((log(S0, loglen(S0)) = log(S1, loglen(S1))) & leader(S1) & indlt(loglen(S0), loglen(S1))) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S1, loglen(S1)) = log(S1, loglen(S0))) | (currentTerm(S1) = log(S1, loglen(S0))))))
		(forall T1, S0, I0 . ((indlt(loglen(S0), I0) & committed(I0, T1)) -> lte(currentTerm(S0), T1)))
		(forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0, T2 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T1) & (log(S0, I0) = T2) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> ((T0 = T1) | (T0 = T2) | (T1 = T2)))))))
		(forall S0, S1 . (leader(S0) -> (exists I1 . (forall T1, T0, I0 . (((succ(I1, I0) -> (I0 = I1)) & (currentTerm(S0) = T0) & (log(S0, I0) = T1) & (log(S1, I0) = T0) & (loglen(S0) = I0)) -> (T0 = T1))))))
		(forall S0, T0, T1, I1 . (exists S1 . ((((S0 = S1) | (loglen(S1) = indzero)) & (currentTerm(S0) = T1) & (log(S0, I1) = T0) & (loglen(S0) = I1) & leader(S0)) -> ((T0 = T1) | (indzero = I1)))))
		(forall S2, S0, S1 . ((leader(S0) & indlt(loglen(S2), loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0)))) -> ((S1 = S2) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall S0, T0, I1 . ((leader(S0) & committed(I1, T0)) -> ((loglen(S0) = I1) | succ(I1, loglen(S0)))))
		(forall S0, I0 . ((currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0)) | (termzero = currentTerm(S0))))
		(forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
		(forall S0, I1 . ((loglen(S0) = I1) | (termzero = log(S0, I1))))
		(forall S0, S1 . (((loglen(S1) = loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0))) & leader(S0) & leader(S1)) -> ((log(S0, loglen(S0)) = currentTerm(S1)) | (log(S1, loglen(S0)) = currentTerm(S1)) | (log(S0, loglen(S0)) = log(S1, loglen(S0))))))
		(forall S2, S0, S1 . (((loglen(S0) = loglen(S2)) & (currentTerm(S0) = log(S1, loglen(S2))) & leader(S2) & leader(S0) & (currentTerm(S2) = log(S1, loglen(S2)))) -> ((log(S1, loglen(S2)) = log(S0, loglen(S2))) | (S0 = S2) | (S1 = S2) | (S0 = S1))))
		(forall S2, I1, T1, Q0, S0, S1 . (((currentTerm(S0) = log(S1, I1)) & committed(I1, T1)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (loglen(S0) = loglen(S2)) | (log(S1, I1) = T1) | (I1 = loglen(S2)) | (loglen(S0) = I1) | member(S1, Q0))))
		(forall S0, S1 . (leader(S0) -> ((termzero = log(S1, loglen(S0))) | (S0 = S1))))
		(forall I0, T1, T2, Q0, S0, S1 . (committed(I0, T1) -> (lte(T2, T1) | (S0 = S1) | indlte(I0, I0) | member(S1, Q0) | (log(S0, I0) = T1))))
		(forall I0, T1, T2, Q0, Q1, S0, S1 . ((committed(I0, T2) & member(S0, Q1) & member(S0, Q0)) -> (lte(T1, T2) | (log(S0, I0) = T2) | (Q0 = Q1) | member(S1, Q0))))
		(forall T0 . ~committed(indzero, T0))
		(forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
		(forall S0, S1 . ((leader(S0) & (log(S1, indzero) = log(S0, loglen(S0))) & (loglen(S1) = indzero)) -> (succ(indzero, loglen(S0)) | (loglen(S0) = indzero))))
		(forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
		(forall S0 . (log(S0, indzero) = termzero))
		(forall I0, T0, S0 . ((loglen(S0) = indzero) -> ~committed(I0, T0)))
		(forall S0, T0, I0, S1 . (committed(I0, T0) -> ((S0 = S1) | (I0 = loglen(S1)) | succ(I0, loglen(S1)) | leader(S0) | (T0 = termzero))))
		(exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
		(forall S2, I1, T2, S0, S1 . (((log(S1, I1) = log(S2, loglen(S0))) & (currentTerm(S0) = log(S2, loglen(S0))) & leader(S0)) -> (lte(T2, log(S2, loglen(S0))) | (S1 = S2) | leader(S1) | (log(S0, loglen(S0)) = log(S2, loglen(S0))))))
@   422s  
Adding frame 3...
Trying forwarding F[1]
Forwarded #5 to F[2]
@   424s  Learning in F[2]: (forall S0, S1, I2, T0 . (committed(I2, T0) -> ((loglen(S1) = loglen(S0)) | (loglen(S0) = I2) | succ(I2, loglen(S0)) | (loglen(S1) = I2) | (T0 = log(S1, loglen(S1))))))
@   424s  Learning in F[2]: (forall T2, Q0, S0, S1, I0, T1 . (committed(I0, T1) -> ((S0 = S1) | lte(T2, T1) | (log(S0, I0) = T1) | member(S1, Q0))))
@   424s  Learning in F[2]: (forall T2, S0, S1, I1 . ((loglen(S1) = indzero) -> (lte(T2, log(S0, I1)) | leader(S0) | (log(S0, I1) = log(S1, indzero)))))
@   424s  Learning in F[2]: (forall S0, S1 . (leader(S1) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S0, loglen(S1)) = log(S1, loglen(S1))) | (log(S0, loglen(S1)) = currentTerm(S1)))))
@   424s  Learning in F[2]: (forall S0, S1 . (((currentTerm(S0) = log(S1, loglen(S0))) & leader(S0)) -> (log(S1, loglen(S0)) = log(S0, loglen(S0)))))
Trying forwarding F[2]
Forwarded #9 to F[3]
@  1318s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@  1318s  Learning in F[3]: (forall S2, I1, T1, Q0, S0, S1 . (((currentTerm(S0) = log(S1, I1)) & committed(I1, T1)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (loglen(S0) = loglen(S2)) | (log(S1, I1) = T1) | (I1 = loglen(S2)) | (loglen(S0) = I1) | member(S1, Q0))))
@  1318s  Learning in F[3]: (forall S0, T0, T1, I1 . (exists S1 . ((((S0 = S1) | (loglen(S1) = indzero)) & (currentTerm(S0) = T1) & (log(S0, I1) = T0) & (loglen(S0) = I1) & leader(S0)) -> ((T0 = T1) | (indzero = I1)))))
@  1318s  Learning in F[3]: (forall I1, T0, I0 . (exists S0 . (((loglen(S0) = I0) & committed(I1, T0)) -> ((I0 = I1) | succ(I1, I0)))))
@  1318s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@  1318s  Learning in F[3]: (forall S0, S1 . (((log(S0, loglen(S0)) = log(S1, loglen(S1))) & leader(S1) & indlt(loglen(S0), loglen(S1))) -> ((log(S1, loglen(S1)) = currentTerm(S1)) | (log(S1, loglen(S1)) = log(S1, loglen(S0))) | (currentTerm(S1) = log(S1, loglen(S0))))))
@  1318s  Learning in F[3]: (forall I1, T1, S0 . (((log(S0, I1) = currentTerm(S0)) & (loglen(S0) = indzero) & leader(S0)) -> lte(T1, currentTerm(S0))))
@  1318s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@  1318s  Learning in F[3]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@  1318s  Learning in F[3]: (forall S0 . (log(S0, indzero) = termzero))
@  1318s  Learning in F[3]: (forall T0 . ~committed(indzero, T0))
@  1318s  Learning in F[3]: (forall S0, T0, T1, I1 . (exists S1 . ((((S0 = S1) | (loglen(S1) = indzero)) & (currentTerm(S0) = T1) & (log(S0, I1) = T0) & (loglen(S0) = I1) & leader(S0)) -> ((T0 = T1) | (indzero = I1)))))
@  1318s  Learning in F[3]: (exists Q0 . (forall S1, T0, T1, S0 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & member(S0, Q0)) -> lte(T1, T0))))
@  1318s  Learning in F[3]: (forall S0 . (leader(S0) -> ~(currentTerm(S0) = termzero)))
@  1318s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  1318s  F[2] /\ T /\ C+ ?
@  1318s  	Ans. UNSAT
@  1319s  F[3] unsat core #5 	(ucsz: 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s2) = i2)
	(log(s0, i2) = t0)
	(log(s2, i0) = t1)
	(loglen(s0) = i0)
	(termzero = t2)
(clause)
	(~(log(s0, i2) = t0) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~(termzero = t2))
(relations)
	loglen
	log
	termzero
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	(termzero = TERM2)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@  1319s  antecedent: 7 -> 5 (reduced)
	removed: SERVER1
	removed: SERVER0

(eq map)
	TERM2 -> termzero
(cube eq)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	-> ~(TERM0 = termzero)
	-> ~(TERM1 = termzero)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	term:e9: -> [ TERM0, TERM1, termzero, ]
qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX1) = TERM0), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = TERM1), ]
	termzero -> [ ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX1) = V:term:e9:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e9:), ]
	termzero -> [ ]
ucubes2qv #3
	true -> [ termzero, ]
	(log(SERVER1, INDEX0) = V:term:e9:) -> [ TERM1, ]
	(log(SERVER0, INDEX1) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { termzero, | TERM1, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER1))
	INDEX0 -> loglen(SERVER0)
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	~(log(SERVER0, loglen(SERVER1)) = termzero)
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0)))
	~(loglen(SERVER0) = loglen(SERVER1))
	~(log(SERVER1, loglen(SERVER0)) = termzero)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = termzero) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | (loglen(SERVER0) = loglen(SERVER1)) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i2) = t0) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i2) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((log(SERVER0, loglen(SERVER1)) = termzero) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, loglen(SERVER0))) | (loglen(SERVER0) = loglen(SERVER1)) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((log(S0, loglen(S1)) = termzero) | (log(S0, loglen(S1)) = log(S1, loglen(S0))) | (loglen(S0) = loglen(S1)) | (log(S1, loglen(S0)) = termzero)))
@  1319s  is global clause? No
@  1319s  Learning in F[3]: (forall S0, S1 . ((log(S0, loglen(S1)) = termzero) | (log(S0, loglen(S1)) = log(S1, loglen(S0))) | (loglen(S0) = loglen(S1)) | (log(S1, loglen(S0)) = termzero)))
@  1319s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  1319s  F[2] /\ T /\ C+ ?
@  1319s  	Ans. UNSAT
@  1319s  F[3] unsat core #5 	(ucsz: 12 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	(currentTerm(s0) = t0)
	(log(s0, i1) = t0)
	(loglen(s0) = i0)
	(log(s2, i1) = t0)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~leader(s0))
(relations)
	loglen
	log
	leader
	currentTerm
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER1, INDEX1) = TERM0)
(antecedent reduction)
@  1320s  antecedent: 4 -> 4

(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX1) = log(SERVER0, INDEX1))
	(currentTerm(SERVER0) = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~leader(SERVER0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER1, INDEX1) = log(SERVER0, INDEX1)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s0, i1) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~leader(SERVER0) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER1, INDEX1) = log(SERVER0, INDEX1)) | ~(currentTerm(SERVER0) = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((leader(S0) & (log(S1, I1) = log(S0, I1)) & (currentTerm(S0) = log(S0, I1))) -> ((S0 = S1) | (loglen(S0) = I1))))
@  1320s  is global clause? No
@  1320s  Learning in F[3]: (forall S0, S1, I1 . ((leader(S0) & (log(S1, I1) = log(S0, I1)) & (currentTerm(S0) = log(S0, I1))) -> ((S0 = S1) | (loglen(S0) = I1))))
@  1320s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  1320s  F[2] /\ T /\ C+ ?
@  1320s  	Ans. UNSAT
@  1320s  F[3] unsat core #4 	(ucsz: 10 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s2, i0) = t0)
	(log(s2, i1) = t2)
	(loglen(s2) = i1)
	(termzero = t2)
(clause)
	(~(log(s2, i0) = t0) | ~(log(s2, i1) = t2) | ~(loglen(s2) = i1) | ~(termzero = t2))
(relations)
	loglen
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = TERM1)
(antecedent reduction)
@  1320s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = termzero)
(qvars eq)
	SERVER0
	TERM0
	INDEX1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX0)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(log(SERVER0, INDEX0) = termzero)
(qvars eq: post)
	INDEX0
	SERVER0
(boosted clause)
	(forall INDEX0, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(log(s2, i0) = t0) | ~(log(s2, i1) = t2) | ~(loglen(s2) = i1) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (log(SERVER0, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall I0, S0 . ((log(S0, loglen(S0)) = termzero) -> (log(S0, I0) = termzero)))
@  1320s  is global clause? No
@  1320s  Learning in F[3]: (forall I0, S0 . ((log(S0, loglen(S0)) = termzero) -> (log(S0, I0) = termzero)))
@  1320s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t0
	currentTerm(s2) = t0			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  1320s  F[2] /\ T /\ C+ ?
@  1321s  	Ans. UNSAT
@  1321s  F[3] unsat core #4 	(ucsz: 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(indzero = i0)
	committed(i1, t0)
	(loglen(s2) = i0)
	~indlte(i1, i1)
(clause)
	(~(indzero = i0) | ~(loglen(s2) = i0) | ~committed(i1, t0) | indlte(i1, i1))
(relations)
	loglen
	indlte
	indzero
	committed
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
	~indlte(INDEX1, INDEX1)
(antecedent reduction)
@  1322s  antecedent: 2 -> 0 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
	~indlte(INDEX1, INDEX1)
(qvars eq)
	TERM0
	SERVER0
	INDEX1
(antecedent eq)
(boosted clause)
	(forall TERM0, SERVER0, INDEX1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | indlte(INDEX1, INDEX1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s2) = i0) | ~committed(i1, t0) | indlte(i1, i1))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, INDEX1 . (~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0) | indlte(INDEX1, INDEX1)))
---------------------------
(clause-type: univ)	(forall T0, S0, I1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> indlte(I1, I1)))
@  1322s  is global clause? Yes
@  1322s  Learning in F[3]: (forall T0, S0, I1 . (((loglen(S0) = indzero) & committed(I1, T0)) -> indlte(I1, I1)))
@  1322s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  1322s  F[2] /\ T /\ C+ ?
@  1923s  	Ans. UNSAT
@  1924s  F[3] unsat core #5 	(ucsz: 12 -> 8 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i2, t1)
	~lte(t0, t1)
	~member(s2, q0)
	(log(s1, i2) = t0)
	leader(s0)
(clause)
	(~(log(s1, i2) = t0) | ~committed(i2, t1) | ~leader(s0) | lte(t0, t1) | member(s2, q0))
(relations)
	member
	committed
	lte
	leader
	log
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	leader(SERVER0)
	~lte(TERM0, TERM1)
	committed(INDEX0, TERM1)
	(log(SERVER1, INDEX0) = TERM0)
	~member(SERVER2, QUORUM0)
(antecedent reduction)
@  1925s  antecedent: 5 -> 2 (reduced)
	removed: TERM0
	removed: TERM1
	removed: SERVER0

qv2cubes #3
	SERVER2 -> [ ~member(SERVER2, QUORUM0), ]
	SERVER0 -> [ leader(SERVER0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ ~member(V:server:e9:, QUORUM0), ]
	SERVER0 -> [ leader(V:server:e9:), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = TERM0), ]
ucubes2qv #3
	~member(V:server:e9:, QUORUM0) -> [ SERVER2, ]
	leader(V:server:e9:) -> [ SERVER0, ]
	(log(V:server:e9:, INDEX0) = TERM0) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER1, INDEX0)
(cube eq: post)
	leader(SERVER0)
	committed(INDEX0, TERM1)
	~(SERVER1 = SERVER2)
	~lte(log(SERVER1, INDEX0), TERM1)
	~member(SERVER2, QUORUM0)
(qvars eq: post)
	SERVER2
	INDEX0
	TERM1
	QUORUM0
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX0, TERM1, QUORUM0, SERVER0, SERVER1 . (~leader(SERVER0) | ~committed(INDEX0, TERM1) | (SERVER1 = SERVER2) | lte(log(SERVER1, INDEX0), TERM1) | member(SERVER2, QUORUM0)))
---------------------------
(original clause)
	(~(log(s1, i2) = t0) | ~committed(i2, t1) | ~leader(s0) | lte(t0, t1) | member(s2, q0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX0, TERM1, QUORUM0, SERVER0, SERVER1 . (~leader(SERVER0) | ~committed(INDEX0, TERM1) | (SERVER1 = SERVER2) | lte(log(SERVER1, INDEX0), TERM1) | member(SERVER2, QUORUM0)))
---------------------------
(clause-type: univ)	(forall S2, I0, T1, Q0, S0, S1 . ((leader(S0) & committed(I0, T1)) -> ((S1 = S2) | lte(log(S1, I0), T1) | member(S2, Q0))))
@  1925s  is global clause? No
@  1925s  Learning in F[3]: (forall S2, I0, T1, Q0, S0, S1 . ((leader(S0) & committed(I0, T1)) -> ((S1 = S2) | lte(log(S1, I0), T1) | member(S2, Q0))))
@  1925s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  1925s  F[2] /\ T /\ C+ ?
@  1925s  	Ans. UNSAT
@  1927s  F[3] unsat core #5 	(ucsz: 15 -> 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	committed(i2, t1)
	~succ(i2, i0)
	~indlte(i2, i2)
	(loglen(s0) = i0)
	leader(s0)
(clause)
	(~(loglen(s0) = i0) | ~committed(i2, t1) | ~leader(s0) | indlte(i2, i2) | succ(i2, i0))
(relations)
	loglen
	indlte
	committed
	leader
	succ
(cube: std)
	leader(SERVER0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	~succ(INDEX1, INDEX0)
	~indlte(INDEX1, INDEX1)
(antecedent reduction)
@  1928s  antecedent: 2 -> 2

(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~indlte(INDEX1, INDEX1)
	committed(INDEX1, TERM0)
	~(loglen(SERVER0) = INDEX1)
	~succ(INDEX1, loglen(SERVER0))
(qvars eq: post)
	SERVER0
	TERM0
	INDEX1
(boosted clause)
	(forall SERVER0, TERM0, INDEX1 . (~leader(SERVER0) | indlte(INDEX1, INDEX1) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(original clause)
	(~(loglen(s0) = i0) | ~committed(i2, t1) | ~leader(s0) | indlte(i2, i2) | succ(i2, i0))
(learnt sym-boosted clause)
	(forall SERVER0, TERM0, INDEX1 . (~leader(SERVER0) | indlte(INDEX1, INDEX1) | ~committed(INDEX1, TERM0) | (loglen(SERVER0) = INDEX1) | succ(INDEX1, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, T0, I1 . ((leader(S0) & committed(I1, T0)) -> (indlte(I1, I1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
@  1928s  is global clause? No
@  1928s  Learning in F[3]: (forall S0, T0, I1 . ((leader(S0) & committed(I1, T0)) -> (indlte(I1, I1) | (loglen(S0) = I1) | succ(I1, loglen(S0)))))
@  1928s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  1928s  F[2] /\ T /\ C+ ?
@  1928s  	Ans. UNSAT
@  1929s  F[3] unsat core #5 	(ucsz: 9 -> 6 -> 5 -> 5)
(minimal unsat core)
	(indzero = i0)
	committed(i2, t1)
	(loglen(s2) = i0)
	(termzero = t1)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | ~(termzero = t1) | ~committed(i2, t1))
(relations)
	loglen
	indzero
	termzero
	committed
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM0)
(antecedent reduction)
@  2108s  antecedent: 4 -> 2 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM0 -> termzero
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, termzero)
	(loglen(SERVER0) = indzero)
	(loglen(SERVER1) = indzero)
(qvars eq)
	SERVER0
	INDEX1
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER0 = SERVER1)
(boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, termzero) | (SERVER0 = SERVER1) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | ~(termzero = t1) | ~committed(i2, t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1, SERVER1 . (~committed(INDEX1, termzero) | (SERVER0 = SERVER1) | ~(loglen(SERVER0) = indzero) | ~(loglen(SERVER1) = indzero)))
---------------------------
(clause-type: univ)	(forall S0, I1, S1 . ((committed(I1, termzero) & (loglen(S0) = indzero) & (loglen(S1) = indzero)) -> (S0 = S1)))
@  2108s  is global clause? No
@  2108s  Learning in F[3]: (forall S0, I1, S1 . ((committed(I1, termzero) & (loglen(S0) = indzero) & (loglen(S1) = indzero)) -> (S0 = S1)))
@  2108s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2108s  F[2] /\ T /\ C+ ?
@  2108s  	Ans. UNSAT
@  2110s  F[3] unsat core #5 	(ucsz: 12 -> 9 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	(indzero = i0)
	~leader(s1)
	~leader(s2)
	(loglen(s0) = i0)
	committed(i2, t0)
(clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i2, t0) | leader(s1) | leader(s2))
(relations)
	loglen
	indzero
	committed
	leader
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	committed(INDEX1, TERM0)
	~leader(SERVER2)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
	~leader(SERVER1)
(antecedent reduction)
@  2116s  antecedent: 5 -> 3 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	INDEX0 -> indzero
(cube eq)
	~leader(SERVER1)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
	~leader(SERVER2)
(qvars eq)
	SERVER2
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ ~leader(SERVER2), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
	SERVER1 -> [ ~leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ ~leader(V:server:e9:), ]
	SERVER0 -> [ (loglen(V:server:e9:) = indzero), ]
	SERVER1 -> [ ~leader(V:server:e9:), ]
ucubes2qv #2
	(loglen(V:server:e9:) = indzero) -> [ SERVER0, ]
	~leader(V:server:e9:) -> [ SERVER2, SERVER1, ]
(partition) #2 server:e9: -> { SERVER0, | SERVER2, SERVER1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		(loglen(SERVER0) = indzero)
ucmulti:
	~leader(SERVER1)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
(epr reduced)
	(exists SERVER1 . (forall TERM0, SERVER0, INDEX1 . ((~(SERVER0 = SERVER1) & leader(SERVER1)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
(non-epr version)
	(forall TERM0, SERVER0, INDEX1 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & leader(SERVER1)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER1 . (forall TERM0, SERVER0, INDEX1 . ((~(SERVER0 = SERVER1) & leader(SERVER1)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s0) = i0) | ~committed(i2, t0) | leader(s1) | leader(s2))
(learnt sym-boosted clause)
	(exists SERVER1 . (forall TERM0, SERVER0, INDEX1 . ((~(SERVER0 = SERVER1) & leader(SERVER1)) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX1, TERM0))))
---------------------------
(clause-type: epr)	(exists S1 . (forall T0, S0, I1 . ((leader(S1) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0)))))
@  2117s  is global clause? No
@  2117s  Learning in F[3]: (exists S1 . (forall T0, S0, I1 . ((leader(S1) -> (S0 = S1)) -> ((loglen(S0) = indzero) -> ~committed(I1, T0)))))
@  2117s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2118s  F[2] /\ T /\ C+ ?
@  2118s  	Ans. UNSAT
@  2119s  F[3] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s1, i1) = t1)
	(indzero = i0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
	committed(i1, t0)
(clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~(loglen(s0) = i0) | ~committed(i1, t0))
(relations)
	loglen
	indzero
	log
	committed
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	(log(SERVER1, INDEX1) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
(antecedent reduction)
@  2126s  antecedent: 6 -> 2 (reduced)
	removed: INDEX1
	removed: INDEX0
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
(cube eq)
	committed(INDEX1, TERM0)
	(log(SERVER1, INDEX1) = TERM1)
	(loglen(SERVER0) = indzero)
	(log(SERVER0, indzero) = TERM0)
(qvars eq)
	INDEX1
	TERM0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
(eq map: post)
	TERM0 -> log(SERVER0, indzero)
	TERM1 -> log(SERVER1, INDEX1)
(cube eq: post)
	~(log(SERVER0, indzero) = log(SERVER1, INDEX1))
	committed(INDEX1, log(SERVER0, indzero))
	(loglen(SERVER0) = indzero)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . ((log(SERVER0, indzero) = log(SERVER1, INDEX1)) | ~committed(INDEX1, log(SERVER0, indzero)) | ~(loglen(SERVER0) = indzero)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~(loglen(s0) = i0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . ((log(SERVER0, indzero) = log(SERVER1, INDEX1)) | ~committed(INDEX1, log(SERVER0, indzero)) | ~(loglen(SERVER0) = indzero)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> (log(S0, indzero) = log(S1, I1))))
@  2126s  is global clause? No
@  2126s  Learning in F[3]: (forall S0, S1, I1 . ((committed(I1, log(S0, indzero)) & (loglen(S0) = indzero)) -> (log(S0, indzero) = log(S1, I1))))
@  2126s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2126s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
@  2126s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2126s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e10 with value True
	inputs:
actionName ext:getEntries
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:j:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
@  2127s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2127s  F[0] /\ T /\ C+ ?
@  2127s  	Ans. UNSAT
@  2127s  F[1] unsat core #2 	(ucsz: 3 -> 2 -> 2)
(minimal unsat core)
	(loglen(s1) = i1)
	(indzero = i0)
(clause)
	(~(indzero = i0) | ~(loglen(s1) = i1))
(relations)
	loglen
	indzero
(cube: std)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
(antecedent reduction)
@  2127s  antecedent: 2 -> 2

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
(qvars eq)
	SERVER0
	INDEX1
(antecedent eq)
	index:e9:
	-> ~(indzero = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (indzero = loglen(SERVER0)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(loglen(s1) = i1))
(learnt sym-boosted clause)
	(forall SERVER0 . (indzero = loglen(SERVER0)))
---------------------------
(clause-type: univ)	(forall S0 . (indzero = loglen(S0)))
@  2127s  is global clause? No
@  2127s  Learning in F[1]: (forall S0 . (indzero = loglen(S0)))
@  2127s  F[1] /\ T /\ C+ ?
@  2127s  	Ans. UNSAT
@  2127s  F[2] unsat core #4 	(ucsz: 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i1)
	(indzero = i0)
	(termzero = t0)
	(log(s1, i1) = t0)
(clause)
	(~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i1) | ~(termzero = t0))
(relations)
	loglen
	indzero
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX1)
	(indzero = INDEX0)
	(termzero = TERM0)
(antecedent reduction)
@  2127s  antecedent: 2 -> 2

(eq map)
	TERM0 -> termzero
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER0, INDEX1) = termzero)
(qvars eq)
	SERVER0
	INDEX1
(antecedent eq)
	index:e9:
	-> ~(indzero = INDEX1)
(eq map: post)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
(boosted clause)
	(forall SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s1) = i1) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0 . ((log(S0, loglen(S0)) = termzero) -> (indzero = loglen(S0))))
@  2127s  is global clause? No
@  2127s  Learning in F[2]: (forall S0 . ((log(S0, loglen(S0)) = termzero) -> (indzero = loglen(S0))))
@  2127s  F[2] /\ T /\ C+ ?
@  2127s  	Ans. UNSAT
@  2129s  F[3] unsat core #4 	(ucsz: 12 -> 7 -> 6 -> 4 -> 4)
(minimal unsat core)
	committed(i1, t0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
	(termzero = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(relations)
	loglen
	termzero
	committed
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	committed(INDEX1, TERM0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
(antecedent reduction)
@  2129s  antecedent: 2 -> 0 (reduced)
	removed: INDEX0
	removed: INDEX1

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX1, termzero)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	INDEX0
	SERVER0
	INDEX1
(antecedent eq)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	committed(INDEX1, termzero)
(qvars eq: post)
	SERVER0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~committed(INDEX1, termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~committed(INDEX1, termzero)))
---------------------------
(clause-type: univ)	(forall S0, I1 . ((log(S0, loglen(S0)) = termzero) -> ~committed(I1, termzero)))
@  2129s  is global clause? No
@  2129s  Learning in F[3]: (forall S0, I1 . ((log(S0, loglen(S0)) = termzero) -> ~committed(I1, termzero)))
@  2129s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2129s  F[2] /\ T /\ C+ ?
@  2130s  	Ans. UNSAT
@  2130s  F[3] unsat core #6 	(ucsz: 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i1)
	leader(s0)
	(loglen(s1) = i1)
	(currentTerm(s0) = t1)
	(log(s0, i1) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1) | ~leader(s0))
(relations)
	loglen
	log
	leader
	currentTerm
(cube: std)
	(log(SERVER0, INDEX1) = TERM0)
	leader(SERVER0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX0) = TERM1)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@  2131s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER1))
	TERM1 -> log(SERVER1, INDEX0)
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	leader(SERVER0)
	(currentTerm(SERVER0) = log(SERVER1, INDEX0))
	(loglen(SERVER0) = loglen(SERVER1))
	~(INDEX0 = loglen(SERVER1))
	~(log(SERVER0, loglen(SERVER1)) = log(SERVER1, INDEX0))
(qvars eq: post)
	INDEX0
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX0)) | ~(loglen(SERVER0) = loglen(SERVER1)) | (INDEX0 = loglen(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, INDEX0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t0) | ~(log(s1, i0) = t1) | ~(loglen(s0) = i1) | ~(loglen(s1) = i1) | ~leader(s0))
(learnt sym-boosted clause)
	(forall INDEX0, SERVER0, SERVER1 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX0)) | ~(loglen(SERVER0) = loglen(SERVER1)) | (INDEX0 = loglen(SERVER1)) | (log(SERVER0, loglen(SERVER1)) = log(SERVER1, INDEX0))))
---------------------------
(clause-type: univ)	(forall I0, S0, S1 . ((leader(S0) & (currentTerm(S0) = log(S1, I0)) & (loglen(S0) = loglen(S1))) -> ((I0 = loglen(S1)) | (log(S0, loglen(S1)) = log(S1, I0)))))
@  2131s  is global clause? No
@  2131s  Learning in F[3]: (forall I0, S0, S1 . ((leader(S0) & (currentTerm(S0) = log(S1, I0)) & (loglen(S0) = loglen(S1))) -> ((I0 = loglen(S1)) | (log(S0, loglen(S1)) = log(S1, I0)))))
@  2131s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t2			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = true
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2132s  F[2] /\ T /\ C+ ?
@  2132s  	Ans. UNSAT
@  2134s  F[3] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	~member(s0, q0)
	(log(s0, i1) = t2)
	committed(i1, t2)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~committed(i1, t2) | ~leader(s0) | member(s0, q0))
(relations)
	member
	currentTerm
	committed
	leader
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	leader(SERVER0)
	~member(SERVER0, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@  2138s  antecedent: 2 -> 2

(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	TERM1 -> log(SERVER0, INDEX0)
(cube eq: post)
	leader(SERVER0)
	~(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~member(SERVER0, QUORUM0)
	committed(INDEX0, log(SERVER0, INDEX0))
(qvars eq: post)
	QUORUM0
	SERVER0
	INDEX0
(boosted clause)
	(forall QUORUM0, SERVER0, INDEX0 . (~leader(SERVER0) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | member(SERVER0, QUORUM0) | ~committed(INDEX0, log(SERVER0, INDEX0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i1) = t2) | ~committed(i1, t2) | ~leader(s0) | member(s0, q0))
(learnt sym-boosted clause)
	(forall QUORUM0, SERVER0, INDEX0 . (~leader(SERVER0) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | member(SERVER0, QUORUM0) | ~committed(INDEX0, log(SERVER0, INDEX0))))
---------------------------
(clause-type: univ)	(forall Q0, S0, I0 . ((leader(S0) & committed(I0, log(S0, I0))) -> ((currentTerm(S0) = log(S0, I0)) | member(S0, Q0))))
@  2138s  is global clause? No
@  2138s  Learning in F[3]: (forall Q0, S0, I0 . ((leader(S0) & committed(I0, log(S0, I0))) -> ((currentTerm(S0) = log(S0, I0)) | member(S0, Q0))))
@  2138s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2139s  F[2] /\ T /\ C+ ?
@  2139s  	Ans. UNSAT
@  2139s  F[3] unsat core #6 	(ucsz: 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(log(s2, i0) = t2)
	(currentTerm(s0) = t1)
	(log(s0, i0) = t0)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(relations)
	loglen
	log
	currentTerm
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER2, INDEX0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
	(log(SERVER0, INDEX0) = TERM0)
	(currentTerm(SERVER0) = TERM1)
(antecedent reduction)
@  2140s  antecedent: 6 -> 3 (reduced)
	removed: SERVER2
	removed: SERVER1
	removed: SERVER0

qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ (currentTerm(SERVER0) = TERM1), (log(SERVER1, INDEX0) = TERM1), ]
	TERM2 -> [ (log(SERVER2, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ (log(SERVER1, INDEX0) = V:term:e9:), (currentTerm(SERVER0) = V:term:e9:), ]
	TERM2 -> [ (log(SERVER2, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	((currentTerm(SERVER0) = V:term:e9:) & (log(SERVER1, INDEX0) = V:term:e9:)) -> [ TERM1, ]
	(log(SERVER2, INDEX0) = V:term:e9:) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM2), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (currentTerm(SERVER0) = TERM1), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), (log(SERVER1, INDEX0) = TERM1), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM2), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM1), (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = TERM1), (loglen(V:server:e9:) = INDEX0), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM2) -> [ SERVER2, ]
	((currentTerm(V:server:e9:) = TERM1) & (log(V:server:e9:, INDEX0) = TERM0) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
	((log(V:server:e9:, INDEX0) = TERM1) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
	TERM2 -> log(SERVER2, loglen(SERVER0))
(cube eq: post)
	(loglen(SERVER1) = loglen(SERVER0))
	~(log(SERVER1, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0)))
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~(loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s1, i0) = t1) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~(loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0))) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . (((loglen(S1) = loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0)))) -> ((log(S1, loglen(S0)) = log(S2, loglen(S0))) | (log(S0, loglen(S0)) = log(S1, loglen(S0))) | (log(S0, loglen(S0)) = log(S2, loglen(S0))))))
@  2140s  is global clause? No
@  2140s  Learning in F[3]: (forall S2, S0, S1 . (((loglen(S1) = loglen(S0)) & (currentTerm(S0) = log(S1, loglen(S0)))) -> ((log(S1, loglen(S0)) = log(S2, loglen(S0))) | (log(S0, loglen(S0)) = log(S1, loglen(S0))) | (log(S0, loglen(S0)) = log(S2, loglen(S0))))))
@  2140s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t2			--> modified
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2141s  F[2] /\ T /\ C+ ?
@  2141s  	Ans. UNSAT
@  2143s  F[3] unsat core #5 	(ucsz: 13 -> 10 -> 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t1)
	committed(i2, t2)
	(loglen(s2) = i1)
	(log(s1, i0) = t1)
	leader(s0)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i0) = t1) | ~(loglen(s2) = i1) | ~committed(i2, t2) | ~leader(s0))
(relations)
	loglen
	currentTerm
	committed
	leader
	log
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	committed(INDEX2, TERM1)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM0)
	(loglen(SERVER2) = INDEX1)
	(log(SERVER1, INDEX0) = TERM0)
(antecedent reduction)
@  2146s  antecedent: 8 -> 8

qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX1), ]
	SERVER0 -> [ leader(SERVER0), (currentTerm(SERVER0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM0), leader(V:server:e9:), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = TERM0), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM0) -> [ SERVER1, ]
	((currentTerm(V:server:e9:) = TERM0) & leader(V:server:e9:)) -> [ SERVER0, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER2, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER0, | SERVER2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ committed(INDEX2, TERM1), ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER2) = INDEX1), ]
qv2ucubes #3
	INDEX2 -> [ committed(V:index:e9:, TERM1), ]
	INDEX0 -> [ (log(SERVER1, V:index:e9:) = TERM0), ]
	INDEX1 -> [ (loglen(SERVER2) = V:index:e9:), ]
ucubes2qv #3
	committed(V:index:e9:, TERM1) -> [ INDEX2, ]
	(log(SERVER1, V:index:e9:) = TERM0) -> [ INDEX0, ]
	(loglen(SERVER2) = V:index:e9:) -> [ INDEX1, ]
(partition) #3 index:e9: -> { INDEX2, | INDEX0, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER1, INDEX0)
	INDEX1 -> loglen(SERVER2)
(cube eq: post)
	~(INDEX0 = INDEX2)
	~(SERVER0 = SERVER1)
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	committed(INDEX2, TERM1)
	leader(SERVER0)
	(currentTerm(SERVER0) = log(SERVER1, INDEX0))
	~(log(SERVER1, INDEX0) = TERM1)
	~(loglen(SERVER2) = INDEX2)
	~(INDEX0 = loglen(SERVER2))
(qvars eq: post)
	SERVER2
	INDEX0
	INDEX2
	TERM1
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX0, INDEX2, TERM1, SERVER0, SERVER1 . ((INDEX0 = INDEX2) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~committed(INDEX2, TERM1) | ~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX0)) | (log(SERVER1, INDEX0) = TERM1) | (loglen(SERVER2) = INDEX2) | (INDEX0 = loglen(SERVER2))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i0) = t1) | ~(loglen(s2) = i1) | ~committed(i2, t2) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX0, INDEX2, TERM1, SERVER0, SERVER1 . ((INDEX0 = INDEX2) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~committed(INDEX2, TERM1) | ~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, INDEX0)) | (log(SERVER1, INDEX0) = TERM1) | (loglen(SERVER2) = INDEX2) | (INDEX0 = loglen(SERVER2))))
---------------------------
(clause-type: univ)	(forall S2, I0, I2, T1, S0, S1 . ((committed(I2, T1) & leader(S0) & (currentTerm(S0) = log(S1, I0))) -> ((I0 = I2) | (S0 = S1) | (S0 = S2) | (S1 = S2) | (log(S1, I0) = T1) | (loglen(S2) = I2) | (I0 = loglen(S2)))))
@  2146s  is global clause? No
@  2146s  Learning in F[3]: (forall S2, I0, I2, T1, S0, S1 . ((committed(I2, T1) & leader(S0) & (currentTerm(S0) = log(S1, I0))) -> ((I0 = I2) | (S0 = S1) | (S0 = S2) | (S1 = S2) | (log(S1, I0) = T1) | (loglen(S2) = I2) | (I0 = loglen(S2)))))
@  2146s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = true			--> modified
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2148s  F[2] /\ T /\ C+ ?
@  2149s  	Ans. UNSAT
@  2149s  F[3] unsat core #4 	(ucsz: 13 -> 8 -> 6 -> 4 -> 4)
(minimal unsat core)
	(log(s2, i1) = t0)
	(loglen(s2) = i1)
	committed(i1, t2)
	(termzero = t0)
(clause)
	(~(log(s2, i1) = t0) | ~(loglen(s2) = i1) | ~(termzero = t0) | ~committed(i1, t2))
(relations)
	loglen
	termzero
	committed
	log
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	committed(INDEX0, TERM1)
(antecedent reduction)
@  2149s  antecedent: 2 -> 0 (reduced)
	removed: TERM0
	removed: TERM1

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX0)
	committed(INDEX0, TERM1)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	SERVER0
	TERM1
	INDEX0
(antecedent eq)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	committed(loglen(SERVER0), TERM1)
(qvars eq: post)
	TERM1
	SERVER0
(boosted clause)
	(forall TERM1, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~committed(loglen(SERVER0), TERM1)))
---------------------------
(original clause)
	(~(log(s2, i1) = t0) | ~(loglen(s2) = i1) | ~(termzero = t0) | ~committed(i1, t2))
(learnt sym-boosted clause)
	(forall TERM1, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~committed(loglen(SERVER0), TERM1)))
---------------------------
(clause-type: univ)	(forall T1, S0 . ((log(S0, loglen(S0)) = termzero) -> ~committed(loglen(S0), T1)))
@  2149s  is global clause? No
@  2149s  Learning in F[3]: (forall T1, S0 . ((log(S0, loglen(S0)) = termzero) -> ~committed(loglen(S0), T1)))
@  2149s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t0			--> modified
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2			--> modified
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t1

@  2149s  F[2] /\ T /\ C+ ?
@  2150s  	Ans. UNSAT
@  2150s  F[3] unsat core #4 	(ucsz: 13 -> 8 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s0) = t2)
	(termzero = t1)
	(log(s0, i2) = t0)
	committed(i1, t0)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i2) = t0) | ~(termzero = t1) | ~committed(i1, t0))
(relations)
	currentTerm
	log
	committed
	termzero
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM2)
	committed(INDEX0, TERM0)
(antecedent reduction)
@  2150s  antecedent: 5 -> 3 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM2)
	committed(INDEX0, TERM0)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	TERM2
	SERVER0
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	-> ~(TERM0 = TERM2)
	-> ~(termzero = TERM2)
(fullsorts)
	term:e9: -> [ TERM0, termzero, TERM2, ]
qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX1) = TERM0), committed(INDEX0, TERM0), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ committed(INDEX0, V:term:e9:), (log(SERVER0, INDEX1) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = V:term:e9:), ]
ucubes2qv #3
	((log(SERVER0, INDEX1) = V:term:e9:) & committed(INDEX0, V:term:e9:)) -> [ TERM0, ]
	true -> [ termzero, ]
	(currentTerm(SERVER0) = V:term:e9:) -> [ TERM2, ]
(partition) #3 term:e9: -> { TERM0, | termzero, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	committed(INDEX0, log(SERVER0, INDEX1))
	~(log(SERVER0, INDEX1) = termzero)
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~committed(INDEX0, log(SERVER0, INDEX1)) | (log(SERVER0, INDEX1) = termzero) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i2) = t0) | ~(termzero = t1) | ~committed(i1, t0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~committed(INDEX0, log(SERVER0, INDEX1)) | (log(SERVER0, INDEX1) = termzero) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0, I1 . (committed(I0, log(S0, I1)) -> ((log(S0, I1) = currentTerm(S0)) | (log(S0, I1) = termzero) | (termzero = currentTerm(S0)))))
@  2150s  is global clause? No
@  2150s  Learning in F[3]: (forall S0, I0, I1 . (committed(I0, log(S0, I1)) -> ((log(S0, I1) = currentTerm(S0)) | (log(S0, I1) = termzero) | (termzero = currentTerm(S0)))))
@  2150s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1			--> modified
	currentTerm(s2) = t1
	leader(s0) = false			--> modified
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2151s  F[2] /\ T /\ C+ ?
@  2151s  	Ans. UNSAT
@  2153s  F[3] unsat core #6 	(ucsz: 15 -> 13 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	committed(i2, t1)
	(loglen(s0) = i0)
	~lte(t2, t1)
	(loglen(s1) = i1)
	(indzero = i0)
	(log(s1, i1) = t0)
(clause)
	(~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i2, t1) | lte(t2, t1))
(relations)
	loglen
	committed
	indzero
	lte
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	~lte(TERM2, TERM1)
	committed(INDEX2, TERM1)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(indzero = INDEX0)
(antecedent reduction)
@  2158s  antecedent: 8 -> 5 (reduced)
	removed: INDEX2
	removed: SERVER1
	removed: SERVER0

(eq map)
	INDEX0 -> indzero
(cube eq)
	~lte(TERM2, TERM1)
	(loglen(SERVER0) = indzero)
	(loglen(SERVER1) = INDEX1)
	(log(SERVER1, INDEX1) = TERM0)
	committed(INDEX2, TERM1)
(qvars eq)
	INDEX1
	INDEX2
	TERM0
	TERM1
	TERM2
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	-> ~(TERM0 = TERM2)
	-> ~(TERM1 = TERM2)
	index:e9:
	-> ~(indzero = INDEX1)
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	index:e9: -> [ indzero, INDEX1, INDEX2, ]
qv2cubes #3
	TERM0 -> [ (log(SERVER1, INDEX1) = TERM0), ]
	TERM1 -> [ ~lte(TERM2, TERM1), committed(INDEX2, TERM1), ]
	TERM2 -> [ ~lte(TERM2, TERM1), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER1, INDEX1) = V:term:e9:), ]
	TERM1 -> [ ~lte(TERM2, V:term:e9:), committed(INDEX2, V:term:e9:), ]
	TERM2 -> [ ~lte(V:term:e9:, TERM1), ]
ucubes2qv #3
	(committed(INDEX2, V:term:e9:) & ~lte(TERM2, V:term:e9:)) -> [ TERM1, ]
	~lte(V:term:e9:, TERM1) -> [ TERM2, ]
	(log(SERVER1, INDEX1) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ committed(INDEX2, TERM1), ]
	indzero -> [ (loglen(SERVER0) = indzero), ]
	INDEX1 -> [ (loglen(SERVER1) = INDEX1), (log(SERVER1, INDEX1) = TERM0), ]
qv2ucubes #3
	INDEX2 -> [ committed(V:index:e9:, TERM1), ]
	indzero -> [ (loglen(SERVER0) = V:index:e9:), ]
	INDEX1 -> [ (log(SERVER1, V:index:e9:) = TERM0), (loglen(SERVER1) = V:index:e9:), ]
ucubes2qv #3
	(loglen(SERVER0) = V:index:e9:) -> [ indzero, ]
	committed(V:index:e9:, TERM1) -> [ INDEX2, ]
	((log(SERVER1, V:index:e9:) = TERM0) & (loglen(SERVER1) = V:index:e9:)) -> [ INDEX1, ]
(partition) #3 index:e9: -> { indzero, | INDEX2, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER1, loglen(SERVER1))
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	~lte(TERM2, TERM1)
	(loglen(SERVER0) = indzero)
	committed(INDEX2, TERM1)
	~(TERM1 = TERM2)
	~(log(SERVER1, loglen(SERVER1)) = TERM1)
	~(log(SERVER1, loglen(SERVER1)) = TERM2)
	~(indzero = loglen(SERVER1))
(qvars eq: post)
	INDEX2
	TERM1
	TERM2
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX2, TERM1, TERM2, SERVER0, SERVER1 . (lte(TERM2, TERM1) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX2, TERM1) | (TERM1 = TERM2) | (log(SERVER1, loglen(SERVER1)) = TERM1) | (log(SERVER1, loglen(SERVER1)) = TERM2) | (indzero = loglen(SERVER1))))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i2, t1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall INDEX2, TERM1, TERM2, SERVER0, SERVER1 . (lte(TERM2, TERM1) | ~(loglen(SERVER0) = indzero) | ~committed(INDEX2, TERM1) | (TERM1 = TERM2) | (log(SERVER1, loglen(SERVER1)) = TERM1) | (log(SERVER1, loglen(SERVER1)) = TERM2) | (indzero = loglen(SERVER1))))
---------------------------
(clause-type: univ)	(forall I2, T1, T2, S0, S1 . (((loglen(S0) = indzero) & committed(I2, T1)) -> (lte(T2, T1) | (T1 = T2) | (log(S1, loglen(S1)) = T1) | (log(S1, loglen(S1)) = T2) | (indzero = loglen(S1)))))
@  2158s  is global clause? No
@  2158s  Learning in F[3]: (forall I2, T1, T2, S0, S1 . (((loglen(S0) = indzero) & committed(I2, T1)) -> (lte(T2, T1) | (T1 = T2) | (log(S1, loglen(S1)) = T1) | (log(S1, loglen(S1)) = T2) | (indzero = loglen(S1)))))
@  2158s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = true
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2159s  F[2] /\ T /\ C+ ?
@  2159s  	Ans. UNSAT
@  2160s  F[3] unsat core #7 	(ucsz: 14 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	(loglen(s0) = i0)
	leader(s1)
	~member(s2, q0)
	(currentTerm(s1) = t2)
	(log(s0, i0) = t0)
	committed(i1, t2)
	(log(s1, i1) = t0)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t2) | ~leader(s1) | member(s2, q0))
(relations)
	loglen
	log
	leader
	currentTerm
	member
	committed
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(currentTerm(SERVER1) = TERM1)
	leader(SERVER1)
	(log(SERVER0, INDEX0) = TERM0)
	~member(SERVER2, QUORUM0)
	committed(INDEX1, TERM1)
(antecedent reduction)
@  2164s  antecedent: 7 -> 5 (reduced)
	removed: INDEX0
	removed: INDEX1

qv2cubes #3
	SERVER2 -> [ ~member(SERVER2, QUORUM0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ leader(SERVER1), (log(SERVER1, INDEX1) = TERM0), (currentTerm(SERVER1) = TERM1), ]
qv2ucubes #3
	SERVER2 -> [ ~member(V:server:e9:, QUORUM0), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (currentTerm(V:server:e9:) = TERM1), leader(V:server:e9:), (log(V:server:e9:, INDEX1) = TERM0), ]
ucubes2qv #3
	~member(V:server:e9:, QUORUM0) -> [ SERVER2, ]
	((log(V:server:e9:, INDEX0) = TERM0) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
	((currentTerm(V:server:e9:) = TERM1) & (log(V:server:e9:, INDEX1) = TERM0) & leader(V:server:e9:)) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER1)
	TERM0 -> log(SERVER1, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~member(SERVER2, QUORUM0)
	leader(SERVER1)
	~(log(SERVER1, INDEX1) = currentTerm(SERVER1))
	(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1))
	committed(INDEX1, currentTerm(SERVER1))
(qvars eq: post)
	SERVER2
	INDEX1
	QUORUM0
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | member(SERVER2, QUORUM0) | ~leader(SERVER1) | (log(SERVER1, INDEX1) = currentTerm(SERVER1)) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1)) | ~committed(INDEX1, currentTerm(SERVER1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t2) | ~leader(s1) | member(s2, q0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, QUORUM0, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | member(SERVER2, QUORUM0) | ~leader(SERVER1) | (log(SERVER1, INDEX1) = currentTerm(SERVER1)) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, INDEX1)) | ~committed(INDEX1, currentTerm(SERVER1))))
---------------------------
(clause-type: univ)	(forall S2, I1, Q0, S0, S1 . ((leader(S1) & (log(S0, loglen(S0)) = log(S1, I1)) & committed(I1, currentTerm(S1))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | member(S2, Q0) | (log(S1, I1) = currentTerm(S1)))))
@  2164s  is global clause? No
@  2164s  Learning in F[3]: (forall S2, I1, Q0, S0, S1 . ((leader(S1) & (log(S0, loglen(S0)) = log(S1, I1)) & committed(I1, currentTerm(S1))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | member(S2, Q0) | (log(S1, I1) = currentTerm(S1)))))
@  2164s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2166s  F[2] /\ T /\ C+ ?
@  2166s  	Ans. UNSAT
@  2168s  F[3] unsat core #4 	(ucsz: 11 -> 8 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i1) = t2)
	committed(i1, t2)
	(loglen(s0) = i0)
	(loglen(s1) = i2)
(clause)
	(~(log(s1, i1) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2))
(relations)
	loglen
	log
	committed
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	committed(INDEX1, TERM0)
	(loglen(SERVER1) = INDEX2)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
(antecedent reduction)
@  2169s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

qv2cubes #3
	INDEX2 -> [ (loglen(SERVER1) = INDEX2), ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ committed(INDEX1, TERM0), (log(SERVER1, INDEX1) = TERM0), ]
qv2ucubes #3
	INDEX2 -> [ (loglen(SERVER1) = V:index:e9:), ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), ]
	INDEX1 -> [ committed(V:index:e9:, TERM0), (log(SERVER1, V:index:e9:) = TERM0), ]
ucubes2qv #3
	(loglen(SERVER0) = V:index:e9:) -> [ INDEX0, ]
	((log(SERVER1, V:index:e9:) = TERM0) & committed(V:index:e9:, TERM0)) -> [ INDEX1, ]
	(loglen(SERVER1) = V:index:e9:) -> [ INDEX2, ]
(partition) #3 index:e9: -> { INDEX0, | INDEX1, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER1)
	TERM0 -> log(SERVER1, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	~(loglen(SERVER0) = loglen(SERVER1))
	~(INDEX1 = loglen(SERVER1))
	committed(INDEX1, log(SERVER1, INDEX1))
	~(loglen(SERVER0) = INDEX1)
(qvars eq: post)
	INDEX1
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX1, SERVER0, SERVER1 . ((loglen(SERVER0) = loglen(SERVER1)) | (INDEX1 = loglen(SERVER1)) | ~committed(INDEX1, log(SERVER1, INDEX1)) | (loglen(SERVER0) = INDEX1)))
---------------------------
(original clause)
	(~(log(s1, i1) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i2) | ~committed(i1, t2))
(learnt sym-boosted clause)
	(forall INDEX1, SERVER0, SERVER1 . ((loglen(SERVER0) = loglen(SERVER1)) | (INDEX1 = loglen(SERVER1)) | ~committed(INDEX1, log(SERVER1, INDEX1)) | (loglen(SERVER0) = INDEX1)))
---------------------------
(clause-type: univ)	(forall I1, S0, S1 . (committed(I1, log(S1, I1)) -> ((loglen(S0) = loglen(S1)) | (I1 = loglen(S1)) | (loglen(S0) = I1))))
@  2169s  is global clause? No
@  2169s  Learning in F[3]: (forall I1, S0, S1 . (committed(I1, log(S1, I1)) -> ((loglen(S0) = loglen(S1)) | (I1 = loglen(S1)) | (loglen(S0) = I1))))
@  2169s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1			--> modified
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2169s  F[2] /\ T /\ C+ ?
@  2169s  	Ans. UNSAT
@  2171s  F[3] unsat core #5 	(ucsz: 12 -> 10 -> 9 -> 8 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i1)
	(log(s2, i1) = t1)
	committed(i1, t1)
	(indzero = i0)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i0) | ~(log(s2, i1) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i1, t1))
(relations)
	loglen
	indzero
	log
	committed
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	committed(INDEX1, TERM0)
	(log(SERVER2, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX0)
(antecedent reduction)
@  2175s  antecedent: 5 -> 2 (reduced)
	removed: SERVER0
	removed: INDEX1
	removed: INDEX0

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER1) = INDEX1)
	(log(SERVER2, INDEX1) = TERM0)
	(loglen(SERVER0) = indzero)
	committed(INDEX1, TERM0)
(qvars eq)
	SERVER2
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX1) = TERM0), ]
	SERVER0 -> [ (loglen(SERVER0) = indzero), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX1) = TERM0), ]
	SERVER0 -> [ (loglen(V:server:e9:) = indzero), ]
	SERVER1 -> [ (loglen(V:server:e9:) = INDEX1), ]
ucubes2qv #3
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER1, ]
	(log(V:server:e9:, INDEX1) = TERM0) -> [ SERVER2, ]
	(loglen(V:server:e9:) = indzero) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER2, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER2, loglen(SERVER1))
	INDEX1 -> loglen(SERVER1)
(cube eq: post)
	committed(loglen(SERVER1), log(SERVER2, loglen(SERVER1)))
	(loglen(SERVER0) = indzero)
	~(SERVER1 = SERVER2)
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~committed(loglen(SERVER1), log(SERVER2, loglen(SERVER1))) | ~(loglen(SERVER0) = indzero) | (SERVER1 = SERVER2)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s2, i1) = t1) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~committed(i1, t1))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~committed(loglen(SERVER1), log(SERVER2, loglen(SERVER1))) | ~(loglen(SERVER0) = indzero) | (SERVER1 = SERVER2)))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . ((committed(loglen(S1), log(S2, loglen(S1))) & (loglen(S0) = indzero)) -> (S1 = S2)))
@  2175s  is global clause? No
@  2175s  Learning in F[3]: (forall S2, S0, S1 . ((committed(loglen(S1), log(S2, loglen(S1))) & (loglen(S0) = indzero)) -> (S1 = S2)))
@  2175s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2175s  F[2] /\ T /\ C+ ?
@  2175s  	Ans. UNSAT
@  2176s  F[3] unsat core #4 	(ucsz: 11 -> 9 -> 6 -> 4 -> 4)
(minimal unsat core)
	(currentTerm(s1) = t2)
	(log(s1, i2) = t1)
	(termzero = t0)
	committed(i1, t2)
(clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i2) = t1) | ~(termzero = t0) | ~committed(i1, t2))
(relations)
	currentTerm
	log
	committed
	termzero
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	committed(INDEX0, TERM2)
	(currentTerm(SERVER0) = TERM2)
	(termzero = TERM0)
	(log(SERVER0, INDEX1) = TERM1)
(antecedent reduction)
@  2180s  antecedent: 5 -> 3 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM0 -> termzero
(cube eq)
	committed(INDEX0, TERM2)
	(currentTerm(SERVER0) = TERM2)
	(log(SERVER0, INDEX1) = TERM1)
(qvars eq)
	INDEX0
	INDEX1
	TERM1
	TERM2
	SERVER0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
(fullsorts)
	term:e9: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ (log(SERVER0, INDEX1) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ committed(INDEX0, TERM2), (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (log(SERVER0, INDEX1) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ committed(INDEX0, V:term:e9:), (currentTerm(SERVER0) = V:term:e9:), ]
ucubes2qv #3
	true -> [ termzero, ]
	((currentTerm(SERVER0) = V:term:e9:) & committed(INDEX0, V:term:e9:)) -> [ TERM2, ]
	(log(SERVER0, INDEX1) = V:term:e9:) -> [ TERM1, ]
(partition) #3 term:e9: -> { termzero, | TERM2, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(termzero = currentTerm(SERVER0))
	~(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	committed(INDEX0, currentTerm(SERVER0))
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	INDEX0
	INDEX1
	SERVER0
(boosted clause)
	(forall INDEX0, INDEX1, SERVER0 . ((termzero = currentTerm(SERVER0)) | (log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~committed(INDEX0, currentTerm(SERVER0)) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(log(s1, i2) = t1) | ~(termzero = t0) | ~committed(i1, t2))
(learnt sym-boosted clause)
	(forall INDEX0, INDEX1, SERVER0 . ((termzero = currentTerm(SERVER0)) | (log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~committed(INDEX0, currentTerm(SERVER0)) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall I0, I1, S0 . (committed(I0, currentTerm(S0)) -> ((termzero = currentTerm(S0)) | (log(S0, I1) = currentTerm(S0)) | (termzero = log(S0, I1)))))
@  2180s  is global clause? No
@  2180s  Learning in F[3]: (forall I0, I1, S0 . (committed(I0, currentTerm(S0)) -> ((termzero = currentTerm(S0)) | (log(S0, I1) = currentTerm(S0)) | (termzero = log(S0, I1)))))
@  2180s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:becomeLeader
	en: en_ext:becomeLeader:e10 with value True
	inputs:
actionName ext:becomeLeader
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:newterm:e1:e4:e7:e8 -> t0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0			--> modified
	currentTerm(s1) = t2
	currentTerm(s2) = t2			--> modified
	leader(s0) = false			--> modified
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2181s  F[2] /\ T /\ C+ ?
@  2182s  	Ans. UNSAT
@  2191s  F[3] unsat core #6 	(ucsz: 12 -> 11 -> 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(log(s2, i1) = t0)
	(loglen(s0) = i0)
	member(s0, q1)
	member(s2, q0)
	(indzero = i0)
	committed(i1, t2)
(clause)
	(~(indzero = i0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t2) | ~member(s0, q1) | ~member(s2, q0))
(relations)
	loglen
	log
	indzero
	committed
	member
(fullsorts)
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	member(SERVER1, QUORUM0)
	member(SERVER0, QUORUM1)
	committed(INDEX1, TERM1)
	(indzero = INDEX0)
(antecedent reduction)
@  2217s  antecedent: 8 -> 4 (reduced)
	removed: INDEX1
	removed: INDEX0
	removed: SERVER0
	removed: SERVER1

(eq map)
	INDEX0 -> indzero
(cube eq)
	(loglen(SERVER0) = indzero)
	member(SERVER0, QUORUM1)
	committed(INDEX1, TERM1)
	(log(SERVER1, INDEX1) = TERM0)
	member(SERVER1, QUORUM0)
(qvars eq)
	INDEX1
	TERM0
	TERM1
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	quorum:e9:
	-> ~(QUORUM0 = QUORUM1)
(fullsorts)
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
qv2cubes #2
	QUORUM0 -> [ member(SERVER1, QUORUM0), ]
	QUORUM1 -> [ member(SERVER0, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER1, V:quorum:e9:), ]
	QUORUM1 -> [ member(SERVER0, V:quorum:e9:), ]
ucubes2qv #2
	member(SERVER1, V:quorum:e9:) -> [ QUORUM0, ]
	member(SERVER0, V:quorum:e9:) -> [ QUORUM1, ]
(partition) #2 quorum:e9: -> { QUORUM0, | QUORUM1, | }
	#2 singles, #0 multiples (out of #2 cells)
(eq map: post)
	TERM0 -> log(SERVER1, INDEX1)
(cube eq: post)
	(loglen(SERVER0) = indzero)
	~(log(SERVER1, INDEX1) = TERM1)
	~(QUORUM0 = QUORUM1)
	member(SERVER1, QUORUM0)
	member(SERVER0, QUORUM1)
	committed(INDEX1, TERM1)
(qvars eq: post)
	INDEX1
	TERM1
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX1, TERM1, QUORUM0, QUORUM1, SERVER0, SERVER1 . (~(loglen(SERVER0) = indzero) | (log(SERVER1, INDEX1) = TERM1) | (QUORUM0 = QUORUM1) | ~member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~committed(INDEX1, TERM1)))
---------------------------
(original clause)
	(~(indzero = i0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~committed(i1, t2) | ~member(s0, q1) | ~member(s2, q0))
(learnt sym-boosted clause)
	(forall INDEX1, TERM1, QUORUM0, QUORUM1, SERVER0, SERVER1 . (~(loglen(SERVER0) = indzero) | (log(SERVER1, INDEX1) = TERM1) | (QUORUM0 = QUORUM1) | ~member(SERVER1, QUORUM0) | ~member(SERVER0, QUORUM1) | ~committed(INDEX1, TERM1)))
---------------------------
(clause-type: univ)	(forall I1, T1, Q0, Q1, S0, S1 . (((loglen(S0) = indzero) & member(S1, Q0) & member(S0, Q1) & committed(I1, T1)) -> ((log(S1, I1) = T1) | (Q0 = Q1))))
@  2217s  is global clause? No
@  2217s  Learning in F[3]: (forall I1, T1, Q0, Q1, S0, S1 . (((loglen(S0) = indzero) & member(S1, Q0) & member(S0, Q1) & committed(I1, T1)) -> ((log(S1, I1) = T1) | (Q0 = Q1))))
@  2217s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t1
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2225s  F[2] /\ T /\ C+ ?
@  2226s  	Ans. UNSAT
@  2234s  F[3] unsat core #5 	(ucsz: 9 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(currentTerm(s0) = t1)
	~lte(t1, t0)
	indlt(i0, i2)
	(loglen(s0) = i0)
	committed(i2, t0)
(clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | ~indlt(i0, i2) | lte(t1, t0))
(relations)
	loglen
	currentTerm
	lte
	indlt
	committed
(cube: std)
	committed(INDEX1, TERM0)
	indlt(INDEX0, INDEX1)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	~lte(TERM1, TERM0)
(antecedent reduction)
@  2250s  antecedent: 4 -> 0 (reduced)
	removed: TERM0
	removed: TERM1
	removed: INDEX0
	removed: INDEX1

(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> currentTerm(SERVER0)
(cube eq: post)
	~lte(currentTerm(SERVER0), TERM0)
	indlt(loglen(SERVER0), INDEX1)
	committed(INDEX1, TERM0)
(qvars eq: post)
	TERM0
	SERVER0
	INDEX1
(boosted clause)
	(forall TERM0, SERVER0, INDEX1 . (lte(currentTerm(SERVER0), TERM0) | ~indlt(loglen(SERVER0), INDEX1) | ~committed(INDEX1, TERM0)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(loglen(s0) = i0) | ~committed(i2, t0) | ~indlt(i0, i2) | lte(t1, t0))
(learnt sym-boosted clause)
	(forall TERM0, SERVER0, INDEX1 . (lte(currentTerm(SERVER0), TERM0) | ~indlt(loglen(SERVER0), INDEX1) | ~committed(INDEX1, TERM0)))
---------------------------
(clause-type: univ)	(forall T0, S0, I1 . ((indlt(loglen(S0), I1) & committed(I1, T0)) -> lte(currentTerm(S0), T0)))
@  2250s  is global clause? No
@  2250s  Learning in F[3]: (forall T0, S0, I1 . ((indlt(loglen(S0), I1) & committed(I1, T0)) -> lte(currentTerm(S0), T0)))
@  2250s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t2
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2252s  F[2] /\ T /\ C+ ?
@  2252s  	Ans. UNSAT
@  2253s  F[3] unsat core #5 	(ucsz: 9 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i0)
	(log(s0, i0) = t0)
	(log(s2, i0) = t2)
	(loglen(s0) = i0)
	(termzero = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0))
(relations)
	loglen
	log
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER2, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@  2254s  antecedent: 5 -> 5

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER2, INDEX0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	SERVER2
	INDEX0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = termzero), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = termzero), ]
	SERVER1 -> [ (loglen(V:server:e9:) = INDEX0), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM1) -> [ SERVER2, ]
	(loglen(V:server:e9:) = INDEX0) -> [ SERVER1, ]
	((log(V:server:e9:, INDEX0) = termzero) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER1, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER2, loglen(SERVER0))
(cube eq: post)
	~(SERVER0 = SERVER1)
	(loglen(SERVER1) = loglen(SERVER0))
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~(termzero = log(SERVER2, loglen(SERVER0)))
	(log(SERVER0, loglen(SERVER0)) = termzero)
(qvars eq: post)
	SERVER2
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER2, SERVER1, SERVER0 . ((SERVER0 = SERVER1) | ~(loglen(SERVER1) = loglen(SERVER0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = log(SERVER2, loglen(SERVER0))) | ~(log(SERVER0, loglen(SERVER0)) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER1, SERVER0 . ((SERVER0 = SERVER1) | ~(loglen(SERVER1) = loglen(SERVER0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = log(SERVER2, loglen(SERVER0))) | ~(log(SERVER0, loglen(SERVER0)) = termzero)))
---------------------------
(clause-type: univ)	(forall S2, S1, S0 . (((loglen(S1) = loglen(S0)) & (log(S0, loglen(S0)) = termzero)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (termzero = log(S2, loglen(S0))))))
@  2254s  is global clause? No
@  2254s  Learning in F[3]: (forall S2, S1, S0 . (((loglen(S1) = loglen(S0)) & (log(S0, loglen(S0)) = termzero)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (termzero = log(S2, loglen(S0))))))
@  2254s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2255s  F[2] /\ T /\ C+ ?
@  2255s  	Ans. UNSAT
@  2255s  F[3] unsat core #6 	(ucsz: 9 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	(indzero = i1)
	(log(s2, i2) = t2)
	(termzero = t0)
	(currentTerm(s2) = t1)
	(log(s0, i0) = t0)
(clause)
	(~(currentTerm(s2) = t1) | ~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s2, i2) = t2) | ~(loglen(s0) = i0) | ~(termzero = t0))
(relations)
	loglen
	currentTerm
	indzero
	termzero
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(indzero = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(currentTerm(SERVER1) = TERM1)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER1, INDEX2) = TERM2)
(antecedent reduction)
@  2256s  antecedent: 8 -> 5 (reduced)
	removed: INDEX2
	removed: SERVER1
	removed: SERVER0

(eq map)
	TERM0 -> termzero
	INDEX1 -> indzero
(cube eq)
	(currentTerm(SERVER1) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX2) = TERM2)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	INDEX0
	INDEX2
	TERM1
	TERM2
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	-> ~(termzero = TERM2)
	-> ~(TERM1 = TERM2)
	index:e9:
	-> ~(INDEX0 = indzero)
(fullsorts)
	term:e9: -> [ termzero, TERM1, TERM2, ]
	index:e9: -> [ INDEX0, indzero, INDEX2, ]
qv2cubes #3
	TERM1 -> [ (currentTerm(SERVER1) = TERM1), ]
	termzero -> [ (log(SERVER0, INDEX0) = termzero), ]
	TERM2 -> [ (log(SERVER1, INDEX2) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ (currentTerm(SERVER1) = V:term:e9:), ]
	termzero -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM2 -> [ (log(SERVER1, INDEX2) = V:term:e9:), ]
ucubes2qv #3
	(log(SERVER1, INDEX2) = V:term:e9:) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ termzero, ]
	(currentTerm(SERVER1) = V:term:e9:) -> [ TERM1, ]
(partition) #3 term:e9: -> { TERM2, | termzero, | TERM1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ (log(SERVER1, INDEX2) = TERM2), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = termzero), ]
qv2ucubes #3
	INDEX2 -> [ (log(SERVER1, V:index:e9:) = TERM2), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER0, V:index:e9:) = termzero), ]
ucubes2qv #3
	true -> [ indzero, ]
	((log(SERVER0, V:index:e9:) = termzero) & (loglen(SERVER0) = V:index:e9:)) -> [ INDEX0, ]
	(log(SERVER1, V:index:e9:) = TERM2) -> [ INDEX2, ]
(partition) #3 index:e9: -> { indzero, | INDEX0, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> currentTerm(SERVER1)
	INDEX0 -> loglen(SERVER0)
	TERM2 -> log(SERVER1, INDEX2)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(loglen(SERVER0) = indzero)
	~(termzero = currentTerm(SERVER1))
	~(termzero = log(SERVER1, INDEX2))
	~(currentTerm(SERVER1) = log(SERVER1, INDEX2))
(qvars eq: post)
	INDEX2
	SERVER0
	SERVER1
(boosted clause)
	(forall INDEX2, SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = indzero) | (termzero = currentTerm(SERVER1)) | (termzero = log(SERVER1, INDEX2)) | (currentTerm(SERVER1) = log(SERVER1, INDEX2))))
---------------------------
(original clause)
	(~(currentTerm(s2) = t1) | ~(indzero = i1) | ~(log(s0, i0) = t0) | ~(log(s2, i2) = t2) | ~(loglen(s0) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall INDEX2, SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (loglen(SERVER0) = indzero) | (termzero = currentTerm(SERVER1)) | (termzero = log(SERVER1, INDEX2)) | (currentTerm(SERVER1) = log(SERVER1, INDEX2))))
---------------------------
(clause-type: univ)	(forall I2, S0, S1 . ((log(S0, loglen(S0)) = termzero) -> ((loglen(S0) = indzero) | (termzero = currentTerm(S1)) | (termzero = log(S1, I2)) | (currentTerm(S1) = log(S1, I2)))))
@  2256s  is global clause? No
@  2256s  Learning in F[3]: (forall I2, S0, S1 . ((log(S0, loglen(S0)) = termzero) -> ((loglen(S0) = indzero) | (termzero = currentTerm(S1)) | (termzero = log(S1, I2)) | (currentTerm(S1) = log(S1, I2)))))
@  2256s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2257s  F[2] /\ T /\ C+ ?
@  2258s  	Ans. UNSAT
@  2259s  F[3] unsat core #7 	(ucsz: 16 -> 13 -> 13 -> 11 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s1) = i0)
	(log(s1, i2) = t0)
	leader(s0)
	leader(s1)
	(log(s0, i0) = t2)
	(log(s2, i0) = t2)
(clause)
	(~(log(s0, i0) = t2) | ~(log(s1, i2) = t0) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~leader(s0) | ~leader(s1))
(relations)
	loglen
	log
	leader
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER2, INDEX0) = TERM1)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
	(log(SERVER0, INDEX0) = TERM1)
	leader(SERVER1)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@  2261s  antecedent: 7 -> 7

qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM1), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM1), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ leader(SERVER1), (log(SERVER1, INDEX1) = TERM0), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
	SERVER0 -> [ (log(V:server:e9:, INDEX0) = TERM1), leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), ]
	SERVER1 -> [ leader(V:server:e9:), (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX1) = TERM0), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX0) = TERM1) -> [ SERVER2, ]
	((log(V:server:e9:, INDEX0) = TERM1) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER0, ]
	((log(V:server:e9:, INDEX1) = TERM0) & (loglen(V:server:e9:) = INDEX0) & leader(V:server:e9:)) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM0 -> log(SERVER1, INDEX1)
	TERM1 -> log(SERVER2, loglen(SERVER0))
(cube eq: post)
	~(SERVER0 = SERVER1)
	(loglen(SERVER1) = loglen(SERVER0))
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	leader(SERVER0)
	~(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0)))
	leader(SERVER1)
	~(loglen(SERVER0) = INDEX1)
	(log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))
(qvars eq: post)
	SERVER2
	INDEX1
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | ~(loglen(SERVER1) = loglen(SERVER0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~leader(SERVER0) | (log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0))) | ~leader(SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(log(s0, i0) = t2) | ~(log(s1, i2) = t0) | ~(log(s2, i0) = t2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i0) | ~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | ~(loglen(SERVER1) = loglen(SERVER0)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | ~leader(SERVER0) | (log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER0))) | ~leader(SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER0, loglen(SERVER0)) = log(SERVER2, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S2, I1, S0, S1 . (((loglen(S1) = loglen(S0)) & leader(S0) & leader(S1) & (log(S0, loglen(S0)) = log(S2, loglen(S0)))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (log(S1, I1) = log(S2, loglen(S0))) | (loglen(S0) = I1))))
@  2261s  is global clause? No
@  2261s  Learning in F[3]: (forall S2, I1, S0, S1 . (((loglen(S1) = loglen(S0)) & leader(S0) & leader(S1) & (log(S0, loglen(S0)) = log(S2, loglen(S0)))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (log(S1, I1) = log(S2, loglen(S0))) | (loglen(S0) = I1))))
@  2261s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  2276s  F[2] /\ T /\ C+ ?
@  2276s  	Ans. UNSAT
@  2277s  F[3] unsat core #5 	(ucsz: 13 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	(log(s2, i1) = t0)
	(log(s0, i1) = t0)
	(loglen(s0) = i0)
	(termzero = t2)
(clause)
	(~(log(s0, i1) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~(termzero = t2) | ~leader(s0))
(relations)
	loglen
	log
	leader
	termzero
(cube: std)
	(termzero = TERM1)
	leader(SERVER0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
(antecedent reduction)
@  2278s  antecedent: 6 -> 6

(eq map)
	TERM1 -> termzero
(cube eq)
	leader(SERVER0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX1) = TERM0)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~(log(SERVER0, INDEX1) = termzero)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX1) = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~leader(SERVER0) | (log(SERVER0, INDEX1) = termzero) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER1, INDEX1) = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(log(s0, i1) = t0) | ~(log(s2, i1) = t0) | ~(loglen(s0) = i0) | ~(termzero = t2) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~leader(SERVER0) | (log(SERVER0, INDEX1) = termzero) | (SERVER0 = SERVER1) | (loglen(SERVER0) = INDEX1) | ~(log(SERVER1, INDEX1) = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((leader(S0) & (log(S1, I1) = log(S0, I1))) -> ((log(S0, I1) = termzero) | (S0 = S1) | (loglen(S0) = I1))))
@  2278s  is global clause? No
@  2278s  Learning in F[3]: (forall S0, S1, I1 . ((leader(S0) & (log(S1, I1) = log(S0, I1))) -> ((log(S0, I1) = termzero) | (S0 = S1) | (loglen(S0) = I1))))
@  2278s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false			--> modified
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = true
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2281s  F[2] /\ T /\ C+ ?
@  2281s  	Ans. UNSAT
@  2282s  F[3] unsat core #5 	(ucsz: 13 -> 11 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(loglen(s1) = i0)
	(log(s2, i2) = t2)
	(loglen(s0) = i1)
	(log(s1, i2) = t2)
	(termzero = t0)
(clause)
	(~(log(s1, i2) = t2) | ~(log(s2, i2) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~(termzero = t0))
(relations)
	loglen
	log
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER2, INDEX2) = TERM1)
	(log(SERVER1, INDEX2) = TERM1)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM0)
(antecedent reduction)
@  2283s  antecedent: 8 -> 7 (reduced)
	removed: SERVER0

(eq map)
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER2, INDEX2) = TERM1)
	(log(SERVER1, INDEX2) = TERM1)
	(loglen(SERVER1) = INDEX0)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	INDEX2
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER1 = SERVER2)
	index:e9:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX2) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
	SERVER1 -> [ (log(SERVER1, INDEX2) = TERM1), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX2) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER1 -> [ (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX2) = TERM1), ]
ucubes2qv #3
	((log(V:server:e9:, INDEX2) = TERM1) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER1, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER0, ]
	(log(V:server:e9:, INDEX2) = TERM1) -> [ SERVER2, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER0, | SERVER2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ (log(SERVER2, INDEX2) = TERM1), (log(SERVER1, INDEX2) = TERM1), ]
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
	INDEX1 -> [ (loglen(SERVER0) = INDEX1), ]
qv2ucubes #3
	INDEX2 -> [ (log(SERVER2, V:index:e9:) = TERM1), (log(SERVER1, V:index:e9:) = TERM1), ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e9:), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e9:), ]
ucubes2qv #3
	(loglen(SERVER0) = V:index:e9:) -> [ INDEX1, ]
	((log(SERVER1, V:index:e9:) = TERM1) & (log(SERVER2, V:index:e9:) = TERM1)) -> [ INDEX2, ]
	(loglen(SERVER1) = V:index:e9:) -> [ INDEX0, ]
(partition) #3 index:e9: -> { INDEX1, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER2, INDEX2)
	INDEX0 -> loglen(SERVER1)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(SERVER1 = SERVER2)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(loglen(SERVER1) = INDEX2)
	~(loglen(SERVER0) = INDEX2)
	~(termzero = log(SERVER2, INDEX2))
	(log(SERVER1, INDEX2) = log(SERVER2, INDEX2))
(qvars eq: post)
	SERVER2
	INDEX2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX2, SERVER0, SERVER1 . ((SERVER1 = SERVER2) | (loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | (loglen(SERVER0) = INDEX2) | (termzero = log(SERVER2, INDEX2)) | ~(log(SERVER1, INDEX2) = log(SERVER2, INDEX2))))
---------------------------
(original clause)
	(~(log(s1, i2) = t2) | ~(log(s2, i2) = t2) | ~(loglen(s0) = i1) | ~(loglen(s1) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX2, SERVER0, SERVER1 . ((SERVER1 = SERVER2) | (loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER1) = INDEX2) | (loglen(SERVER0) = INDEX2) | (termzero = log(SERVER2, INDEX2)) | ~(log(SERVER1, INDEX2) = log(SERVER2, INDEX2))))
---------------------------
(clause-type: univ)	(forall S2, I2, S0, S1 . ((log(S1, I2) = log(S2, I2)) -> ((S1 = S2) | (loglen(S1) = loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = I2) | (termzero = log(S2, I2)))))
@  2283s  is global clause? No
@  2283s  Learning in F[3]: (forall S2, I2, S0, S1 . ((log(S1, I2) = log(S2, I2)) -> ((S1 = S2) | (loglen(S1) = loglen(S0)) | (loglen(S1) = I2) | (loglen(S0) = I2) | (termzero = log(S2, I2)))))
@  2283s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t2
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t1
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = true
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  2286s  F[2] /\ T /\ C+ ?
@  2286s  	Ans. UNSAT
@  2286s  F[3] unsat core #4 	(ucsz: 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i0) = t0)
	(currentTerm(s0) = t2)
	(termzero = t1)
	(log(s0, i2) = t0)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i0) = t0) | ~(log(s0, i2) = t0) | ~(termzero = t1))
(relations)
	currentTerm
	termzero
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM2)
(antecedent reduction)
@  2287s  antecedent: 5 -> 5

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(currentTerm(SERVER0) = TERM2)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	TERM2
	SERVER0
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	-> ~(TERM0 = TERM2)
	-> ~(termzero = TERM2)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	term:e9: -> [ TERM0, termzero, TERM2, ]
qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), (log(SERVER0, INDEX1) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ (currentTerm(SERVER0) = V:term:e9:), ]
ucubes2qv #3
	true -> [ termzero, ]
	((log(SERVER0, INDEX0) = V:term:e9:) & (log(SERVER0, INDEX1) = V:term:e9:)) -> [ TERM0, ]
	(currentTerm(SERVER0) = V:term:e9:) -> [ TERM2, ]
(partition) #3 term:e9: -> { termzero, | TERM0, | TERM2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(INDEX0 = INDEX1)
	~(log(SERVER0, INDEX1) = currentTerm(SERVER0))
	(log(SERVER0, INDEX0) = log(SERVER0, INDEX1))
	~(log(SERVER0, INDEX1) = termzero)
	~(termzero = currentTerm(SERVER0))
(qvars eq: post)
	SERVER0
	INDEX0
	INDEX1
(boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | (log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~(log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX1) = termzero) | (termzero = currentTerm(SERVER0))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s0, i0) = t0) | ~(log(s0, i2) = t0) | ~(termzero = t1))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0, INDEX1 . ((INDEX0 = INDEX1) | (log(SERVER0, INDEX1) = currentTerm(SERVER0)) | ~(log(SERVER0, INDEX0) = log(SERVER0, INDEX1)) | (log(SERVER0, INDEX1) = termzero) | (termzero = currentTerm(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) -> ((I0 = I1) | (log(S0, I1) = currentTerm(S0)) | (log(S0, I1) = termzero) | (termzero = currentTerm(S0)))))
@  2287s  is global clause? No
@  2287s  Learning in F[3]: (forall S0, I0, I1 . ((log(S0, I0) = log(S0, I1)) -> ((I0 = I1) | (log(S0, I1) = currentTerm(S0)) | (log(S0, I1) = termzero) | (termzero = currentTerm(S0)))))
@  2287s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = true
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false			--> modified
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t2
	log(s0, i2) = t0
	log(s1, i0) = t1
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t1
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  2299s  F[2] /\ T /\ C+ ?
@  2299s  	Ans. UNSAT
@  2300s  F[3] unsat core #6 	(ucsz: 13 -> 11 -> 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(termzero = t2)
	(loglen(s1) = i0)
	leader(s0)
	(log(s0, i2) = t0)
	(loglen(s2) = i2)
	(log(s0, i0) = t0)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i2) = t0) | ~(loglen(s1) = i0) | ~(loglen(s2) = i2) | ~(termzero = t2) | ~leader(s0))
(relations)
	loglen
	log
	leader
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
	(termzero = TERM1)
	leader(SERVER0)
	(loglen(SERVER2) = INDEX1)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@  2301s  antecedent: 7 -> 4 (reduced)
	removed: SERVER2
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM1 -> termzero
(cube eq)
	leader(SERVER0)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
	(loglen(SERVER2) = INDEX1)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX1), ]
	SERVER0 -> [ leader(SERVER0), (log(SERVER0, INDEX0) = TERM0), (log(SERVER0, INDEX1) = TERM0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER0 -> [ leader(V:server:e9:), (log(V:server:e9:, INDEX1) = TERM0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (loglen(V:server:e9:) = INDEX0), ]
ucubes2qv #3
	((log(V:server:e9:, INDEX0) = TERM0) & (log(V:server:e9:, INDEX1) = TERM0) & leader(V:server:e9:)) -> [ SERVER0, ]
	(loglen(V:server:e9:) = INDEX0) -> [ SERVER1, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER2, ]
(partition) #3 server:e9: -> { SERVER0, | SERVER1, | SERVER2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER0, loglen(SERVER2))
	INDEX0 -> loglen(SERVER1)
	INDEX1 -> loglen(SERVER2)
(cube eq: post)
	leader(SERVER0)
	~(loglen(SERVER1) = loglen(SERVER2))
	(log(SERVER0, loglen(SERVER1)) = log(SERVER0, loglen(SERVER2)))
	~(log(SERVER0, loglen(SERVER2)) = termzero)
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~leader(SERVER0) | (loglen(SERVER1) = loglen(SERVER2)) | ~(log(SERVER0, loglen(SERVER1)) = log(SERVER0, loglen(SERVER2))) | (log(SERVER0, loglen(SERVER2)) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i2) = t0) | ~(loglen(s1) = i0) | ~(loglen(s2) = i2) | ~(termzero = t2) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~leader(SERVER0) | (loglen(SERVER1) = loglen(SERVER2)) | ~(log(SERVER0, loglen(SERVER1)) = log(SERVER0, loglen(SERVER2))) | (log(SERVER0, loglen(SERVER2)) = termzero)))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . ((leader(S0) & (log(S0, loglen(S1)) = log(S0, loglen(S2)))) -> ((loglen(S1) = loglen(S2)) | (log(S0, loglen(S2)) = termzero))))
@  2301s  is global clause? No
@  2301s  Learning in F[3]: (forall S2, S0, S1 . ((leader(S0) & (log(S0, loglen(S1)) = log(S0, loglen(S2)))) -> ((loglen(S1) = loglen(S2)) | (log(S0, loglen(S2)) = termzero))))
@  2301s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2302s  F[2] /\ T /\ C+ ?
@  2302s  	Ans. UNSAT
@  2304s  F[3] unsat core #8 	(ucsz: 16 -> 12 -> 11 -> 10 -> 9 -> 8 -> 8)
(minimal unsat core)
	(indzero = i2)
	(loglen(s0) = i0)
	(loglen(s2) = i0)
	~leader(s1)
	~lte(t2, t1)
	(log(s1, i1) = t1)
	(log(s0, i0) = t0)
	(log(s2, i0) = t1)
(clause)
	(~(indzero = i2) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | leader(s1) | lte(t2, t1))
(relations)
	loglen
	indzero
	log
	leader
	lte
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	~lte(TERM2, TERM1)
	(log(SERVER2, INDEX0) = TERM1)
	(log(SERVER1, INDEX1) = TERM1)
	~leader(SERVER1)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX2)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@  2305s  antecedent: 9 -> 9

(eq map)
	INDEX2 -> indzero
(cube eq)
	~lte(TERM2, TERM1)
	(log(SERVER2, INDEX0) = TERM1)
	(log(SERVER1, INDEX1) = TERM1)
	~leader(SERVER1)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = TERM0)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	TERM0
	TERM1
	TERM2
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = TERM1)
	-> ~(TERM0 = TERM2)
	-> ~(TERM1 = TERM2)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
	index:e9:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = indzero)
	-> ~(INDEX1 = indzero)
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, indzero, ]
qv2cubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM2, TERM1), (log(SERVER2, INDEX0) = TERM1), (log(SERVER1, INDEX1) = TERM1), ]
	TERM2 -> [ ~lte(TERM2, TERM1), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
	TERM1 -> [ ~lte(TERM2, V:term:e9:), (log(SERVER2, INDEX0) = V:term:e9:), (log(SERVER1, INDEX1) = V:term:e9:), ]
	TERM2 -> [ ~lte(V:term:e9:, TERM1), ]
ucubes2qv #3
	((log(SERVER1, INDEX1) = V:term:e9:) & (log(SERVER2, INDEX0) = V:term:e9:) & ~lte(TERM2, V:term:e9:)) -> [ TERM1, ]
	~lte(V:term:e9:, TERM1) -> [ TERM2, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { TERM1, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM1), (loglen(SERVER2) = INDEX0), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM0), (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM1), ~leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM1), (loglen(V:server:e9:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = TERM0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX1) = TERM1), ~leader(V:server:e9:), ]
ucubes2qv #3
	((log(V:server:e9:, INDEX1) = TERM1) & ~leader(V:server:e9:)) -> [ SERVER1, ]
	((log(V:server:e9:, INDEX0) = TERM1) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER2, ]
	((log(V:server:e9:, INDEX0) = TERM0) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER2, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	indzero -> [ ]
	INDEX0 -> [ (log(SERVER0, INDEX0) = TERM0), (log(SERVER2, INDEX0) = TERM1), (loglen(SERVER0) = INDEX0), (loglen(SERVER2) = INDEX0), ]
	INDEX1 -> [ (log(SERVER1, INDEX1) = TERM1), ]
qv2ucubes #3
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER2, V:index:e9:) = TERM1), (log(SERVER0, V:index:e9:) = TERM0), (loglen(SERVER2) = V:index:e9:), ]
	INDEX1 -> [ (log(SERVER1, V:index:e9:) = TERM1), ]
ucubes2qv #3
	true -> [ indzero, ]
	(log(SERVER1, V:index:e9:) = TERM1) -> [ INDEX1, ]
	((log(SERVER0, V:index:e9:) = TERM0) & (log(SERVER2, V:index:e9:) = TERM1) & (loglen(SERVER0) = V:index:e9:) & (loglen(SERVER2) = V:index:e9:)) -> [ INDEX0, ]
(partition) #3 index:e9: -> { indzero, | INDEX1, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER2)
	TERM0 -> log(SERVER0, loglen(SERVER2))
	TERM1 -> log(SERVER2, loglen(SERVER2))
(cube eq: post)
	~(SERVER0 = SERVER1)
	(loglen(SERVER0) = loglen(SERVER2))
	~(SERVER0 = SERVER2)
	~(SERVER1 = SERVER2)
	~(INDEX1 = indzero)
	~leader(SERVER1)
	~(log(SERVER0, loglen(SERVER2)) = log(SERVER2, loglen(SERVER2)))
	~lte(TERM2, log(SERVER2, loglen(SERVER2)))
	(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER2)))
	~(loglen(SERVER2) = INDEX1)
	~(log(SERVER0, loglen(SERVER2)) = TERM2)
	~(log(SERVER2, loglen(SERVER2)) = TERM2)
	~(loglen(SERVER2) = indzero)
(qvars eq: post)
	SERVER2
	INDEX1
	TERM2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX1, TERM2, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (INDEX1 = indzero) | leader(SERVER1) | (log(SERVER0, loglen(SERVER2)) = log(SERVER2, loglen(SERVER2))) | lte(TERM2, log(SERVER2, loglen(SERVER2))) | ~(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER2))) | (loglen(SERVER2) = INDEX1) | (log(SERVER0, loglen(SERVER2)) = TERM2) | (log(SERVER2, loglen(SERVER2)) = TERM2) | (loglen(SERVER2) = indzero)))
---------------------------
(original clause)
	(~(indzero = i2) | ~(log(s0, i0) = t0) | ~(log(s1, i1) = t1) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~(loglen(s2) = i0) | leader(s1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX1, TERM2, SERVER0, SERVER1 . ((SERVER0 = SERVER1) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (INDEX1 = indzero) | leader(SERVER1) | (log(SERVER0, loglen(SERVER2)) = log(SERVER2, loglen(SERVER2))) | lte(TERM2, log(SERVER2, loglen(SERVER2))) | ~(log(SERVER1, INDEX1) = log(SERVER2, loglen(SERVER2))) | (loglen(SERVER2) = INDEX1) | (log(SERVER0, loglen(SERVER2)) = TERM2) | (log(SERVER2, loglen(SERVER2)) = TERM2) | (loglen(SERVER2) = indzero)))
---------------------------
(clause-type: univ)	(forall S2, I1, T2, S0, S1 . (((loglen(S0) = loglen(S2)) & (log(S1, I1) = log(S2, loglen(S2)))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (I1 = indzero) | leader(S1) | (log(S0, loglen(S2)) = log(S2, loglen(S2))) | lte(T2, log(S2, loglen(S2))) | (loglen(S2) = I1) | (log(S0, loglen(S2)) = T2) | (log(S2, loglen(S2)) = T2) | (loglen(S2) = indzero))))
@  2305s  is global clause? No
@  2305s  Learning in F[3]: (forall S2, I1, T2, S0, S1 . (((loglen(S0) = loglen(S2)) & (log(S1, I1) = log(S2, loglen(S2)))) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (I1 = indzero) | leader(S1) | (log(S0, loglen(S2)) = log(S2, loglen(S2))) | lte(T2, log(S2, loglen(S2))) | (loglen(S2) = I1) | (log(S0, loglen(S2)) = T2) | (log(S2, loglen(S2)) = T2) | (loglen(S2) = indzero))))
@  2305s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2309s  F[2] /\ T /\ C+ ?
@  2309s  	Ans. UNSAT
@  2310s  F[3] unsat core #6 	(ucsz: 6 -> 6)
(minimal unsat core)
	(log(s2, i0) = t0)
	(loglen(s2) = i0)
	(indzero = i1)
	(termzero = t0)
	(loglen(s1) = i2)
	(log(s1, i2) = t0)
(clause)
	(~(indzero = i1) | ~(log(s1, i2) = t0) | ~(log(s2, i0) = t0) | ~(loglen(s1) = i2) | ~(loglen(s2) = i0) | ~(termzero = t0))
(relations)
	loglen
	indzero
	log
	termzero
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(indzero = INDEX1)
	(log(SERVER1, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX2)
	(termzero = TERM0)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX2) = TERM0)
(antecedent reduction)
@  2310s  antecedent: 5 -> 3 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM0 -> termzero
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER0) = INDEX2)
	(log(SERVER0, INDEX2) = termzero)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER1, INDEX0) = termzero)
(qvars eq)
	INDEX0
	INDEX2
	SERVER0
	SERVER1
(antecedent eq)
	index:e9:
	-> ~(INDEX0 = indzero)
	-> ~(INDEX0 = INDEX2)
	-> ~(indzero = INDEX2)
(fullsorts)
	index:e9: -> [ INDEX0, indzero, INDEX2, ]
qv2cubes #3
	INDEX2 -> [ (loglen(SERVER0) = INDEX2), (log(SERVER0, INDEX2) = termzero), ]
	indzero -> [ ]
	INDEX0 -> [ (log(SERVER1, INDEX0) = termzero), (loglen(SERVER1) = INDEX0), ]
qv2ucubes #3
	INDEX2 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER0, V:index:e9:) = termzero), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e9:), (log(SERVER1, V:index:e9:) = termzero), ]
ucubes2qv #3
	((log(SERVER0, V:index:e9:) = termzero) & (loglen(SERVER0) = V:index:e9:)) -> [ INDEX2, ]
	((log(SERVER1, V:index:e9:) = termzero) & (loglen(SERVER1) = V:index:e9:)) -> [ INDEX0, ]
	true -> [ indzero, ]
(partition) #3 index:e9: -> { INDEX2, | INDEX0, | indzero, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX2 -> loglen(SERVER0)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	(log(SERVER1, loglen(SERVER1)) = termzero)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(loglen(SERVER1) = indzero)
	~(indzero = loglen(SERVER0))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~(log(SERVER1, loglen(SERVER1)) = termzero) | (loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER1) = indzero) | (indzero = loglen(SERVER0))))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s1, i2) = t0) | ~(log(s2, i0) = t0) | ~(loglen(s1) = i2) | ~(loglen(s2) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | ~(log(SERVER1, loglen(SERVER1)) = termzero) | (loglen(SERVER1) = loglen(SERVER0)) | (loglen(SERVER1) = indzero) | (indzero = loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall S0, S1 . (((log(S0, loglen(S0)) = termzero) & (log(S1, loglen(S1)) = termzero)) -> ((loglen(S1) = loglen(S0)) | (loglen(S1) = indzero) | (indzero = loglen(S0)))))
@  2310s  is global clause? No
@  2310s  Learning in F[3]: (forall S0, S1 . (((log(S0, loglen(S0)) = termzero) & (log(S1, loglen(S1)) = termzero)) -> ((loglen(S1) = loglen(S0)) | (loglen(S1) = indzero) | (indzero = loglen(S0)))))
@  2310s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  2313s  F[2] /\ T /\ C+ ?
@  2313s  	Ans. UNSAT
@  2314s  F[3] unsat core #5 	(ucsz: 14 -> 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	(log(s0, i0) = t2)
	(termzero = t1)
	(currentTerm(s0) = t0)
	~succ(i1, i0)
	(indzero = i1)
(clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i1) | ~(log(s0, i0) = t2) | ~(termzero = t1) | succ(i1, i0))
(relations)
	currentTerm
	indzero
	termzero
	succ
	log
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	(termzero = TERM1)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX0) = TERM2)
	(indzero = INDEX1)
	~succ(INDEX1, INDEX0)
(antecedent reduction)
@  2315s  antecedent: 5 -> 3 (reduced)
	removed: INDEX1
	removed: INDEX0

(eq map)
	TERM1 -> termzero
	INDEX1 -> indzero
(cube eq)
	~succ(indzero, INDEX0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER0, INDEX0) = TERM2)
(qvars eq)
	INDEX0
	TERM0
	TERM2
	SERVER0
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	-> ~(TERM0 = TERM2)
	-> ~(termzero = TERM2)
(fullsorts)
	term:e9: -> [ TERM0, termzero, TERM2, ]
qv2cubes #3
	TERM0 -> [ (currentTerm(SERVER0) = TERM0), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ (currentTerm(SERVER0) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ (log(SERVER0, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	true -> [ termzero, ]
	(log(SERVER0, INDEX0) = V:term:e9:) -> [ TERM2, ]
	(currentTerm(SERVER0) = V:term:e9:) -> [ TERM0, ]
(partition) #3 term:e9: -> { termzero, | TERM2, | TERM0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> currentTerm(SERVER0)
	TERM2 -> log(SERVER0, INDEX0)
(cube eq: post)
	~succ(indzero, INDEX0)
	~(currentTerm(SERVER0) = log(SERVER0, INDEX0))
	~(termzero = log(SERVER0, INDEX0))
	~(currentTerm(SERVER0) = termzero)
(qvars eq: post)
	SERVER0
	INDEX0
(boosted clause)
	(forall SERVER0, INDEX0 . (succ(indzero, INDEX0) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(indzero = i1) | ~(log(s0, i0) = t2) | ~(termzero = t1) | succ(i1, i0))
(learnt sym-boosted clause)
	(forall SERVER0, INDEX0 . (succ(indzero, INDEX0) | (currentTerm(SERVER0) = log(SERVER0, INDEX0)) | (termzero = log(SERVER0, INDEX0)) | (currentTerm(SERVER0) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, I0 . (succ(indzero, I0) | (currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0)) | (currentTerm(S0) = termzero)))
@  2315s  is global clause? No
@  2315s  Learning in F[3]: (forall S0, I0 . (succ(indzero, I0) | (currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0)) | (currentTerm(S0) = termzero)))
@  2315s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = true
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = false
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = true
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = false
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = true
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2325s  F[2] /\ T /\ C+ ?
@  2325s  	Ans. UNSAT
@  2326s  F[3] unsat core #6 	(ucsz: 13 -> 10 -> 7 -> 6 -> 6)
(minimal unsat core)
	(loglen(s0) = i0)
	(loglen(s2) = i0)
	(indzero = i1)
	(termzero = t0)
	(loglen(s1) = i1)
	(log(s0, i0) = t0)
(clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~(loglen(s2) = i0) | ~(termzero = t0))
(relations)
	loglen
	indzero
	log
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(indzero = INDEX1)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(log(SERVER0, INDEX0) = TERM0)
(antecedent reduction)
@  2327s  antecedent: 5 -> 4 (reduced)
	removed: SERVER1

(eq map)
	TERM0 -> termzero
	INDEX1 -> indzero
(cube eq)
	(loglen(SERVER1) = indzero)
	(loglen(SERVER2) = INDEX0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	SERVER2
	INDEX0
	SERVER0
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER0 = SERVER2)
	index:e9:
	-> ~(INDEX0 = indzero)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), (log(SERVER0, INDEX0) = termzero), ]
	SERVER1 -> [ (loglen(SERVER1) = indzero), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX0), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX0), (log(V:server:e9:, INDEX0) = termzero), ]
	SERVER1 -> [ (loglen(V:server:e9:) = indzero), ]
ucubes2qv #3
	(loglen(V:server:e9:) = indzero) -> [ SERVER1, ]
	(loglen(V:server:e9:) = INDEX0) -> [ SERVER2, ]
	((log(V:server:e9:, INDEX0) = termzero) & (loglen(V:server:e9:) = INDEX0)) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER1, | SERVER2, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER2)
(cube eq: post)
	(loglen(SERVER1) = indzero)
	~(loglen(SERVER2) = indzero)
	(loglen(SERVER0) = loglen(SERVER2))
	~(SERVER0 = SERVER2)
	(log(SERVER0, loglen(SERVER2)) = termzero)
(qvars eq: post)
	SERVER2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~(loglen(SERVER1) = indzero) | (loglen(SERVER2) = indzero) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | ~(log(SERVER0, loglen(SERVER2)) = termzero)))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~(loglen(s2) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER2, SERVER0, SERVER1 . (~(loglen(SERVER1) = indzero) | (loglen(SERVER2) = indzero) | ~(loglen(SERVER0) = loglen(SERVER2)) | (SERVER0 = SERVER2) | ~(log(SERVER0, loglen(SERVER2)) = termzero)))
---------------------------
(clause-type: univ)	(forall S2, S0, S1 . (((loglen(S1) = indzero) & (loglen(S0) = loglen(S2)) & (log(S0, loglen(S2)) = termzero)) -> ((loglen(S2) = indzero) | (S0 = S2))))
@  2327s  is global clause? No
@  2327s  Learning in F[3]: (forall S2, S0, S1 . (((loglen(S1) = indzero) & (loglen(S0) = loglen(S2)) & (log(S0, loglen(S2)) = termzero)) -> ((loglen(S2) = indzero) | (S0 = S2))))
@  2327s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = true
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false			--> modified
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t1
	log(s2, i1) = t1
	log(s2, i2) = t0
	loglen(s0) = i1
	loglen(s1) = i1
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  2328s  F[2] /\ T /\ C+ ?
@  2328s  	Ans. UNSAT
@  2329s  F[3] unsat core #6 	(ucsz: 12 -> 10 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(log(s2, i2) = t0)
	(loglen(s0) = i1)
	~succ(i0, i1)
	(termzero = t1)
	(log(s0, i1) = t1)
	(log(s1, i1) = t0)
(clause)
	(~(log(s0, i1) = t1) | ~(log(s1, i1) = t0) | ~(log(s2, i2) = t0) | ~(loglen(s0) = i1) | ~(termzero = t1) | succ(i0, i1))
(relations)
	loglen
	log
	succ
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	~succ(INDEX0, INDEX1)
	(termzero = TERM1)
	(log(SERVER1, INDEX1) = TERM0)
	(log(SERVER0, INDEX1) = TERM1)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER2, INDEX2) = TERM0)
(antecedent reduction)
@  2331s  antecedent: 8 -> 5 (reduced)
	removed: SERVER2
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER2, INDEX2) = TERM0)
	(log(SERVER1, INDEX1) = TERM0)
	(loglen(SERVER0) = INDEX1)
	~succ(INDEX0, INDEX1)
	(log(SERVER0, INDEX1) = termzero)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	INDEX2
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	index:e9:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = INDEX2)
	-> ~(INDEX1 = INDEX2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX2) = TERM0), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), (log(SERVER0, INDEX1) = termzero), ]
	SERVER1 -> [ (log(SERVER1, INDEX1) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX2) = TERM0), ]
	SERVER0 -> [ (log(V:server:e9:, INDEX1) = termzero), (loglen(V:server:e9:) = INDEX1), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX1) = TERM0), ]
ucubes2qv #3
	(log(V:server:e9:, INDEX2) = TERM0) -> [ SERVER2, ]
	((log(V:server:e9:, INDEX1) = termzero) & (loglen(V:server:e9:) = INDEX1)) -> [ SERVER0, ]
	(log(V:server:e9:, INDEX1) = TERM0) -> [ SERVER1, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER0, | SERVER1, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	INDEX2 -> [ (log(SERVER2, INDEX2) = TERM0), ]
	INDEX0 -> [ ~succ(INDEX0, INDEX1), ]
	INDEX1 -> [ (log(SERVER0, INDEX1) = termzero), (loglen(SERVER0) = INDEX1), (log(SERVER1, INDEX1) = TERM0), ~succ(INDEX0, INDEX1), ]
qv2ucubes #3
	INDEX2 -> [ (log(SERVER2, V:index:e9:) = TERM0), ]
	INDEX0 -> [ ~succ(V:index:e9:, INDEX1), ]
	INDEX1 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER0, V:index:e9:) = termzero), (log(SERVER1, V:index:e9:) = TERM0), ~succ(INDEX0, V:index:e9:), ]
ucubes2qv #3
	~succ(V:index:e9:, INDEX1) -> [ INDEX0, ]
	((log(SERVER0, V:index:e9:) = termzero) & (log(SERVER1, V:index:e9:) = TERM0) & (loglen(SERVER0) = V:index:e9:) & ~succ(INDEX0, V:index:e9:)) -> [ INDEX1, ]
	(log(SERVER2, V:index:e9:) = TERM0) -> [ INDEX2, ]
(partition) #3 index:e9: -> { INDEX0, | INDEX1, | INDEX2, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER1, loglen(SERVER0))
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX0 = INDEX2)
	~(loglen(SERVER0) = INDEX2)
	~succ(INDEX0, loglen(SERVER0))
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(INDEX0 = loglen(SERVER0))
	(log(SERVER2, INDEX2) = log(SERVER1, loglen(SERVER0)))
	~(log(SERVER1, loglen(SERVER0)) = termzero)
(qvars eq: post)
	SERVER2
	INDEX0
	INDEX2
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX0, INDEX2, SERVER0, SERVER1 . ((INDEX0 = INDEX2) | (loglen(SERVER0) = INDEX2) | succ(INDEX0, loglen(SERVER0)) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (INDEX0 = loglen(SERVER0)) | ~(log(SERVER2, INDEX2) = log(SERVER1, loglen(SERVER0))) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i1) = t1) | ~(log(s1, i1) = t0) | ~(log(s2, i2) = t0) | ~(loglen(s0) = i1) | ~(termzero = t1) | succ(i0, i1))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX0, INDEX2, SERVER0, SERVER1 . ((INDEX0 = INDEX2) | (loglen(SERVER0) = INDEX2) | succ(INDEX0, loglen(SERVER0)) | ~(log(SERVER0, loglen(SERVER0)) = termzero) | (INDEX0 = loglen(SERVER0)) | ~(log(SERVER2, INDEX2) = log(SERVER1, loglen(SERVER0))) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(clause-type: univ)	(forall S2, I0, I2, S0, S1 . (((log(S0, loglen(S0)) = termzero) & (log(S2, I2) = log(S1, loglen(S0)))) -> ((I0 = I2) | (loglen(S0) = I2) | succ(I0, loglen(S0)) | (I0 = loglen(S0)) | (log(S1, loglen(S0)) = termzero))))
@  2331s  is global clause? No
@  2331s  Learning in F[3]: (forall S2, I0, I2, S0, S1 . (((log(S0, loglen(S0)) = termzero) & (log(S2, I2) = log(S1, loglen(S0)))) -> ((I0 = I2) | (loglen(S0) = I2) | succ(I0, loglen(S0)) | (I0 = loglen(S0)) | (log(S1, loglen(S0)) = termzero))))
@  2331s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = true
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false			--> modified
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t2
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t1
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i1
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t2

@  2333s  F[2] /\ T /\ C+ ?
@  2333s  	Ans. UNSAT
@  2333s  F[3] unsat core #5 	(ucsz: 9 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	(loglen(s2) = i0)
	(loglen(s0) = i1)
	(log(s2, i1) = t0)
	(termzero = t2)
(clause)
	(~(log(s2, i1) = t0) | ~(loglen(s0) = i1) | ~(loglen(s2) = i0) | ~(termzero = t2) | ~leader(s0))
(relations)
	loglen
	log
	leader
	termzero
(cube: std)
	(termzero = TERM1)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@  2334s  antecedent: 6 -> 4 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map)
	TERM1 -> termzero
(cube eq)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX1)
	(log(SERVER1, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	TERM0 -> log(SERVER1, loglen(SERVER0))
	INDEX0 -> loglen(SERVER1)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	~(loglen(SERVER1) = loglen(SERVER0))
	~(log(SERVER1, loglen(SERVER0)) = termzero)
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(original clause)
	(~(log(s2, i1) = t0) | ~(loglen(s0) = i1) | ~(loglen(s2) = i0) | ~(termzero = t2) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (loglen(SERVER1) = loglen(SERVER0)) | (log(SERVER1, loglen(SERVER0)) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, S1 . (leader(S0) -> ((loglen(S1) = loglen(S0)) | (log(S1, loglen(S0)) = termzero))))
@  2334s  is global clause? No
@  2334s  Learning in F[3]: (forall S0, S1 . (leader(S0) -> ((loglen(S1) = loglen(S0)) | (log(S1, loglen(S0)) = termzero))))
@  2334s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = true
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false			--> modified
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t0
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t1
	log(s0, i2) = t1
	log(s1, i0) = t1
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t2
	log(s2, i1) = t1
	log(s2, i2) = t1
	loglen(s0) = i2
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = false
	lte(t0, t2) = false
	lte(t1, t0) = true
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = true
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t1

@  2336s  F[2] /\ T /\ C+ ?
@  2337s  	Ans. UNSAT
@  2339s  F[3] unsat core #7 	(ucsz: 20 -> 17 -> 16 -> 14 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 7)
(minimal unsat core)
	~lte(t0, t2)
	(currentTerm(s0) = t0)
	member(s2, q0)
	member(s2, q1)
	(termzero = t1)
	(log(s2, i0) = t2)
	(log(s1, i0) = t1)
(clause)
	(~(currentTerm(s0) = t0) | ~(log(s1, i0) = t1) | ~(log(s2, i0) = t2) | ~(termzero = t1) | ~member(s2, q0) | ~member(s2, q1) | lte(t0, t2))
(relations)
	member
	currentTerm
	log
	lte
	termzero
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
(cube: std)
	(log(SERVER2, INDEX0) = TERM2)
	(termzero = TERM1)
	member(SERVER2, QUORUM0)
	(currentTerm(SERVER0) = TERM0)
	(log(SERVER1, INDEX0) = TERM1)
	~lte(TERM0, TERM2)
	member(SERVER2, QUORUM1)
(antecedent reduction)
@  2341s  antecedent: 8 -> 7 (reduced)
	removed: TERM0

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER2, INDEX0) = TERM2)
	member(SERVER2, QUORUM0)
	(log(SERVER1, INDEX0) = termzero)
	(currentTerm(SERVER0) = TERM0)
	~lte(TERM0, TERM2)
	member(SERVER2, QUORUM1)
(qvars eq)
	SERVER2
	INDEX0
	TERM0
	TERM2
	QUORUM0
	QUORUM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM2)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
	quorum:e9:
	-> ~(QUORUM0 = QUORUM1)
(fullsorts)
	term:e9: -> [ TERM0, termzero, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	quorum:e9: -> [ QUORUM0, QUORUM1, ]
qv2cubes #3
	TERM0 -> [ (currentTerm(SERVER0) = TERM0), ~lte(TERM0, TERM2), ]
	termzero -> [ (log(SERVER1, INDEX0) = termzero), ]
	TERM2 -> [ ~lte(TERM0, TERM2), (log(SERVER2, INDEX0) = TERM2), ]
qv2ucubes #3
	TERM0 -> [ ~lte(V:term:e9:, TERM2), (currentTerm(SERVER0) = V:term:e9:), ]
	termzero -> [ (log(SERVER1, INDEX0) = V:term:e9:), ]
	TERM2 -> [ ~lte(TERM0, V:term:e9:), (log(SERVER2, INDEX0) = V:term:e9:), ]
ucubes2qv #3
	((log(SERVER2, INDEX0) = V:term:e9:) & ~lte(TERM0, V:term:e9:)) -> [ TERM2, ]
	((currentTerm(SERVER0) = V:term:e9:) & ~lte(V:term:e9:, TERM2)) -> [ TERM0, ]
	(log(SERVER1, INDEX0) = V:term:e9:) -> [ termzero, ]
(partition) #3 term:e9: -> { TERM2, | TERM0, | termzero, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	SERVER2 -> [ member(SERVER2, QUORUM1), member(SERVER2, QUORUM0), (log(SERVER2, INDEX0) = TERM2), ]
	SERVER0 -> [ (currentTerm(SERVER0) = TERM0), ]
	SERVER1 -> [ (log(SERVER1, INDEX0) = termzero), ]
qv2ucubes #3
	SERVER2 -> [ member(V:server:e9:, QUORUM0), (log(V:server:e9:, INDEX0) = TERM2), member(V:server:e9:, QUORUM1), ]
	SERVER0 -> [ (currentTerm(V:server:e9:) = TERM0), ]
	SERVER1 -> [ (log(V:server:e9:, INDEX0) = termzero), ]
ucubes2qv #3
	(currentTerm(V:server:e9:) = TERM0) -> [ SERVER0, ]
	(log(V:server:e9:, INDEX0) = termzero) -> [ SERVER1, ]
	((log(V:server:e9:, INDEX0) = TERM2) & member(V:server:e9:, QUORUM0) & member(V:server:e9:, QUORUM1)) -> [ SERVER2, ]
(partition) #3 server:e9: -> { SERVER0, | SERVER1, | SERVER2, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #2
	QUORUM0 -> [ member(SERVER2, QUORUM0), ]
	QUORUM1 -> [ member(SERVER2, QUORUM1), ]
qv2ucubes #2
	QUORUM0 -> [ member(SERVER2, V:quorum:e9:), ]
	QUORUM1 -> [ member(SERVER2, V:quorum:e9:), ]
ucubes2qv #1
	member(SERVER2, V:quorum:e9:) -> [ QUORUM0, QUORUM1, ]
(partition) #1 quorum:e9: -> { QUORUM0, QUORUM1, | }
	#0 singles, #1 multiples (out of #1 cells)
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: index -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> index)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: term -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> term)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
	(epr check: forward)	allowed(arc: server -> quorum)? False
	(epr check: reverse)	allowed(arc: quorum -> server)? True
(epr reduced)
	(exists QUORUM0 . (forall SERVER2, INDEX0, TERM0, TERM2, SERVER0, SERVER1 . (~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX0) = termzero) | ~(log(SERVER2, INDEX0) = TERM2) | ~member(SERVER2, QUORUM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = TERM2) | lte(TERM0, TERM2))))
(non-epr version)
	(forall SERVER2, INDEX0, TERM0, TERM2, SERVER0, SERVER1 . (exists QUORUM0 . (~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX0) = termzero) | ~(log(SERVER2, INDEX0) = TERM2) | ~member(SERVER2, QUORUM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = TERM2) | lte(TERM0, TERM2))))
(epr-reduction) -> UNSAT
(boosted clause)
	(exists QUORUM0 . (forall SERVER2, INDEX0, TERM0, TERM2, SERVER0, SERVER1 . (~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX0) = termzero) | ~(log(SERVER2, INDEX0) = TERM2) | ~member(SERVER2, QUORUM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = TERM2) | lte(TERM0, TERM2))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t0) | ~(log(s1, i0) = t1) | ~(log(s2, i0) = t2) | ~(termzero = t1) | ~member(s2, q0) | ~member(s2, q1) | lte(t0, t2))
(learnt sym-boosted clause)
	(exists QUORUM0 . (forall SERVER2, INDEX0, TERM0, TERM2, SERVER0, SERVER1 . (~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX0) = termzero) | ~(log(SERVER2, INDEX0) = TERM2) | ~member(SERVER2, QUORUM0) | (SERVER0 = SERVER1) | (SERVER0 = SERVER2) | (SERVER1 = SERVER2) | (termzero = TERM2) | lte(TERM0, TERM2))))
---------------------------
(clause-type: epr)	(exists Q0 . (forall S2, I0, T0, T2, S0, S1 . (((currentTerm(S0) = T0) & (log(S1, I0) = termzero) & (log(S2, I0) = T2) & member(S2, Q0)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (termzero = T2) | lte(T0, T2)))))
@  2348s  is global clause? No
@  2348s  Learning in F[3]: (exists Q0 . (forall S2, I0, T0, T2, S0, S1 . (((currentTerm(S0) = T0) & (log(S1, I0) = termzero) & (log(S2, I0) = T2) & member(S2, Q0)) -> ((S0 = S1) | (S0 = S2) | (S1 = S2) | (termzero = T2) | lte(T0, T2)))))
@  2348s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = true
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false			--> modified
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t0
	leader(s0) = true
	leader(s1) = true
	leader(s2) = false
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2360s  F[2] /\ T /\ C+ ?
@  2361s  	Ans. UNSAT
@  2362s  F[3] unsat core #6 	(ucsz: 15 -> 9 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	~succ(i0, i2)
	(log(s1, i2) = t1)
	~succ(i1, i2)
	leader(s0)
	(loglen(s0) = i2)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i2) | ~leader(s0) | succ(i0, i2) | succ(i1, i2))
(relations)
	loglen
	succ
	log
	leader
	currentTerm
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	leader(SERVER0)
	(loglen(SERVER0) = INDEX2)
	(currentTerm(SERVER0) = TERM0)
	~succ(INDEX1, INDEX2)
	~succ(INDEX0, INDEX2)
	(log(SERVER1, INDEX2) = TERM0)
(antecedent reduction)
@  2364s  antecedent: 5 -> 5

qv2cubes #3
	INDEX2 -> [ (loglen(SERVER0) = INDEX2), ~succ(INDEX1, INDEX2), ~succ(INDEX0, INDEX2), (log(SERVER1, INDEX2) = TERM0), ]
	INDEX0 -> [ ~succ(INDEX0, INDEX2), ]
	INDEX1 -> [ ~succ(INDEX1, INDEX2), ]
qv2ucubes #3
	INDEX2 -> [ (loglen(SERVER0) = V:index:e9:), ~succ(INDEX0, V:index:e9:), ~succ(INDEX1, V:index:e9:), (log(SERVER1, V:index:e9:) = TERM0), ]
	INDEX0 -> [ ~succ(V:index:e9:, INDEX2), ]
	INDEX1 -> [ ~succ(V:index:e9:, INDEX2), ]
ucubes2qv #2
	~succ(V:index:e9:, INDEX2) -> [ INDEX0, INDEX1, ]
	((log(SERVER1, V:index:e9:) = TERM0) & (loglen(SERVER0) = V:index:e9:) & ~succ(INDEX0, V:index:e9:) & ~succ(INDEX1, V:index:e9:)) -> [ INDEX2, ]
(partition) #2 index:e9: -> { INDEX0, INDEX1, | INDEX2, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	INDEX2:
		(loglen(SERVER0) = INDEX2)
		~succ(INDEX1, INDEX2)
		~succ(INDEX0, INDEX2)
		(log(SERVER1, INDEX2) = TERM0)
ucmulti:
	~succ(INDEX0, INDEX2)
	(epr check: forward)	allowed(arc: index -> index)? False
	(epr check: reverse)	allowed(arc: index -> index)? False
	(epr check: forward)	allowed(arc: term -> index)? False
	(epr check: reverse)	allowed(arc: index -> term)? True
	(epr check: forward)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: server -> index)? True
(epr reduced)
	(forall SERVER0, SERVER1 . ((~leader(SERVER0) | (SERVER0 = SERVER1)) | (exists INDEX0 . (forall INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & succ(INDEX0, INDEX2)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX2) = TERM0) | ~(loglen(SERVER0) = INDEX2))))))
(non-epr version)
	(forall SERVER0, SERVER1 . ((~leader(SERVER0) | (SERVER0 = SERVER1)) | (forall INDEX2, TERM0 . (exists INDEX0 . ((~(INDEX2 = INDEX0) & succ(INDEX0, INDEX2)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX2) = TERM0) | ~(loglen(SERVER0) = INDEX2))))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(forall SERVER0, SERVER1 . ((~leader(SERVER0) | (SERVER0 = SERVER1)) | (exists INDEX0 . (forall INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & succ(INDEX0, INDEX2)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX2) = TERM0) | ~(loglen(SERVER0) = INDEX2))))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i2) | ~leader(s0) | succ(i0, i2) | succ(i1, i2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . ((~leader(SERVER0) | (SERVER0 = SERVER1)) | (exists INDEX0 . (forall INDEX2, TERM0 . ((~(INDEX2 = INDEX0) & succ(INDEX0, INDEX2)) | ~(currentTerm(SERVER0) = TERM0) | ~(log(SERVER1, INDEX2) = TERM0) | ~(loglen(SERVER0) = INDEX2))))))
---------------------------
(clause-type: epr)	(forall S0, S1 . ((leader(S0) & ~(S0 = S1)) -> (exists I0 . (forall I2, T0 . ((succ(I0, I2) -> (I2 = I0)) -> ((currentTerm(S0) = T0) -> ((log(S1, I2) = T0) -> ~(loglen(S0) = I2))))))))
@  2365s  is global clause? No
@  2365s  Learning in F[3]: (forall S0, S1 . ((leader(S0) & ~(S0 = S1)) -> (exists I0 . (forall I2, T0 . ((succ(I0, I2) -> (I2 = I0)) -> ((currentTerm(S0) = T0) -> ((log(S1, I2) = T0) -> ~(loglen(S0) = I2))))))))
@  2365s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t2
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = true
	indlt(i2, i0) = true
	indlt(i2, i1) = false
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = false
	indlte(i1, i2) = true
	indlte(i2, i0) = true
	indlte(i2, i1) = false
	indlte(i2, i2) = false
	indzero = i1
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2370s  F[2] /\ T /\ C+ ?
@  2370s  	Ans. UNSAT
@  2372s  F[3] unsat core #5 	(ucsz: 11 -> 9 -> 8 -> 7 -> 5 -> 5)
(minimal unsat core)
	succ(i2, i0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
	(termzero = t0)
	(indzero = i1)
(clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~succ(i2, i0))
(relations)
	loglen
	indzero
	log
	succ
	termzero
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	succ(INDEX2, INDEX0)
	(loglen(SERVER0) = INDEX0)
	(termzero = TERM0)
	(indzero = INDEX1)
(antecedent reduction)
@  2372s  antecedent: 3 -> 2 (reduced)
	removed: INDEX0

(eq map)
	TERM0 -> termzero
	INDEX1 -> indzero
(cube eq)
	succ(INDEX2, INDEX0)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER0, INDEX0) = termzero)
(qvars eq)
	INDEX2
	INDEX0
	SERVER0
(antecedent eq)
	index:e9:
	-> ~(indzero = INDEX2)
(fullsorts)
	index:e9: -> [ INDEX0, indzero, INDEX2, ]
qv2cubes #3
	INDEX2 -> [ succ(INDEX2, INDEX0), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), succ(INDEX2, INDEX0), (log(SERVER0, INDEX0) = termzero), ]
qv2ucubes #3
	INDEX2 -> [ succ(V:index:e9:, INDEX0), ]
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), (log(SERVER0, V:index:e9:) = termzero), succ(INDEX2, V:index:e9:), ]
ucubes2qv #3
	true -> [ indzero, ]
	succ(V:index:e9:, INDEX0) -> [ INDEX2, ]
	((log(SERVER0, V:index:e9:) = termzero) & (loglen(SERVER0) = V:index:e9:) & succ(INDEX2, V:index:e9:)) -> [ INDEX0, ]
(partition) #3 index:e9: -> { indzero, | INDEX2, | INDEX0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	(log(SERVER0, loglen(SERVER0)) = termzero)
	~(indzero = INDEX2)
	succ(INDEX2, loglen(SERVER0))
(qvars eq: post)
	INDEX2
	SERVER0
(boosted clause)
	(forall INDEX2, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (indzero = INDEX2) | ~succ(INDEX2, loglen(SERVER0))))
---------------------------
(original clause)
	(~(indzero = i1) | ~(log(s0, i0) = t0) | ~(loglen(s0) = i0) | ~(termzero = t0) | ~succ(i2, i0))
(learnt sym-boosted clause)
	(forall INDEX2, SERVER0 . (~(log(SERVER0, loglen(SERVER0)) = termzero) | (indzero = INDEX2) | ~succ(INDEX2, loglen(SERVER0))))
---------------------------
(clause-type: univ)	(forall I2, S0 . (((log(S0, loglen(S0)) = termzero) & succ(I2, loglen(S0))) -> (indzero = I2)))
@  2372s  is global clause? No
@  2372s  Learning in F[3]: (forall I2, S0 . (((log(S0, loglen(S0)) = termzero) & succ(I2, loglen(S0))) -> (indzero = I2)))
@  2372s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2381s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e10 with value True
	inputs:
actionName ext:getEntries
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:j:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
@  2382s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t1
	log(s1, i2) = t0
	log(s2, i0) = t1
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2			--> modified
	loglen(s1) = i1
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  2382s  F[1] /\ T /\ C+ ?
@  2382s  	Ans. UNSAT
@  2382s  F[2] unsat core #4 	(ucsz: 5 -> 4 -> 4)
(minimal unsat core)
	(log(s1, i1) = t1)
	(indzero = i2)
	(loglen(s2) = i0)
	(termzero = t0)
(clause)
	(~(indzero = i2) | ~(log(s1, i1) = t1) | ~(loglen(s2) = i0) | ~(termzero = t0))
(relations)
	loglen
	indzero
	log
	termzero
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(termzero = TERM0)
	(indzero = INDEX2)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
(antecedent reduction)
@  2383s  antecedent: 7 -> 6 (reduced)
	removed: INDEX1

(eq map)
	INDEX2 -> indzero
	TERM0 -> termzero
(cube eq)
	(loglen(SERVER1) = INDEX0)
	(log(SERVER0, INDEX1) = TERM1)
(qvars eq)
	INDEX0
	INDEX1
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	index:e9:
	-> ~(INDEX0 = indzero)
(fullsorts)
	index:e9: -> [ INDEX0, INDEX1, indzero, ]
qv2cubes #3
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER1) = INDEX0), ]
	INDEX1 -> [ (log(SERVER0, INDEX1) = TERM1), ]
qv2ucubes #3
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER1) = V:index:e9:), ]
	INDEX1 -> [ (log(SERVER0, V:index:e9:) = TERM1), ]
ucubes2qv #3
	true -> [ indzero, ]
	(loglen(SERVER1) = V:index:e9:) -> [ INDEX0, ]
	(log(SERVER0, V:index:e9:) = TERM1) -> [ INDEX1, ]
(partition) #3 index:e9: -> { indzero, | INDEX0, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM1 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	~(SERVER0 = SERVER1)
	~(loglen(SERVER1) = indzero)
	~(termzero = log(SERVER0, INDEX1))
(qvars eq: post)
	SERVER1
	INDEX1
	SERVER0
(boosted clause)
	(forall SERVER1, INDEX1, SERVER0 . ((SERVER0 = SERVER1) | (loglen(SERVER1) = indzero) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(original clause)
	(~(indzero = i2) | ~(log(s1, i1) = t1) | ~(loglen(s2) = i0) | ~(termzero = t0))
(learnt sym-boosted clause)
	(forall SERVER1, INDEX1, SERVER0 . ((SERVER0 = SERVER1) | (loglen(SERVER1) = indzero) | (termzero = log(SERVER0, INDEX1))))
---------------------------
(clause-type: univ)	(forall S1, I1, S0 . ((S0 = S1) | (loglen(S1) = indzero) | (termzero = log(S0, I1))))
@  2383s  is global clause? No
@  2383s  Learning in F[2]: (forall S1, I1, S0 . ((S0 = S1) | (loglen(S1) = indzero) | (termzero = log(S0, I1))))
@  2383s  F[2] /\ T /\ C+ ?
@  2383s  	Ans. UNSAT
@  2384s  F[3] unsat core #5 	(ucsz: 10 -> 8 -> 7 -> 6 -> 5 -> 5)
(minimal unsat core)
	leader(s0)
	(log(s0, i0) = t0)
	(loglen(s0) = i0)
	(log(s2, i0) = t1)
	(currentTerm(s0) = t1)
(clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0))
(relations)
	loglen
	log
	leader
	currentTerm
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	leader(SERVER0)
	(currentTerm(SERVER0) = TERM1)
	(loglen(SERVER0) = INDEX0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@  2384s  antecedent: 4 -> 2 (reduced)
	removed: SERVER0
	removed: SERVER1

(eq map: post)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM0 -> log(SERVER0, loglen(SERVER0))
	INDEX0 -> loglen(SERVER0)
(cube eq: post)
	leader(SERVER0)
	(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0)))
	~(log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t1) | ~(log(s0, i0) = t0) | ~(log(s2, i0) = t1) | ~(loglen(s0) = i0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | ~(currentTerm(SERVER0) = log(SERVER1, loglen(SERVER0))) | (log(SERVER0, loglen(SERVER0)) = log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((leader(S0) & (currentTerm(S0) = log(S1, loglen(S0)))) -> (log(S0, loglen(S0)) = log(S1, loglen(S0)))))
@  2384s  is global clause? No
@  2385s  Learning in F[3]: (forall S0, S1 . ((leader(S0) & (currentTerm(S0) = log(S1, loglen(S0)))) -> (log(S0, loglen(S0)) = log(S1, loglen(S0)))))
@  2385s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = true
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false			--> modified
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t0
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t1
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t0
	loglen(s0) = i0
	loglen(s1) = i1
	loglen(s2) = i1
	indlt(i0, i0) = false
	indlt(i0, i1) = false
	indlt(i0, i2) = false
	indlt(i1, i0) = true
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = false
	indlte(i0, i2) = false
	indlte(i1, i0) = true
	indlte(i1, i1) = true
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = true
	succ(i2, i2) = false
	termzero = t0

@  2393s  F[2] /\ T /\ C+ ?
@  2393s  	Ans. UNSAT
@  2394s  F[3] unsat core #4 	(ucsz: 14 -> 12 -> 11 -> 10 -> 7 -> 6 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i1)
	(indzero = i2)
	(loglen(s2) = i1)
	(loglen(s0) = i0)
(clause)
	(~(indzero = i2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~(loglen(s2) = i1))
(relations)
	loglen
	indzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, INDEX2, ]
(cube: std)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(indzero = INDEX2)
	(loglen(SERVER2) = INDEX1)
(antecedent reduction)
@  2394s  antecedent: 6 -> 5 (reduced)
	removed: SERVER0

(eq map)
	INDEX2 -> indzero
(cube eq)
	(loglen(SERVER1) = INDEX1)
	(loglen(SERVER0) = INDEX0)
	(loglen(SERVER2) = INDEX1)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	SERVER0
	SERVER1
(antecedent eq)
	server:e9:
	-> ~(SERVER1 = SERVER2)
	index:e9:
	-> ~(INDEX0 = INDEX1)
	-> ~(INDEX0 = indzero)
	-> ~(INDEX1 = indzero)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
	index:e9: -> [ INDEX0, INDEX1, indzero, ]
qv2cubes #3
	SERVER2 -> [ (loglen(SERVER2) = INDEX1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX0), ]
	SERVER1 -> [ (loglen(SERVER1) = INDEX1), ]
qv2ucubes #3
	SERVER2 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX0), ]
	SERVER1 -> [ (loglen(V:server:e9:) = INDEX1), ]
ucubes2qv #2
	(loglen(V:server:e9:) = INDEX0) -> [ SERVER0, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER2, SERVER1, ]
(partition) #2 server:e9: -> { SERVER0, | SERVER2, SERVER1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER0:
		(loglen(SERVER0) = INDEX0)
ucmulti:
	(loglen(SERVER1) = INDEX1)
qv2cubes #3
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = INDEX0), ]
	INDEX1 -> [ ((SERVER0 = SERVER1) | (loglen(SERVER1) = INDEX1)), ]
qv2ucubes #3
	indzero -> [ ]
	INDEX0 -> [ (loglen(SERVER0) = V:index:e9:), ]
	INDEX1 -> [ ((SERVER0 = SERVER1) | (loglen(SERVER1) = V:index:e9:)), ]
ucubes2qv #3
	(loglen(SERVER0) = V:index:e9:) -> [ INDEX0, ]
	true -> [ indzero, ]
	((SERVER0 = SERVER1) | (loglen(SERVER1) = V:index:e9:)) -> [ INDEX1, ]
(partition) #3 index:e9: -> { INDEX0, | indzero, | INDEX1, | }
	#3 singles, #0 multiples (out of #3 cells)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
(epr reduced)
	(exists SERVER1 . (forall SERVER0, INDEX0, INDEX1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX1)) | ~(loglen(SERVER0) = INDEX0) | (INDEX0 = INDEX1) | (INDEX0 = indzero) | (INDEX1 = indzero))))
(non-epr version)
	(forall SERVER0, INDEX0, INDEX1 . (exists SERVER1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX1)) | ~(loglen(SERVER0) = INDEX0) | (INDEX0 = INDEX1) | (INDEX0 = indzero) | (INDEX1 = indzero))))
	Both verions not allowed!
(epr-reduction) -> UNSAT
(boosted clause)
	(exists SERVER1 . (forall SERVER0, INDEX0, INDEX1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX1)) | ~(loglen(SERVER0) = INDEX0) | (INDEX0 = INDEX1) | (INDEX0 = indzero) | (INDEX1 = indzero))))
---------------------------
(original clause)
	(~(indzero = i2) | ~(loglen(s0) = i0) | ~(loglen(s1) = i1) | ~(loglen(s2) = i1))
(learnt sym-boosted clause)
	(exists SERVER1 . (forall SERVER0, INDEX0, INDEX1 . ((~(SERVER0 = SERVER1) & ~(loglen(SERVER1) = INDEX1)) | ~(loglen(SERVER0) = INDEX0) | (INDEX0 = INDEX1) | (INDEX0 = indzero) | (INDEX1 = indzero))))
---------------------------
(clause-type: epr)	(exists S1 . (forall S0, I0, I1 . ((((S0 = S1) | (loglen(S1) = I1)) & (loglen(S0) = I0)) -> ((I0 = I1) | (I0 = indzero) | (I1 = indzero)))))
@  2419s  is global clause? No
@  2419s  Learning in F[3]: (exists S1 . (forall S0, I0, I1 . ((((S0 = S1) | (loglen(S1) = I1)) & (loglen(S0) = I0)) -> ((I0 = I1) | (I0 = indzero) | (I1 = indzero)))))
@  2419s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = false
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t0
	currentTerm(s1) = t1
	currentTerm(s2) = t1
	leader(s0) = false
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t2
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = true
	member(s1, q1) = true
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  2508s  F[2] /\ T /\ C+ ?
@  2508s  	Ans. UNSAT
@  2509s  F[3] unsat core #4 	(ucsz: 11 -> 10 -> 8 -> 7 -> 5 -> 4 -> 4)
(minimal unsat core)
	(loglen(s1) = i0)
	(log(s0, i0) = t0)
	(log(s0, i1) = t0)
	(termzero = t2)
(clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(loglen(s1) = i0) | ~(termzero = t2))
(relations)
	loglen
	log
	termzero
(cube: std)
	(log(SERVER0, INDEX0) = TERM0)
	(termzero = TERM1)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
(antecedent reduction)
@  2511s  antecedent: 6 -> 6

(eq map)
	TERM1 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM0)
	(log(SERVER0, INDEX1) = TERM0)
	(loglen(SERVER1) = INDEX0)
(qvars eq)
	INDEX0
	INDEX1
	TERM0
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(eq map: post)
	TERM0 -> log(SERVER0, INDEX1)
	INDEX0 -> loglen(SERVER1)
(cube eq: post)
	(log(SERVER0, loglen(SERVER1)) = log(SERVER0, INDEX1))
	~(loglen(SERVER1) = INDEX1)
	~(SERVER0 = SERVER1)
	~(log(SERVER0, INDEX1) = termzero)
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX1
(boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~(log(SERVER0, loglen(SERVER1)) = log(SERVER0, INDEX1)) | (loglen(SERVER1) = INDEX1) | (SERVER0 = SERVER1) | (log(SERVER0, INDEX1) = termzero)))
---------------------------
(original clause)
	(~(log(s0, i0) = t0) | ~(log(s0, i1) = t0) | ~(loglen(s1) = i0) | ~(termzero = t2))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX1 . (~(log(SERVER0, loglen(SERVER1)) = log(SERVER0, INDEX1)) | (loglen(SERVER1) = INDEX1) | (SERVER0 = SERVER1) | (log(SERVER0, INDEX1) = termzero)))
---------------------------
(clause-type: univ)	(forall S0, S1, I1 . ((log(S0, loglen(S1)) = log(S0, I1)) -> ((loglen(S1) = I1) | (S0 = S1) | (log(S0, I1) = termzero))))
@  2511s  is global clause? No
@  2511s  Learning in F[3]: (forall S0, S1, I1 . ((log(S0, loglen(S1)) = log(S0, I1)) -> ((loglen(S1) = I1) | (S0 = S1) | (log(S0, I1) = termzero))))
@  2511s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = true
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

(cube in F[3])
	committed(i0, t0) = false			--> modified
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t2
	currentTerm(s2) = t1
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t2
	log(s0, i1) = t2
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t2
	log(s1, i2) = t2
	log(s2, i0) = t0
	log(s2, i1) = t2
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = false
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = true
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = true
	indlte(i0, i1) = true
	indlte(i0, i2) = false
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = true
	indlte(i2, i1) = true
	indlte(i2, i2) = false
	indzero = i2
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = false
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = true
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = false
	member(s0, q1) = false
	member(s1, q0) = false
	member(s1, q1) = true
	member(s2, q0) = true
	member(s2, q1) = true
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = false
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = true
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t2

@  2547s  F[2] /\ T /\ C+ ?
@  2548s  	Ans. UNSAT
@  2549s  F[3] unsat core #6 	(ucsz: 17 -> 12 -> 11 -> 10 -> 9 -> 7 -> 6 -> 6)
(minimal unsat core)
	(termzero = t2)
	~lte(t1, t0)
	(loglen(s0) = i2)
	(log(s1, i0) = t0)
	(currentTerm(s1) = t2)
	(currentTerm(s2) = t1)
(clause)
	(~(currentTerm(s1) = t2) | ~(currentTerm(s2) = t1) | ~(log(s1, i0) = t0) | ~(loglen(s0) = i2) | ~(termzero = t2) | lte(t1, t0))
(relations)
	loglen
	currentTerm
	log
	lte
	termzero
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(termzero = TERM2)
	(log(SERVER1, INDEX0) = TERM0)
	(loglen(SERVER0) = INDEX1)
	~lte(TERM1, TERM0)
	(currentTerm(SERVER1) = TERM2)
	(currentTerm(SERVER2) = TERM1)
(antecedent reduction)
@  2550s  antecedent: 8 -> 6 (reduced)
	removed: SERVER1
	removed: TERM1

(eq map)
	TERM2 -> termzero
(cube eq)
	~lte(TERM1, TERM0)
	(loglen(SERVER0) = INDEX1)
	(currentTerm(SERVER1) = termzero)
	(log(SERVER1, INDEX0) = TERM0)
	(currentTerm(SERVER2) = TERM1)
(qvars eq)
	SERVER2
	INDEX0
	INDEX1
	TERM0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(TERM0 = termzero)
	server:e9:
	-> ~(SERVER0 = SERVER2)
	index:e9:
	-> ~(INDEX0 = INDEX1)
(fullsorts)
	term:e9: -> [ TERM0, TERM1, termzero, ]
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	TERM0 -> [ ~lte(TERM1, TERM0), (log(SERVER1, INDEX0) = TERM0), ]
	TERM1 -> [ ~lte(TERM1, TERM0), (currentTerm(SERVER2) = TERM1), ]
	termzero -> [ (currentTerm(SERVER1) = termzero), ]
qv2ucubes #3
	TERM0 -> [ (log(SERVER1, INDEX0) = V:term:e9:), ~lte(TERM1, V:term:e9:), ]
	TERM1 -> [ ~lte(V:term:e9:, TERM0), (currentTerm(SERVER2) = V:term:e9:), ]
	termzero -> [ (currentTerm(SERVER1) = V:term:e9:), ]
ucubes2qv #3
	((log(SERVER1, INDEX0) = V:term:e9:) & ~lte(TERM1, V:term:e9:)) -> [ TERM0, ]
	((currentTerm(SERVER2) = V:term:e9:) & ~lte(V:term:e9:, TERM0)) -> [ TERM1, ]
	(currentTerm(SERVER1) = V:term:e9:) -> [ termzero, ]
(partition) #3 term:e9: -> { TERM0, | TERM1, | termzero, | }
	#3 singles, #0 multiples (out of #3 cells)
qv2cubes #3
	SERVER2 -> [ (currentTerm(SERVER2) = TERM1), ]
	SERVER0 -> [ (loglen(SERVER0) = INDEX1), ]
	SERVER1 -> [ (currentTerm(SERVER1) = termzero), (log(SERVER1, INDEX0) = TERM0), ]
qv2ucubes #3
	SERVER2 -> [ (currentTerm(V:server:e9:) = TERM1), ]
	SERVER0 -> [ (loglen(V:server:e9:) = INDEX1), ]
	SERVER1 -> [ (currentTerm(V:server:e9:) = termzero), (log(V:server:e9:, INDEX0) = TERM0), ]
ucubes2qv #3
	(currentTerm(V:server:e9:) = TERM1) -> [ SERVER2, ]
	((currentTerm(V:server:e9:) = termzero) & (log(V:server:e9:, INDEX0) = TERM0)) -> [ SERVER1, ]
	(loglen(V:server:e9:) = INDEX1) -> [ SERVER0, ]
(partition) #3 server:e9: -> { SERVER2, | SERVER1, | SERVER0, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	TERM0 -> log(SERVER1, INDEX0)
	TERM1 -> currentTerm(SERVER2)
	INDEX1 -> loglen(SERVER0)
(cube eq: post)
	~(INDEX0 = loglen(SERVER0))
	~lte(currentTerm(SERVER2), log(SERVER1, INDEX0))
	~(SERVER0 = SERVER2)
	(currentTerm(SERVER1) = termzero)
	~(log(SERVER1, INDEX0) = termzero)
(qvars eq: post)
	SERVER2
	INDEX0
	SERVER0
	SERVER1
(boosted clause)
	(forall SERVER2, INDEX0, SERVER0, SERVER1 . ((INDEX0 = loglen(SERVER0)) | lte(currentTerm(SERVER2), log(SERVER1, INDEX0)) | (SERVER0 = SERVER2) | ~(currentTerm(SERVER1) = termzero) | (log(SERVER1, INDEX0) = termzero)))
---------------------------
(original clause)
	(~(currentTerm(s1) = t2) | ~(currentTerm(s2) = t1) | ~(log(s1, i0) = t0) | ~(loglen(s0) = i2) | ~(termzero = t2) | lte(t1, t0))
(learnt sym-boosted clause)
	(forall SERVER2, INDEX0, SERVER0, SERVER1 . ((INDEX0 = loglen(SERVER0)) | lte(currentTerm(SERVER2), log(SERVER1, INDEX0)) | (SERVER0 = SERVER2) | ~(currentTerm(SERVER1) = termzero) | (log(SERVER1, INDEX0) = termzero)))
---------------------------
(clause-type: univ)	(forall S2, I0, S0, S1 . ((currentTerm(S1) = termzero) -> ((I0 = loglen(S0)) | lte(currentTerm(S2), log(S1, I0)) | (S0 = S2) | (log(S1, I0) = termzero))))
@  2550s  is global clause? No
@  2550s  Learning in F[3]: (forall S2, I0, S0, S1 . ((currentTerm(S1) = termzero) -> ((I0 = loglen(S0)) | lte(currentTerm(S2), log(S1, I0)) | (S0 = S2) | (log(S1, I0) = termzero))))
@  2550s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = true
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false			--> modified
	committed(i2, t2) = false
	currentTerm(s0) = t2
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = false
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t1
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t1
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0
	loglen(s0) = i2
	loglen(s1) = i2
	loglen(s2) = i0
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = true
	lte(t2, t0) = false
	lte(t2, t1) = false
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = false
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  3795s  F[2] /\ T /\ C+ ?
@  3795s  	Ans. UNSAT
@  3796s  F[3] unsat core #6 	(ucsz: 14 -> 10 -> 8 -> 7 -> 6 -> 6)
(minimal unsat core)
	(log(s1, i2) = t1)
	~leader(s1)
	(termzero = t0)
	(loglen(s0) = i2)
	~lte(t2, t1)
	(currentTerm(s0) = t2)
(clause)
	(~(currentTerm(s0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i2) | ~(termzero = t0) | leader(s1) | lte(t2, t1))
(relations)
	loglen
	termzero
	leader
	currentTerm
	log
	lte
(fullsorts)
	term:e9: -> [ TERM0, TERM1, TERM2, ]
(cube: std)
	~lte(TERM2, TERM1)
	(currentTerm(SERVER0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	(termzero = TERM0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@  3800s  antecedent: 5 -> 4 (reduced)
	removed: TERM2

(eq map)
	TERM0 -> termzero
(cube eq)
	~lte(TERM2, TERM1)
	(currentTerm(SERVER0) = TERM2)
	(loglen(SERVER0) = INDEX0)
	~leader(SERVER1)
	(log(SERVER1, INDEX0) = TERM1)
(qvars eq)
	INDEX0
	TERM1
	TERM2
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
(fullsorts)
	term:e9: -> [ termzero, TERM1, TERM2, ]
qv2cubes #3
	TERM1 -> [ ~lte(TERM2, TERM1), (log(SERVER1, INDEX0) = TERM1), ]
	termzero -> [ ]
	TERM2 -> [ ~lte(TERM2, TERM1), (currentTerm(SERVER0) = TERM2), ]
qv2ucubes #3
	TERM1 -> [ ~lte(TERM2, V:term:e9:), (log(SERVER1, INDEX0) = V:term:e9:), ]
	termzero -> [ ]
	TERM2 -> [ ~lte(V:term:e9:, TERM1), (currentTerm(SERVER0) = V:term:e9:), ]
ucubes2qv #3
	((log(SERVER1, INDEX0) = V:term:e9:) & ~lte(TERM2, V:term:e9:)) -> [ TERM1, ]
	((currentTerm(SERVER0) = V:term:e9:) & ~lte(V:term:e9:, TERM1)) -> [ TERM2, ]
	true -> [ termzero, ]
(partition) #3 term:e9: -> { TERM1, | TERM2, | termzero, | }
	#3 singles, #0 multiples (out of #3 cells)
(eq map: post)
	INDEX0 -> loglen(SERVER0)
	TERM1 -> log(SERVER1, loglen(SERVER0))
	TERM2 -> currentTerm(SERVER0)
(cube eq: post)
	~(termzero = log(SERVER1, loglen(SERVER0)))
	~leader(SERVER1)
	~(SERVER0 = SERVER1)
	~lte(currentTerm(SERVER0), log(SERVER1, loglen(SERVER0)))
(qvars eq: post)
	SERVER1
	SERVER0
(boosted clause)
	(forall SERVER1, SERVER0 . ((termzero = log(SERVER1, loglen(SERVER0))) | leader(SERVER1) | (SERVER0 = SERVER1) | lte(currentTerm(SERVER0), log(SERVER1, loglen(SERVER0)))))
---------------------------
(original clause)
	(~(currentTerm(s0) = t2) | ~(log(s1, i2) = t1) | ~(loglen(s0) = i2) | ~(termzero = t0) | leader(s1) | lte(t2, t1))
(learnt sym-boosted clause)
	(forall SERVER1, SERVER0 . ((termzero = log(SERVER1, loglen(SERVER0))) | leader(SERVER1) | (SERVER0 = SERVER1) | lte(currentTerm(SERVER0), log(SERVER1, loglen(SERVER0)))))
---------------------------
(clause-type: univ)	(forall S1, S0 . ((termzero = log(S1, loglen(S0))) | leader(S1) | (S0 = S1) | lte(currentTerm(S0), log(S1, loglen(S0)))))
@  3800s  is global clause? No
@  3800s  Learning in F[3]: (forall S1, S0 . ((termzero = log(S1, loglen(S0))) | leader(S1) | (S0 = S1) | lte(currentTerm(S0), log(S1, loglen(S0)))))
@  3800s  F[3] /\ T /\ !P+ -> SAT
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:commitEntry
	en: en_ext:commitEntry:e10 with value True
	inputs:
actionName ext:commitEntry
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:q:e1:e4:e7:e8 -> q0
(cube in !P)
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = true
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

(cube in F[3])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false			--> modified
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t2
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i2
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  4183s  F[2] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:getEntries
	en: en_ext:getEntries:e10 with value True
	inputs:
actionName ext:getEntries
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:j:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
@  4184s  	Ans. SAT
(cube in F[2])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0			--> modified
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t2
	loglen(s0) = i0			--> modified
	loglen(s1) = i0
	loglen(s2) = i2
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  4184s  F[1] /\ T /\ C+ ?
####################MODEL PRINT: ####################
####################END PRINT MODEL:####################
(action info)
	action: ext:clientRequest
	en: en_ext:clientRequest:e10 with value True
	inputs:
actionName ext:clientRequest
		V__fml:e1:e4:e7:e8 -> s0
		V__fml:nextInd:e1:e4:e7:e8 -> i0
@  4184s  	Ans. SAT
(cube in F[1])
	committed(i0, t0) = false
	committed(i0, t1) = false
	committed(i0, t2) = false
	committed(i1, t0) = false
	committed(i1, t1) = false
	committed(i1, t2) = false
	committed(i2, t0) = false
	committed(i2, t1) = false
	committed(i2, t2) = false
	currentTerm(s0) = t1
	currentTerm(s1) = t1
	currentTerm(s2) = t2
	leader(s0) = true
	leader(s1) = true
	leader(s2) = true
	log(s0, i0) = t0
	log(s0, i1) = t0
	log(s0, i2) = t0
	log(s1, i0) = t0
	log(s1, i1) = t0
	log(s1, i2) = t0
	log(s2, i0) = t0
	log(s2, i1) = t0
	log(s2, i2) = t0			--> modified
	loglen(s0) = i0
	loglen(s1) = i0
	loglen(s2) = i0			--> modified
	indlt(i0, i0) = false
	indlt(i0, i1) = true
	indlt(i0, i2) = true
	indlt(i1, i0) = false
	indlt(i1, i1) = false
	indlt(i1, i2) = false
	indlt(i2, i0) = false
	indlt(i2, i1) = true
	indlt(i2, i2) = false
	indlte(i0, i0) = false
	indlte(i0, i1) = true
	indlte(i0, i2) = true
	indlte(i1, i0) = false
	indlte(i1, i1) = false
	indlte(i1, i2) = false
	indlte(i2, i0) = false
	indlte(i2, i1) = true
	indlte(i2, i2) = true
	indzero = i0
	lte(t0, t0) = true
	lte(t0, t1) = true
	lte(t0, t2) = true
	lte(t1, t0) = false
	lte(t1, t1) = true
	lte(t1, t2) = false
	lte(t2, t0) = false
	lte(t2, t1) = true
	lte(t2, t2) = true
	member(s0, q0) = true
	member(s0, q1) = true
	member(s1, q0) = true
	member(s1, q1) = false
	member(s2, q0) = false
	member(s2, q1) = false
	succ(i0, i0) = false
	succ(i0, i1) = false
	succ(i0, i2) = true
	succ(i1, i0) = false
	succ(i1, i1) = false
	succ(i1, i2) = false
	succ(i2, i0) = false
	succ(i2, i1) = false
	succ(i2, i2) = false
	termzero = t0

@  4184s  F[0] /\ T /\ C+ ?
@  4184s  	Ans. UNSAT
@  4184s  F[1] unsat core #2 	(ucsz: 5 -> 2 -> 2 -> 2)
(minimal unsat core)
	leader(s0)
	leader(s1)
(clause)
	(~leader(s0) | ~leader(s1))
(relations)
	leader
(cube: std)
	leader(SERVER0)
	leader(SERVER1)
(antecedent reduction)
@  4184s  antecedent: 2 -> 2

(boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (SERVER0 = SERVER1) | ~leader(SERVER1)))
---------------------------
(original clause)
	(~leader(s0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1 . (~leader(SERVER0) | (SERVER0 = SERVER1) | ~leader(SERVER1)))
---------------------------
(clause-type: univ)	(forall S0, S1 . ((leader(S0) & leader(S1)) -> (S0 = S1)))
@  4184s  is global clause? No
@  4184s  Learning in F[1]: (forall S0, S1 . ((leader(S0) & leader(S1)) -> (S0 = S1)))
@  4184s  F[1] /\ T /\ C+ ?
@  4184s  	Ans. UNSAT
@  4184s  F[2] unsat core #3 	(ucsz: 4 -> 3 -> 3)
(minimal unsat core)
	leader(s0)
	(termzero = t0)
	(log(s2, i2) = t2)
(clause)
	(~(log(s2, i2) = t2) | ~(termzero = t0) | ~leader(s0))
(relations)
	log
	leader
	termzero
(cube: std)
	leader(SERVER0)
	(termzero = TERM0)
	(log(SERVER1, INDEX0) = TERM1)
(antecedent reduction)
@  4185s  antecedent: 4 -> 4

(eq map)
	TERM0 -> termzero
(cube eq)
	leader(SERVER0)
	(log(SERVER1, INDEX0) = TERM1)
(qvars eq)
	SERVER0
	TERM1
	SERVER1
	INDEX0
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
(eq map: post)
	TERM1 -> log(SERVER1, INDEX0)
(cube eq: post)
	leader(SERVER0)
	~(SERVER0 = SERVER1)
	~(termzero = log(SERVER1, INDEX0))
(qvars eq: post)
	SERVER0
	SERVER1
	INDEX0
(boosted clause)
	(forall SERVER0, SERVER1, INDEX0 . (~leader(SERVER0) | (SERVER0 = SERVER1) | (termzero = log(SERVER1, INDEX0))))
---------------------------
(original clause)
	(~(log(s2, i2) = t2) | ~(termzero = t0) | ~leader(s0))
(learnt sym-boosted clause)
	(forall SERVER0, SERVER1, INDEX0 . (~leader(SERVER0) | (SERVER0 = SERVER1) | (termzero = log(SERVER1, INDEX0))))
---------------------------
(clause-type: univ)	(forall S0, S1, I0 . (leader(S0) -> ((S0 = S1) | (termzero = log(S1, I0)))))
@  4185s  is global clause? No
@  4185s  Learning in F[2]: (forall S0, S1, I0 . (leader(S0) -> ((S0 = S1) | (termzero = log(S1, I0)))))
@  4185s  F[2] /\ T /\ C+ ?
@  4185s  	Ans. UNSAT
@  4186s  F[3] unsat core #4 	(ucsz: 8 -> 7 -> 6 -> 5 -> 4 -> 4)
(minimal unsat core)
	(log(s0, i2) = t2)
	(log(s2, i2) = t2)
	leader(s1)
	(termzero = t0)
(clause)
	(~(log(s0, i2) = t2) | ~(log(s2, i2) = t2) | ~(termzero = t0) | ~leader(s1))
(relations)
	log
	leader
	termzero
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
(cube: std)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER2, INDEX0) = TERM1)
	leader(SERVER1)
	(termzero = TERM0)
(antecedent reduction)
@  4189s  antecedent: 5 -> 5

(eq map)
	TERM0 -> termzero
(cube eq)
	(log(SERVER0, INDEX0) = TERM1)
	(log(SERVER2, INDEX0) = TERM1)
	leader(SERVER1)
(qvars eq)
	SERVER2
	INDEX0
	TERM1
	SERVER0
	SERVER1
(antecedent eq)
	term:e9:
	-> ~(termzero = TERM1)
	server:e9:
	-> ~(SERVER0 = SERVER1)
	-> ~(SERVER0 = SERVER2)
	-> ~(SERVER1 = SERVER2)
(fullsorts)
	server:e9: -> [ SERVER0, SERVER1, SERVER2, ]
qv2cubes #3
	SERVER2 -> [ (log(SERVER2, INDEX0) = TERM1), ]
	SERVER0 -> [ (log(SERVER0, INDEX0) = TERM1), ]
	SERVER1 -> [ leader(SERVER1), ]
qv2ucubes #3
	SERVER2 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
	SERVER0 -> [ (log(V:server:e9:, INDEX0) = TERM1), ]
	SERVER1 -> [ leader(V:server:e9:), ]
ucubes2qv #2
	(log(V:server:e9:, INDEX0) = TERM1) -> [ SERVER2, SERVER0, ]
	leader(V:server:e9:) -> [ SERVER1, ]
(partition) #2 server:e9: -> { SERVER2, SERVER0, | SERVER1, | }
	#1 singles, #1 multiples (out of #2 cells)
ucsingle:
	SERVER1:
		leader(SERVER1)
ucmulti:
	(log(SERVER0, INDEX0) = TERM1)
	(epr check: forward)	allowed(arc: index -> server)? False
	(epr check: reverse)	allowed(arc: server -> index)? True
	(epr check: forward)	allowed(arc: term -> server)? False
	(epr check: reverse)	allowed(arc: server -> term)? True
	(epr check: forward)	allowed(arc: server -> server)? False
	(epr check: reverse)	allowed(arc: server -> server)? False
(epr reduced)
	(exists SERVER0 . (forall TERM1, INDEX0, SERVER1 . ((~(SERVER1 = SERVER0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~leader(SERVER1) | (termzero = TERM1))))
(non-epr version)
	(forall TERM1, INDEX0, SERVER1 . (exists SERVER0 . ((~(SERVER1 = SERVER0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~leader(SERVER1) | (termzero = TERM1))))
	Both verions not allowed!
(epr-reduction) -> SAT
	EPR-reduction is not allowed!
	Learning non-epr version instead.
(boosted clause)
	(forall TERM1, INDEX0, SERVER1 . (exists SERVER0 . ((~(SERVER1 = SERVER0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~leader(SERVER1) | (termzero = TERM1))))
---------------------------
(original clause)
	(~(log(s0, i2) = t2) | ~(log(s2, i2) = t2) | ~(termzero = t0) | ~leader(s1))
(learnt sym-boosted clause)
	(forall TERM1, INDEX0, SERVER1 . (exists SERVER0 . ((~(SERVER1 = SERVER0) & ~(log(SERVER0, INDEX0) = TERM1)) | ~leader(SERVER1) | (termzero = TERM1))))
---------------------------
(clause-type: non-epr)	(forall T1, I0, S1 . (exists S0 . ((((S1 = S0) | (log(S0, I0) = T1)) & leader(S1)) -> (termzero = T1))))
@  4193s  is global clause? No
@  4193s  Learning in F[3]: (forall T1, I0, S1 . (exists S0 . ((((S1 = S0) | (log(S0, I0) = T1)) & leader(S1)) -> (termzero = T1))))
@  4194s  F[3] /\ T /\ !P+ canceled
Error in solver result.
Z3 reason for unknown: canceled
	(trying qf)
