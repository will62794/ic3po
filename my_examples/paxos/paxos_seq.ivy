#lang ivy1.7

################################################################################
#
# Module for axiomatizing a total order
#
################################################################################

module total_order(r) = {
    axiom r(X,X)                        # Reflexivity
    axiom r(X, Y) & r(Y, Z) -> r(X, Z)  # Transitivity
    axiom r(X, Y) & r(Y, X) -> X = Y    # Anti-symmetry
    axiom r(X, Y) | r(Y, X)             # Totality
}


################################################################################
#
# Types, relations and functions describing state of the network
#
################################################################################

type round
type value
type quorum
type node

individual none: round
relation le(X:round, Y:round)
instantiate total_order(le)

relation member(N:node, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:node. member(N, Q1) & member(N, Q2)

relation one_a(R:round)
relation one_b_max_vote(N:node, R1:round, R2:round, V:value)
relation one_b(N:node, R:round) # := exists RMAX, V. one_b_max_vote(N,R,RMAX,V)
relation left_rnd(N:node, R:round) # := exists R2, RMAX, V. ~le(R2,R) & one_b_max_vote(N,R,RMAX,V)
relation proposal(R:round, V:value) # 2a
relation vote(N:node, R:round, V:value) # 2b
relation decision(N:node, R:round, V:value) # got 2b from a quorum

type phase

individual curr_phase : phase

individual phase_1a : phase
individual phase_join_round : phase
individual phase_propose : phase
individual phase_cast_vote : phase
individual phase_decide : phase

axiom ~(phase_1a = phase_join_round) & ~(phase_1a = phase_propose) & ~(phase_1a = phase_cast_vote) & ~(phase_1a = phase_decide)
axiom ~(phase_join_round = phase_propose) & ~(phase_join_round = phase_cast_vote) & ~(phase_join_round = phase_decide)
axiom ~(phase_propose = phase_cast_vote) & ~(phase_propose = phase_decide)

# individual prev_round : round
# individual curr_round : round
# axiom le(prev_round, curr_round) & 


after init{
    one_a(R) := false;
    one_b_max_vote(N,R1,R2,V) := false;
    one_b(N,R) := false;
    left_rnd(N,R) :=  false;
    proposal(R,V) := false;
    vote(N,R,V) := false;
    decision(N,R,V) := false;


    # one_a(R) := *;
    # one_b_max_vote(N,R1,R2,V) := false;
    # one_b(N,R) := false;
    # left_rnd(N,R) :=  false;
    # proposal(R,V) := false;
    # vote(N,R,V) := false;
    # decision(N,R,V) := false;   
    
    curr_phase := phase_1a;
    # require decision(N,R,V) -> (exists Q. (member(I,Q) -> vote(I,R,V)));
}

action send_1a(r:round) = {
    require curr_phase = phase_1a;
    # a proposer selects a round and sends a message asking nodes to join the round
    require r ~= none;
    one_a(r) := true;
}

action join_round(n:node, r:round, maxr:round, v:value) = {
    require curr_phase = phase_join_round;
    # receive 1a and answer with 1b
    require ~(r = none);
    require one_a(r);
    require ~left_rnd(n,r);

    # find the maximal vote in a round less than r
    require ((maxr = none & forall MAXR:round,V:value. ~(~le(r,MAXR) & vote(n,MAXR,V))) |
            (~(maxr = none) & ~le(r,maxr) & vote(n,maxr,v) &
            (forall MAXR:round,V:value. (~le(r,MAXR) & vote(n,MAXR,V)) -> le(MAXR,maxr))
            ));
    # send the 1b message
    one_b_max_vote(n,r,maxr,v) := true;
    one_b(n,r) := true;
    left_rnd(n,R) := left_rnd(n,R) | ~le(r,R)
}



action propose(r:round, q:quorum, maxr: round, v:value) = {
    require curr_phase = phase_propose;

    # receive a quorum of 1b's and send a 2a (proposal)
    require ~(r = none);
    require ~proposal(r,V);
    require forall N:node. member(N, q) -> one_b(N,r);

    # find the maximal max_vote in the quorum
    require ((maxr = none & forall N:node,MAXR:round,V:value. ~(member(N, q) & ~le(r,MAXR) & vote(N,MAXR,V))) |
            (~(maxr = none) &
            (exists N:node. member(N, q) & ~le(r,maxr) & vote(N,maxr,v)) &
            (forall N:node,MAXR:round,V:value. (member(N, q) & ~le(r,MAXR) & vote(N,MAXR,V)) -> le(MAXR,maxr))
            ));
    # propose value v
    proposal(r, v) := true;
}

action cast_vote(n:node, v:value, r:round) = {
    require curr_phase = phase_cast_vote;
    # receive a 2a and send 2b
    require ~(r = none);
    require ~left_rnd(n,r);
    require proposal(r, v);
    vote(n, r, v) := true;
}

action decide(n:node, r:round, v:value, q:quorum) = {
    require curr_phase = phase_decide;
    # get 2b from a quorum
    require ~(r = none);
    require member(N, q) -> vote(N, r, v);
    decision(n, r, v) := true;
}

export send_1a
export join_round
export propose
export cast_vote
export decide

action next_phase1 = {
    require curr_phase = phase_1a;
    curr_phase := phase_join_round;
}
action next_phase2 = {
    require curr_phase = phase_join_round;
    curr_phase := phase_propose;
}
action next_phase3 = {
    require curr_phase = phase_propose;
    curr_phase := phase_cast_vote;
}
action next_phase4 = {
    require curr_phase = phase_cast_vote;
    curr_phase := phase_decide;
}
export next_phase1
export next_phase2
export next_phase3
export next_phase4

# safety property:
# invariant [safety] (decision(N1,R1,V1) & decision(N2,R2,V2)) -> (V1 = V2)

# join_round safety:
# After leaving the join_round phase, if a node has sent a 1b message for round r,
# it must be the case that it can no longer join a lesser round.
# invariant [safety] ( one_b(N,R) & (le(U,R) & ~(U=R)) ) -> left_rnd(N,U)


# phase safety: if a value has been chosen, then it should be present on a quourm in the round.
# invariant [safety] decision(N,R,V) -> (exists Q. (member(I,Q) -> vote(I,R,V)))

# if a value has been accepted by a quorum in round R, no proposer in higher round can propose 
# a different value.
# invariant [safety] (exists Q. (member(I,Q) -> vote(I,R,V)) & le(R,U) & (R~=U)) -> ~(exists Q1. member(N, Q1) -> one_b(N,U))



# invariant [egress_inv] (decision(N,R,V) & le(R,U) & (R~=U)) -> ~(  exists Q. (member(N, Q) -> one_b(N,U)) &     )

# ( ~(maxr = none) & (exists N:node. member(N, q) & ~le(r,maxr) & vote(N,maxr,v)) & (forall N:node,MAXR:round,V:value. (member(N, q) & ~le(r,MAXR) & vote(N,MAXR,V)) -> le(MAXR,maxr)) ))


# R: current round.
# U: newer round.
invariant [egress_inv] (decision(N,R,V) & le(R,U) & (R~=U) & (V2~=V)) -> 
    ~( exists Q.
        # ( (MAXR = none & forall N:node,RX:round,VX:value. ~(member(N, Q) & ~le(U,RX) & vote(N,RX,VX)) )  |
        (  ~(MAXR = none)     &     
            (exists N:node. member(N, Q) & ~le(U,MAXR) & vote(N,MAXR,V2))    &    
            (forall N:node,RX:round,VX:value. (member(N, Q) & ~le(U,RX) & vote(N,RX,VX)) -> le(RX,MAXR))  )
        )