#lang ivy1.7

#
# Simplified version of MongoDB Raft protocol in Ivy
#

type server
type term
type quorum
type index

#
# Axioms on the sorts used in the protocol.
#

# Any two quorums must overlap.
relation member(N:server, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:server. member(N, Q1) & member(N, Q2)

# Less than relation on terms to provide total order.
relation lt(X:term, Y:term)
axiom lt(X:term,Y) & lt(Y,Z) -> lt(X,Z)
axiom ~lt(X:term,X)
axiom lt(X:term,Y) | (X = Y) | lt(Y,X)
axiom X:term = 0 | lt(0, X)

function lte(A:term,B:term):bool
definition lte(A,B) = lt(A,B) | (A = B)

# Less than relation on log indices to provide total order.
individual indzero:index
relation indlt(X:index, Y:index)
axiom indlt(X:index,Y) & indlt(Y,Z) -> indlt(X,Z)
axiom ~indlt(X:index,X)
axiom indlt(X:index,Y) | (X = Y) | indlt(Y,X)
axiom X:index = indzero | indlt(indzero, X)

function indlte(A:index,B:index):bool
definition indlte(A,B) = indlt(A,B) | (A = B)

#
# State variables.
#

# VARIABLE currentTerm
# VARIABLE state
# VARIABLE log
# VARIABLE config
# VARIABLE committed

# A server's current term.
function currentTerm(X:server) : term

# Whether a server is currently acting as a leader.
#function state(X:server) : state_t
relation leader(X:server)

# The logs of each server.
function log(X:server, I:index):term

# The current length of the log on server X.
function loglen(X:server) : index

after init {
    leader(X) := false;
    currentTerm(X) := 0;
    loglen(X) := indzero;
    log(X,I) := 0;
}

# Server 'i' becomes leader by using the next term.
action becomeLeader(i:server, q: quorum, newTerm: term) = {
    # Must garner a quorum of voters that haven't voted in this term,
    # and primary votes for itself.
    require lt(currentTerm(i), newTerm);
    require member(i,q);
    require lt(currentTerm(i), newTerm);
    require forall X. member(X,q) -> lt(currentTerm(X), newTerm);

    # Update term and state of servers.
    currentTerm(J) := newTerm if member(J,q) else currentTerm(J);
    leader(J) := true if J=i else (false if member(J,q) else leader(J));
}
export becomeLeader

action clientRequest(i:server, nextInd:index) = {
    require leader(i);
    require indlt(loglen(i),nextInd); 
    log(i, nextInd) := currentTerm(i);
    loglen(i) := nextInd;
}
export clientRequest

# invariant [election_safety] (leader(X) & leader(Y) & ~(X=Y)) -> ~(currentTerm(X)=currentTerm(Y))

#
# Attempting to prove this invariant. Need to make sure the definition is correct first, though.
#
invariant [monotonic_log_terms] (indlt(I,J) & ~(J=indzero) & indlt(J,loglen(X)) & ~(log(X,J)=0)) -> lte(log(X,I),log(X,J))
# invariant [monotonic_log_terms] lte(log(X,I),log(X,J))


#
# Manually generated inductive invariant 
#

# invariant [leader_implies_quorum_at_term] leader(X) -> (exists Y:quorum. (member(Z,Y) -> lte(currentTerm(Z), currentTerm(X))))
# invariant [leader_implies_quorum_at_term] (state(X) = primary) -> (exists Y:quorum. member(Z,Y) -> (currentTerm(Z) = currentTerm(X)) | lt(currentTerm(X), currentTerm(Z)))

 
#
# IC3PO generated inductive invariants.
#

# invariant [ic3po_prop1]	(forall Y, X . ((leader(X) & leader(Y) & ~(X = Y)) -> ~(currentTerm(X) = currentTerm(Y))))
# invariant [ic3po_global1]	(forall Q0 . (exists S0 . (forall S1, T0, T1 . ((((S1 = S0) | (currentTerm(S0) = T0)) & (currentTerm(S1) = T1)) -> ((T0 = T1) | lt(T1, T0) | member(S1, Q0))))))


# interpret server -> {0..0}
# interpret term -> {0..2}
# interpret quorum -> {0..2}
# interpret index -> {0..1}

