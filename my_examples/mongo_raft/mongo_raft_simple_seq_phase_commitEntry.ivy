#lang ivy1.7

#
# Simplified version of MongoDB Raft protocol in Ivy
#

type server
type term
type quorum
type index
type phase

#
# Axioms on the sorts used in the protocol.
#

# Any two quorums must overlap.
relation member(N:server, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:server. member(N, Q1) & member(N, Q2)

# Less than relation on terms to provide total order.
individual termzero:term
relation lte(X:term,Y:term)
axiom lte(termzero, X:term)
axiom lte(X:term, X) # Reflexivity
axiom ~lte(X:term, Y) | ~lte(Y, Z) | lte(X, Z) # transitivity
axiom ~lte(X:term, Y) | ~lte(Y, X) | X = Y # anti-symmetric
axiom lte(X:term, Y) | lte(Y, X) # totality


# Less than relation on log indices to provide total order.
individual indzero:index
relation indlt(X:index, Y:index)
axiom indlt(X:index,Y) & indlt(Y,Z) -> indlt(X,Z)
axiom ~indlt(X:index,X)
axiom indlt(X:index,Y) | (X = Y) | indlt(Y,X)
axiom X:index = indzero | indlt(indzero, X)

# function indlte(A:index,B:index):bool
# definition indlte(A,B) = indlt(A,B) | (A = B)

relation indlte(A:index,B:index)
axiom indlte(A:index,B:index) = indlt(A,B) | (A = B)

# Define successor relation for indices.
relation succ(X:index,Z:index)
axiom succ(X,Z) -> (indlt(X,Z) & ~(indlt(X,Y) & indlt(Y,Z)))

# relation succ(X:index,Y:index)
# definition succ(x:index,y:index) = (~indlte(y,x) & forall Z:index. ~indlte(Z,x) -> indlte(y,Z))
# axiom ~succ(indzero, X:index)





individual curr_phase : phase

individual phase_becomeLeader : phase
individual phase_clientRequest : phase
individual phase_getEntries : phase
individual phase_commitEntry : phase

axiom ~(phase_becomeLeader = phase_clientRequest) & ~(phase_becomeLeader = phase_getEntries) & ~(phase_becomeLeader = phase_commitEntry) 
axiom ~(phase_clientRequest = phase_getEntries) & ~(phase_clientRequest = phase_commitEntry)
axiom ~(phase_getEntries = phase_commitEntry)



#
# State variables.
#

# VARIABLE currentTerm
# VARIABLE state
# VARIABLE log
# VARIABLE config
# VARIABLE committed

# A server's current term.
function currentTerm(X:server) : term

# Whether a server is currently acting as a leader.
#function state(X:server) : state_t
relation leader(X:server)

# The logs of each server.
function log(X:server, I:index):term

# The current length of the log on server X.
function loglen(X:server) : index

# The set of committed log entries.
relation committed(I:index, T:term)

after init {
    leader(X) := *;
    currentTerm(X) := *;
    loglen(X) := *;
    log(X,I) := *;
    committed(I,T) := false;

    curr_phase := phase_commitEntry;

    # Election safety.
    require (leader(X) & leader(Y) & ~(X=Y)) -> ~(currentTerm(X)=currentTerm(Y));
    require (exists Q0 . (forall T0, S0, S1, T1 . (((currentTerm(S0) = T0) & (currentTerm(S1) = T1) & leader(S1) & member(S0, Q0)) -> lte(T1, T0))));

    # Monotonic log terms and log matching.
    require (forall J, X, I . ((succ(I, J) & indlte(J, loglen(X))) -> lte(log(X, I), log(X, J))));
	require (forall S0 . (termzero = log(S0, indzero)));
	require (forall I0, S0 . ((termzero = log(S0, I0)) | leader(S0)));
	require (forall I0, S0 . ((currentTerm(S0) = log(S0, I0)) | (termzero = log(S0, I0))));
	require (forall I0, S0 . ((log(S0, I0) = currentTerm(S0)) -> (log(S0, loglen(S0)) = currentTerm(S0))));

    require (forall I . lte(log(I, loglen(I)), currentTerm(I)));
    require (forall S0, I0 . ((log(S0, I0) = termzero) | leader(S0)));
}


# Does node 'x' have a newer or equal log than node 'y'
# definition logGTE(x,y) = (loglen(Y) = 0) | (lastTerm(y) = lastTerm(x) & indlt(loglen(y), loglen(x))) | lt(lastTerm(y),lastTerm(x))

# Can server 'i' vote for server 'j' in term 't'.
#definition canVoteFor(I,J) = true #lt(currentTerm(j), t) #& logGTE(j,i)

# Server 'i' becomes leader by using the next term.
action becomeLeader(i:server, q:quorum, newterm:term) = {
    require curr_phase = phase_becomeLeader;
    # Must garner a quorum of voters that haven't voted in this term,
    # and primary votes for itself.
    require ~(newterm = termzero);
    require lte(currentTerm(i), newterm) & ~(newterm = currentTerm(i));
    require member(i,q);
    require forall X. member(X,q) -> (lte(currentTerm(X), newterm) & ~(currentTerm(X) = newterm));
    
    # Log check (TODO)
    require forall X. member(X,q) -> ( (loglen(X) = indzero) | ( (log(i, loglen(i)) = log(X, loglen(X)) ) & indlt(loglen(i), loglen(X))) | ( lte(log(X, loglen(X)), log(i, loglen(i))) & ~(log(X, loglen(X)) = log(i, loglen(i))) ) );


    # Something a bit weaker.
    # require forall X. member(X,q) -> (loglen(X) = indzero);

    # Try something even stronger for debugging.
    #require forall X. (loglen(X) = indzero);

    # Update term and state of servers. /
    currentTerm(J) := newterm if member(J,q) else currentTerm(J);
    leader(J) := true if J=i else (false if member(J,q) else leader(J));
}

# Leader 'i' writes down a new entry.
action clientRequest(i:server, nextInd:index) = {
    require curr_phase = phase_clientRequest;

    require leader(i);

    # Only write one log entry in your term.
    require ~(log(i,loglen(i))=currentTerm(i));

    # require succ(loglen(i), nextInd);
    # require indlt(loglen(i),nextInd); 
    require succ(loglen(i), nextInd);
    log(i, nextInd) := currentTerm(i);
    loglen(i) := nextInd;
}

# Server 'i' sends a log entry to server 'j'.
action getEntries(i:server, j:server, nextInd:index) = {
    require curr_phase = phase_getEntries;

    require ~leader(i); # only allow secondaries to replicate entries.
    require ~(indzero = loglen(i)); # i cannot have an empty log.
    require indlt(loglen(j), loglen(i)); # i should have a longer log than j.
    require succ(loglen(j), nextInd);

    # Log consistency check. An empty log can always receive log entries.
    require true if (loglen(j)=indzero) else (log(j,loglen(j)) = log(i, loglen(i)));
    
    # Append the new entry to j's log.
    log(j, nextInd) := log(i, nextInd);
    loglen(j) := nextInd;
}

# Leader i commits its latest entry.
action commitEntry(i:server, q:quorum) = {
    require curr_phase = phase_commitEntry;

    require leader(i);
    require ~(loglen(i) = indzero);
    require member(i,q);
    # require indlt(indzero, loglen(i));

    # Can only commit entries in your current term.
    require log(i, loglen(i)) = currentTerm(i);

    # All members in quorum have the entry and are in term of the primary.
    require forall X. member(X,q) -> currentTerm(X) = currentTerm(i);
    require forall X. member(X,q) -> (indlte(loglen(X), loglen(i))) & (log(X, loglen(i)) = log(i, loglen(i)));
    committed(loglen(i), log(i, loglen(i))) := true;
}

export becomeLeader
# export clientRequest
# export getEntries
export commitEntry

action next_phase1 = {
    require curr_phase = phase_becomeLeader;
    curr_phase := phase_clientRequest;
}
action next_phase2 = {
    require curr_phase = phase_clientRequest;
    curr_phase := phase_getEntries;
}
action next_phase3 = {
    require curr_phase = phase_getEntries;
    curr_phase := phase_commitEntry;
}
action next_phase4 = {
    require curr_phase = phase_commitEntry;
    curr_phase := phase_becomeLeader;
}
# export next_phase1
# export next_phase2
# export next_phase3
export next_phase4

#
# Some basic lemma invariants of Raft.
#

# invariant [election_safety] (leader(X) & leader(Y) & ~(X=Y)) -> ~(currentTerm(X)=currentTerm(Y))
# invariant [election_safety_a1] (leader(X) & currentTerm(X)=T) -> exists Q:quorum. member(Y,Q) -> lte(currentTerm(X), currentTerm(Y))

# If a log entry has been written down it must have been by a primary.
# invariant [client_request_safety] ~(loglen(I) = indzero) -> leader(I)

# The logs of secondaries are prefixes of the logs of some primary.
# invariant [get_entries_safety] forall X. exists Y. (log(X,I) = log(Y,I) & leader(Y) & ~leader(X)) -> ( indlte(loglen(X),loglen(Y)) & ( (indlte(J,loglen(X)) & ~(J=indzero)) -> (log(X,J) = log(Y,J)) ) )

# Terms increase monotonically in a server's log.
# invariant [monotonic_log_terms] (succ(I,J) & indlte(J, loglen(X))) -> lte(log(X,I),log(X,J))
# invariant [monotonic_log_terms] ( (log(X,I) = log(Y,I) & indlt(J,I)) -> (log(X,J) = log(X,J))) & ( (succ(I,J) & indlte(J, loglen(X))) -> lte(log(X,I),log(X,J)) )

# An (index, term) pair uniquely identifies log prefix.
# invariant [log_matching] (log(X,I) = log(Y,I) & indlt(J,I)) -> (log(X,J) = log(X,J))

# When a leader gets elected, it must have all entries committed in previous terms.
# invariant [leader_completeness] ( committed(I,T) & leader(X) & (lte(T, currentTerm(X)) &  ~(T=currentTerm(X))) ) -> (log(X,I) = T)
# invariant [leader_completeness] ( (leader(X) & currentTerm(X)=T) -> exists Q:quorum. member(Y,Q) -> lte(currentTerm(X), currentTerm(Y)) ) & ( (succ(I,J) & indlte(J, loglen(X))) -> lte(log(X,I),log(X,J)) ) & (committed(I,T) & leader(X) & (lte(T, currentTerm(X)) &  ~(T=currentTerm(X)))) -> log(X,I) = T
# invariant [l1] committed(I,T) -> ~(I = indzero)
# invariant [l2] committed(I,T) -> exists X. log(X,I)=T

# If an entry is committed, then it must be present on a quorum of servers.
# invariant [leader_completeness] ( committed(I,T) & leader(X) & (lte(T, currentTerm(X)) &  ~(T=currentTerm(X))) ) -> (log(X,I) = T)
invariant [committed_on_quorum] committed(I,T) -> (exists Q. member(X,Q) -> log(X,I)=T)





# At most one unique log entry can be committed at a particular log index.
#invariant [sm_safety] (committed(I,T0) & committed(J,T1) & (I=J)) -> (T0 = T1)


#
# Manually generated inductive invariant 
#

# invariant [leader_implies_quorum_at_term] leader(X) -> (exists Y:quorum. (member(Z,Y) -> lte(currentTerm(Z), currentTerm(X))))
# invariant [leader_implies_quorum_at_term] (state(X) = primary) -> (exists Y:quorum. member(Z,Y) -> (currentTerm(Z) = currentTerm(X)) | lt(currentTerm(X), currentTerm(Z)))

 
#
# IC3PO generated inductive invariants.
#

# invariant [ic3po_prop1]	(forall Y, X . ((leader(X) & leader(Y) & ~(X = Y)) -> ~(currentTerm(X) = currentTerm(Y))))
# invariant [ic3po_global1]	(forall Q0 . (exists S0 . (forall S1, T0, T1 . ((((S1 = S0) | (currentTerm(S0) = T0)) & (currentTerm(S1) = T1)) -> ((T0 = T1) | lt(T1, T0) | member(S1, Q0))))))


# interpret server -> {0..1}
# interpret term -> {0..1}
# interpret quorum -> {0..3}
# interpret index -> {0..1}
