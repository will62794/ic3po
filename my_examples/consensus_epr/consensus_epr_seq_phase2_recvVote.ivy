#lang ivy1.7

type node
type value
type quorum
type phase

relation member(N:node, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:node. member(N, Q1) & member(N, Q2)

relation vote_request_msg(N0:node, N1:node)
relation voted(N:node)
relation vote_msg(N0:node, N1:node)
relation votes(N0:node, N1:node)
relation leader(N:node)
relation decided(N:node, V:value)

after init  {
	vote_request_msg(N1, N2) := true;
	vote_msg(N1, N2) := *;
  voted(N) := *;

	votes(N1, N2) := false;
	leader(N1) := false;
	decided(N, V) := false;

  # The invariant of the previous 'sendVote' phase holds.
  require (forall I, J, S . (~(I = J) -> (vote_msg(S, I) -> ~vote_msg(S, J))));
  require (forall N0, N1 . (vote_msg(N0, N1) -> voted(N0)));
}

action recv_vote(n: node, sender: node) = {
  require vote_msg(sender, n);
  votes(n, sender) := true;
}

export recv_vote

# (Phase invariant)
# If a node I recorded a vote from node J, then J must have actually voted for I.
invariant [safety] (votes(I,J) -> vote_msg(J,I))
