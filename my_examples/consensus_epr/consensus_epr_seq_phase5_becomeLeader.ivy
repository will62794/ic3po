#lang ivy1.7

type node
type value
type quorum
type phase

relation member(N:node, Q:quorum)
axiom forall Q1:quorum, Q2:quorum. exists N:node. member(N, Q1) & member(N, Q2)

relation vote_request_msg(N0:node, N1:node)
relation voted(N:node)
relation vote_msg(N0:node, N1:node)
relation votes(N0:node, N1:node)
relation leader(N:node)
relation decided(N:node, V:value)

after init  {
	vote_request_msg(N1, N2) := true;
  
	vote_msg(N1, N2) := *;
  voted(N) := *;

	votes(N1, N2) := *;

	leader(N1) := *;
	decided(N, V) := false;

  # The invariant of the previous 'sendVote' phase holds.
  require (forall I, J, S . (~(I = J) -> (vote_msg(S, I) -> ~vote_msg(S, J))));
  require (forall N0, N1 . (vote_msg(N0, N1) -> voted(N0)));

  # The invariant of the 'recvVote' phase holds.
  require (forall I, J, S . ((votes(I, S) & votes(J, S)) -> (I = J)));
  require (forall N0, N1, N2 . ((vote_msg(N1, N2) & vote_msg(N1, N0)) -> (N0 = N2)));
  require (forall N0, N1 . (votes(N1, N0) -> vote_msg(N0, N1)));

  # The invariant of the 'becomeLeader' phase holds.
  require (forall I, J . ((leader(I) & leader(J)) -> (I = J)));
  require (forall N0, N1 . (votes(N1, N0) -> vote_msg(N0, N1)));
  require (exists Q1 . (forall N2, Q0, N0, N1 . ((((Q0 = Q1) | member(N1, Q1)) & leader(N0) & member(N2, Q0)) -> (votes(N0, N1) | votes(N0, N2)))));
  require (forall N2, N0, N1 . ((vote_msg(N1, N2) & vote_msg(N1, N0)) -> (N0 = N2)));

  # The invariant of the 'decide' phase holds.
  require (forall N1, N2, V1, V2 . ((decided(N1, V1) & decided(N2, V2)) -> (V1 = V2)));
  require (forall N1, V0, N0 . ((decided(N1, V0) & leader(N0)) -> (N0 = N1)));
  require (forall N1, N0 . ((leader(N0) & leader(N1)) -> (N0 = N1)));
}

action become_leader(n: node, q: quorum) = {
  require member(N, q) -> votes(n, N);
  leader(n) := true;
}

export become_leader

# (Phase invariant)
# At most one value is decided upon.
invariant [safety] (decided(N1, V1) & decided(N2, V2) -> V1 = V2)